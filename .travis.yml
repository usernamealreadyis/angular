From fba69b2a9f64f2eef4bedadf4468f985dc73d390 Mon Sep 17 00:00:00 2001
From: usernamealreadyis <jayashipping@hotmail.com>
Date: Fri, 1 Jan 2016 23:52:39 +0700
Subject: [PATCH 01/12] Create clone.git

---
 clone/clone.git | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 clone/clone.git

diff --git a/clone/clone.git b/clone/clone.git
new file mode 100644
index 0000000..3121304
--- /dev/null
+++ b/clone/clone.git
@@ -0,0 +1 @@
+~ $ git@gist.github.com:51ca261c09faafb90c0a.git

From 9d28147acb4052c30cb11de08fd8b41ceb05f89d Mon Sep 17 00:00:00 2001
From: Hank Duan <duan.hank@gmail.com>
Date: Mon, 28 Dec 2015 17:47:49 -0800
Subject: [PATCH 02/12] fix(benchpress): fix flake

memory was not allocated to be high enough, resulting in partial results to be
clipped, and therefore failing the assertions

Closes #6161
---
 modules/benchpress/src/firefox_extension/lib/main.ts | 2 +-
 modules/benchpress/test/firefox_extension/spec.ts    | 1 +
 scripts/ci/test_e2e_js.sh                            | 5 +----
 3 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/modules/benchpress/src/firefox_extension/lib/main.ts b/modules/benchpress/src/firefox_extension/lib/main.ts
index f6214ea..b56dde8 100644
--- a/modules/benchpress/src/firefox_extension/lib/main.ts
+++ b/modules/benchpress/src/firefox_extension/lib/main.ts
@@ -54,7 +54,7 @@ mod.PageMod({
   contentScriptFile: data.url('installed_script.js'),
   onAttach: worker => {
     worker.port.on('startProfiler',
-                   (timeStarted) => profiler.start(/* = profiler memory */ 1000000, 0.1,
+                   (timeStarted) => profiler.start(/* = profiler memory */ 3000000, 0.1,
                                                    ['leaf', 'js', 'stackwalk', 'gc'], timeStarted));
     worker.port.on('stopProfiler', () => profiler.stop());
     worker.port.on('getProfile',
diff --git a/modules/benchpress/test/firefox_extension/spec.ts b/modules/benchpress/test/firefox_extension/spec.ts
index 454f7c1..9b9cf24 100644
--- a/modules/benchpress/test/firefox_extension/spec.ts
+++ b/modules/benchpress/test/firefox_extension/spec.ts
@@ -24,6 +24,7 @@ describe('firefox extension', function() {
     browser.executeScript('window.startProfiler()')
         .then(function() { console.log('started measuring perf'); });
 
+    browser.executeAsyncScript('setTimeout(arguments[0], 1000);');
     browser.executeScript('window.forceGC()');
 
     browser.executeAsyncScript('var cb = arguments[0]; window.getProfile(cb);')
diff --git a/scripts/ci/test_e2e_js.sh b/scripts/ci/test_e2e_js.sh
index 6a40470..449a8a4 100755
--- a/scripts/ci/test_e2e_js.sh
+++ b/scripts/ci/test_e2e_js.sh
@@ -30,8 +30,5 @@ fi
 
 ./node_modules/.bin/protractor protractor-js.conf.js $OPTIONS
 ./node_modules/.bin/protractor protractor-js.conf.js $OPTIONS --benchmark --dryrun
-# TODO(tbosch): tests for benchpress on firefox are disabled
-# as they are very flake. Enable once https://github.com/angular/angular/issues/5611
-# is resolved.
-# ./node_modules/.bin/protractor dist/js/cjs/benchpress/test/firefox_extension/conf.js
+./node_modules/.bin/protractor dist/js/cjs/benchpress/test/firefox_extension/conf.js
 

From a038bb9ae3a3464ba1f46c1adaabdcdc774577a0 Mon Sep 17 00:00:00 2001
From: Brian Ford <btford@umich.edu>
Date: Tue, 15 Dec 2015 15:58:04 -0800
Subject: [PATCH 03/12] fix(router): preserve specificity for redirects

Previously when comparing which of multiple possible routes to choose in
an ambiguous case, we looked at the specificity of the target of redirect
matches rather than the original match. This meant that if a redirect
used a whilecard, but redirected to a target that was a static path,
we'd cound the static path's specificity instead of the wildcard.

This change stores the specificity of the redirect on the RedirectInstruction.

Closes #5933
---
 modules/angular2/src/router/instruction.ts          |  4 +++-
 modules/angular2/src/router/route_registry.ts       |  2 +-
 .../router/integration/impl/fixture_components.ts   |  6 ++++++
 .../test/router/integration/redirect_route_spec.ts  | 21 ++++++++++++++++++++-
 4 files changed, 30 insertions(+), 3 deletions(-)

diff --git a/modules/angular2/src/router/instruction.ts b/modules/angular2/src/router/instruction.ts
index 815745b..817e91a 100644
--- a/modules/angular2/src/router/instruction.ts
+++ b/modules/angular2/src/router/instruction.ts
@@ -281,9 +281,11 @@ export class UnresolvedInstruction extends Instruction {
 
 export class RedirectInstruction extends ResolvedInstruction {
   constructor(component: ComponentInstruction, child: Instruction,
-              auxInstruction: {[key: string]: Instruction}) {
+              auxInstruction: {[key: string]: Instruction}, private _specificity: string) {
     super(component, child, auxInstruction);
   }
+
+  get specificity(): string { return this._specificity; }
 }
 
 
diff --git a/modules/angular2/src/router/route_registry.ts b/modules/angular2/src/router/route_registry.ts
index dbf757f..5750396 100644
--- a/modules/angular2/src/router/route_registry.ts
+++ b/modules/angular2/src/router/route_registry.ts
@@ -205,7 +205,7 @@ export class RouteRegistry {
             var instruction =
                 this.generate(candidate.redirectTo, ancestorInstructions.concat([null]));
             return new RedirectInstruction(instruction.component, instruction.child,
-                                           instruction.auxInstruction);
+                                           instruction.auxInstruction, candidate.specificity);
           }
         }));
 
diff --git a/modules/angular2/test/router/integration/impl/fixture_components.ts b/modules/angular2/test/router/integration/impl/fixture_components.ts
index 075213b..5777bf1 100644
--- a/modules/angular2/test/router/integration/impl/fixture_components.ts
+++ b/modules/angular2/test/router/integration/impl/fixture_components.ts
@@ -10,6 +10,12 @@ import {
 } from 'angular2/router';
 import {PromiseWrapper} from 'angular2/src/facade/async';
 
+@Component({selector: 'goodbye-cmp', template: `{{farewell}}`})
+export class GoodbyeCmp {
+  farewell: string;
+  constructor() { this.farewell = 'goodbye'; }
+}
+
 @Component({selector: 'hello-cmp', template: `{{greeting}}`})
 export class HelloCmp {
   greeting: string;
diff --git a/modules/angular2/test/router/integration/redirect_route_spec.ts b/modules/angular2/test/router/integration/redirect_route_spec.ts
index 4c2f195..963fc78 100644
--- a/modules/angular2/test/router/integration/redirect_route_spec.ts
+++ b/modules/angular2/test/router/integration/redirect_route_spec.ts
@@ -25,7 +25,7 @@ import {
 } from 'angular2/src/router/route_config_decorator';
 
 import {TEST_ROUTER_PROVIDERS, RootCmp, compile} from './util';
-import {HelloCmp, RedirectToParentCmp} from './impl/fixture_components';
+import {HelloCmp, GoodbyeCmp, RedirectToParentCmp} from './impl/fixture_components';
 
 var cmpInstanceCount;
 var childCmpInstanceCount;
@@ -117,5 +117,24 @@ export function main() {
                async.done();
              });
        }));
+
+
+    it('should not redirect when redirect is less specific than other matching routes',
+       inject([AsyncTestCompleter, Location], (async, location) => {
+         compile(tcb)
+             .then((rtc) => {rootTC = rtc})
+             .then((_) => rtr.config([
+               new Route({path: '/foo', component: HelloCmp, name: 'Hello'}),
+               new Route({path: '/:param', component: GoodbyeCmp, name: 'Goodbye'}),
+               new Redirect({path: '/*rest', redirectTo: ['/Hello']})
+             ]))
+             .then((_) => rtr.navigateByUrl('/bye'))
+             .then((_) => {
+               rootTC.detectChanges();
+               expect(rootTC.debugElement.nativeElement).toHaveText('goodbye');
+               expect(location.urlChanges).toEqual(['/bye']);
+               async.done();
+             });
+       }));
   });
 }

From b44d36cf955acd81a3e7285ab0e1acbffe8c8dcc Mon Sep 17 00:00:00 2001
From: vsavkin <avix1000@gmail.com>
Date: Wed, 16 Dec 2015 15:30:29 -0800
Subject: [PATCH 04/12] fix(forms): fix SelectControlValueAccessor not to call
 onChange twice

Closes #5969
---
 .../src/common/forms/directives/select_control_value_accessor.ts    | 6 +-----
 modules/angular2/test/common/forms/integration_spec.ts              | 2 +-
 2 files changed, 2 insertions(+), 6 deletions(-)

diff --git a/modules/angular2/src/common/forms/directives/select_control_value_accessor.ts b/modules/angular2/src/common/forms/directives/select_control_value_accessor.ts
index 230631d..2fe527a 100644
--- a/modules/angular2/src/common/forms/directives/select_control_value_accessor.ts
+++ b/modules/angular2/src/common/forms/directives/select_control_value_accessor.ts
@@ -36,11 +36,7 @@ export class NgSelectOption {
  */
 @Directive({
   selector: 'select[ngControl],select[ngFormControl],select[ngModel]',
-  host: {
-    '(change)': 'onChange($event.target.value)',
-    '(input)': 'onChange($event.target.value)',
-    '(blur)': 'onTouched()'
-  },
+  host: {'(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()'},
   bindings: [SELECT_VALUE_ACCESSOR]
 })
 export class SelectControlValueAccessor implements ControlValueAccessor {
diff --git a/modules/angular2/test/common/forms/integration_spec.ts b/modules/angular2/test/common/forms/integration_spec.ts
index 7635320..a2d66e5 100644
--- a/modules/angular2/test/common/forms/integration_spec.ts
+++ b/modules/angular2/test/common/forms/integration_spec.ts
@@ -348,7 +348,7 @@ export function main() {
              expect(sfOption.nativeElement.selected).toBe(true);
 
              select.nativeElement.value = 'NYC';
-             dispatchEvent(select.nativeElement, "change");
+             dispatchEvent(select.nativeElement, "input");
 
              expect(fixture.debugElement.componentInstance.form.value).toEqual({"city": 'NYC'});
              expect(sfOption.nativeElement.selected).toBe(false);

From 4291758079ca6b312ec8f5b274ead5a8c2f79494 Mon Sep 17 00:00:00 2001
From: mlaval <mlaval@amadeus.com>
Date: Thu, 10 Dec 2015 14:40:00 +0100
Subject: [PATCH 05/12] build(sauce/bs): make some browsers required in CI

Closes #5795
---
 .travis.yml                     | 10 ++++---
 browser-providers.conf.js       | 62 +++++++++++++++++++++++++++++++++--------
 gulpfile.js                     | 13 +++++++--
 karma-js.conf.js                |  4 +--
 scripts/ci/build_and_test.sh    |  6 ++--
 scripts/ci/test_browserstack.sh |  4 ++-
 scripts/ci/test_saucelabs.sh    |  4 ++-
 7 files changed, 78 insertions(+), 25 deletions(-)

diff --git a/.travis.yml b/.travis.yml
index 80d9d75..ec2f2e1 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -37,8 +37,10 @@ env:
     # Order: a slower build first, so that we don't occupy an idle travis worker waiting for others to complete.
     - MODE=dart DART_CHANNEL=stable DART_VERSION=$DART_STABLE_VERSION
     - MODE=dart DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
-    - MODE=saucelabs DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
-    - MODE=browserstack DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
+    - MODE=saucelabs_required DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
+    - MODE=browserstack_required DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
+    - MODE=saucelabs_optional DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
+    - MODE=browserstack_optional DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
     - MODE=dart_experimental DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
     - MODE=js DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
     - MODE=router DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
@@ -48,8 +50,8 @@ env:
 
 matrix:
   allow_failures:
-  - env: "MODE=saucelabs DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"
-  - env: "MODE=browserstack DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"
+  - env: "MODE=saucelabs_optional DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"
+  - env: "MODE=browserstack_optional DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"
   - env: "MODE=dart_experimental DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"
   # TODO(alxhub): remove when dartdoc #1039 is in dev channel
   - env: "MODE=dart DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"
diff --git a/browser-providers.conf.js b/browser-providers.conf.js
index 5fb1028..37877ce 100644
--- a/browser-providers.conf.js
+++ b/browser-providers.conf.js
@@ -1,3 +1,32 @@
+// Unique place to configure the browsers which are used in the different CI jobs in Sauce Labs (SL) and BrowserStack (BS).
+// If the target is set to null, then the browser is not run anywhere during CI.
+// If a category becomes empty (e.g. BS and required), then the corresponding job must be commented out in Travis configuration.
+var CIconfiguration = {
+  'Chrome':       { unitTest: {target: 'SL', required: true}, e2e: {target: null, required: true}},
+  'Firefox':      { unitTest: {target: 'SL', required: true}, e2e: {target: null, required: true}},
+  'ChromeBeta':   { unitTest: {target: 'SL', required: true}, e2e: {target: null, required: true}},
+  'FirefoxBeta':  { unitTest: {target: 'SL', required: true}, e2e: {target: null, required: true}},
+  'ChromeDev':    { unitTest: {target: null, required: true}, e2e: {target: null, required: true}},
+  'FirefoxDev':   { unitTest: {target: null, required: true}, e2e: {target: null, required: true}},
+  'IE9':          { unitTest: {target: 'SL', required: false}, e2e: {target: null, required: true}},
+  'IE10':         { unitTest: {target: 'SL', required: true}, e2e: {target: null, required: true}},
+  'IE11':         { unitTest: {target: 'SL', required: true}, e2e: {target: null, required: true}},
+  'Edge':         { unitTest: {target: 'SL', required: true}, e2e: {target: null, required: true}},
+  'Android4.1':   { unitTest: {target: 'SL', required: false}, e2e: {target: null, required: true}},
+  'Android4.2':   { unitTest: {target: 'SL', required: false}, e2e: {target: null, required: true}},
+  'Android4.3':   { unitTest: {target: 'SL', required: false}, e2e: {target: null, required: true}},
+  'Android4.4':   { unitTest: {target: 'SL', required: false}, e2e: {target: null, required: true}},
+  'Android5':     { unitTest: {target: 'SL', required: false}, e2e: {target: null, required: true}},
+  'Safari7':      { unitTest: {target: 'BS', required: false}, e2e: {target: null, required: true}},
+  'Safari8':      { unitTest: {target: 'BS', required: false}, e2e: {target: null, required: true}},
+  'Safari9':      { unitTest: {target: 'BS', required: false}, e2e: {target: null, required: true}},
+  'iOS7':         { unitTest: {target: 'BS', required: true}, e2e: {target: null, required: true}},
+  'iOS8':         { unitTest: {target: 'BS', required: false}, e2e: {target: null, required: true}},
+  // TODO(mlaval): iOS9 deactivated as not reliable, reactivate after https://github.com/angular/angular/issues/5408
+  'iOS9':         { unitTest: {target: null, required: false}, e2e: {target: null, required: true}},
+  'WindowsPhone': { unitTest: {target: 'BS', required: false}, e2e: {target: null, required: true}}
+};
+
 var customLaunchers = {
   'DartiumWithWebPlatform': {
     base: 'Dartium',
@@ -47,7 +76,7 @@ var customLaunchers = {
     platform: 'OS X 10.10',
     version: '8'
   },
-  'SL_SAFARI9.0': {
+  'SL_SAFARI9': {
     base: 'SauceLabs',
     browserName: 'safari',
     platform: 'OS X 10.11',
@@ -119,7 +148,7 @@ var customLaunchers = {
     platform: 'Linux',
     version: '4.4'
   },
-  'SL_ANDROID5.1': {
+  'SL_ANDROID5': {
     base: 'SauceLabs',
     browserName: 'android',
     platform: 'Linux',
@@ -239,21 +268,18 @@ var customLaunchers = {
   }
 };
 
-// iOS9 deactivated as not reliable in both providers
-// TODO(mlaval): reactivate after https://github.com/angular/angular/issues/5408
-
 var sauceAliases = {
   'ALL': Object.keys(customLaunchers).filter(function(item) {return customLaunchers[item].base == 'SauceLabs';}),
-  'DESKTOP': ['SL_CHROME', 'SL_FIREFOX', 'SL_IE9', 'SL_IE10', 'SL_IE11', 'SL_EDGE', 'SL_SAFARI7', 'SL_SAFARI8', 'SL_SAFARI9.0'],
-  'MOBILE': ['SL_ANDROID4.1', 'SL_ANDROID4.2', 'SL_ANDROID4.3', 'SL_ANDROID4.4', 'SL_ANDROID5.1', 'SL_IOS7', 'SL_IOS8', 'SL_IOS9'],
-  'ANDROID': ['SL_ANDROID4.1', 'SL_ANDROID4.2', 'SL_ANDROID4.3', 'SL_ANDROID4.4', 'SL_ANDROID5.1'],
+  'DESKTOP': ['SL_CHROME', 'SL_FIREFOX', 'SL_IE9', 'SL_IE10', 'SL_IE11', 'SL_EDGE', 'SL_SAFARI7', 'SL_SAFARI8', 'SL_SAFARI9'],
+  'MOBILE': ['SL_ANDROID4.1', 'SL_ANDROID4.2', 'SL_ANDROID4.3', 'SL_ANDROID4.4', 'SL_ANDROID5', 'SL_IOS7', 'SL_IOS8', 'SL_IOS9'],
+  'ANDROID': ['SL_ANDROID4.1', 'SL_ANDROID4.2', 'SL_ANDROID4.3', 'SL_ANDROID4.4', 'SL_ANDROID5'],
   'IE': ['SL_IE9', 'SL_IE10', 'SL_IE11'],
   'IOS': ['SL_IOS7', 'SL_IOS8', 'SL_IOS9'],
-  'SAFARI': ['SL_SAFARI7', 'SL_SAFARI8', 'SL_SAFARI9.0'],
+  'SAFARI': ['SL_SAFARI7', 'SL_SAFARI8', 'SL_SAFARI9'],
   'BETA': ['SL_CHROMEBETA', 'SL_FIREFOXBETA'],
   'DEV': ['SL_CHROMEDEV', 'SL_FIREFOXDEV'],
-  'CI': ['SL_CHROME',' SL_FIREFOX', 'SL_CHROMEDEV', 'SL_FIREFOXBETA', 'SL_IE9', 'SL_IE10', 'SL_IE11', 'SL_EDGE',
-    'SL_ANDROID4.1', 'SL_ANDROID4.2', 'SL_ANDROID4.3', 'SL_ANDROID4.4', 'SL_ANDROID5.1']
+  'CI_REQUIRED': buildConfiguration('unitTest', 'SL', true),
+  'CI_OPTIONAL': buildConfiguration('unitTest', 'SL', false)
 };
 
 var browserstackAliases = {
@@ -264,7 +290,8 @@ var browserstackAliases = {
   'IE': ['BS_IE9', 'BS_IE10', 'BS_IE11'],
   'IOS': ['BS_IOS7', 'BS_IOS8', 'BS_IOS9'],
   'SAFARI': ['BS_SAFARI7', 'BS_SAFARI8', 'BS_SAFARI9'],
-  'CI': ['BS_SAFARI7', 'BS_SAFARI8', 'BS_SAFARI9', 'BS_IOS7', 'BS_IOS8', 'BS_WINDOWSPHONE']
+  'CI_REQUIRED': buildConfiguration('unitTest', 'BS', true),
+  'CI_OPTIONAL': buildConfiguration('unitTest', 'BS', false)
 };
 
 module.exports = {
@@ -277,3 +304,14 @@ if (process.env.TRAVIS) {
   process.env.SAUCE_ACCESS_KEY = process.env.SAUCE_ACCESS_KEY.split('').reverse().join('');
   process.env.BROWSER_STACK_ACCESS_KEY = process.env.BROWSER_STACK_ACCESS_KEY.split('').reverse().join('');
 }
+
+function buildConfiguration(type, target, required) {
+  return Object.keys(CIconfiguration)
+    .filter((item) => {
+      var conf = CIconfiguration[item][type];
+      return conf.required === required && conf.target === target;
+    })
+    .map((item) => {
+      return target + '_' + item.toUpperCase();
+    });
+}
diff --git a/gulpfile.js b/gulpfile.js
index fc8f207..6d2b0aa 100644
--- a/gulpfile.js
+++ b/gulpfile.js
@@ -720,12 +720,19 @@ gulp.task('test.unit.js/ci', function(done) {
 });
 
 gulp.task('test.unit.js.sauce/ci', function(done) {
-  launchKarmaWithExternalBrowsers(['dots', 'saucelabs'], browserProvidersConf.sauceAliases.CI,
-                                  done);
+  var browsers = browserProvidersConf.sauceAliases.CI_REQUIRED;
+  if (cliArgs.mode && cliArgs.mode == 'saucelabs_optional') {
+    browsers = browserProvidersConf.sauceAliases.CI_OPTIONAL;
+  }
+  launchKarmaWithExternalBrowsers(['dots', 'saucelabs'], browsers, done);
 });
 
 gulp.task('test.unit.js.browserstack/ci', function(done) {
-  launchKarmaWithExternalBrowsers(['dots'], browserProvidersConf.browserstackAliases.CI, done);
+  var browsers = browserProvidersConf.browserstackAliases.CI_REQUIRED;
+  if (cliArgs.mode && cliArgs.mode == 'browserstack_optional') {
+    browsers = browserProvidersConf.browserstackAliases.CI_OPTIONAL;
+  }
+  launchKarmaWithExternalBrowsers(['dots'], browsers, done);
 });
 
 gulp.task('test.unit.dart/ci', function(done) {
diff --git a/karma-js.conf.js b/karma-js.conf.js
index b407d1c..f2b1375 100644
--- a/karma-js.conf.js
+++ b/karma-js.conf.js
@@ -79,7 +79,7 @@ module.exports = function(config) {
 
   if (process.env.TRAVIS) {
     var buildId = 'TRAVIS #' + process.env.TRAVIS_BUILD_NUMBER + ' (' + process.env.TRAVIS_BUILD_ID + ')';
-    if (process.env.MODE === 'saucelabs') {
+    if (process.env.MODE.startsWith('saucelabs')) {
       config.sauceLabs.build = buildId;
       config.sauceLabs.tunnelIdentifier = process.env.TRAVIS_JOB_NUMBER;
 
@@ -89,7 +89,7 @@ module.exports = function(config) {
       config.transports = ['polling'];
     }
 
-    if (process.env.MODE === 'browserstack') {
+    if (process.env.MODE.startsWith('browserstack')) {
       config.browserStack.build = buildId;
       config.browserStack.tunnelIdentifier = process.env.TRAVIS_JOB_NUMBER;
     }
diff --git a/scripts/ci/build_and_test.sh b/scripts/ci/build_and_test.sh
index 0d4c9ce..02ab2c8 100755
--- a/scripts/ci/build_and_test.sh
+++ b/scripts/ci/build_and_test.sh
@@ -10,8 +10,10 @@ cd $SCRIPT_DIR/../..
 
 if [ "$MODE" = "dart_experimental" ]; then
   ${SCRIPT_DIR}/build_$MODE.sh
-elif [ "$MODE" = "saucelabs" ] || [ "$MODE" = "browserstack" ] ; then
-  ${SCRIPT_DIR}/test_$MODE.sh
+elif [[ $MODE = saucelabs* ]] ; then
+  ${SCRIPT_DIR}/test_saucelabs.sh $MODE
+elif [[ $MODE = browserstack* ]] ; then
+  ${SCRIPT_DIR}/test_browserstack.sh $MODE
 elif [ "$MODE" = "lint" ]; then
   ./node_modules/.bin/gulp static-checks
 elif [ "$MODE" = "build_only" ]; then
diff --git a/scripts/ci/test_browserstack.sh b/scripts/ci/test_browserstack.sh
index 9f6c3a8..fe918f8 100755
--- a/scripts/ci/test_browserstack.sh
+++ b/scripts/ci/test_browserstack.sh
@@ -1,6 +1,8 @@
 #!/bin/bash
 set -e
 
+MODE=$1
+
 echo =============================================================================
 # go to project dir
 SCRIPT_DIR=$(dirname $0)
@@ -9,4 +11,4 @@ cd $SCRIPT_DIR/../..
 ./scripts/browserstack/start_tunnel.sh
 ./scripts/browserstack/waitfor_tunnel.sh
 ./node_modules/.bin/gulp build.js.dev
-./node_modules/.bin/gulp test.unit.js.browserstack/ci
+./node_modules/.bin/gulp test.unit.js.browserstack/ci --mode=$MODE
diff --git a/scripts/ci/test_saucelabs.sh b/scripts/ci/test_saucelabs.sh
index e57c378..8cb5949 100755
--- a/scripts/ci/test_saucelabs.sh
+++ b/scripts/ci/test_saucelabs.sh
@@ -1,6 +1,8 @@
 #!/bin/bash
 set -e
 
+MODE=$1
+
 echo =============================================================================
 # go to project dir
 SCRIPT_DIR=$(dirname $0)
@@ -9,4 +11,4 @@ cd $SCRIPT_DIR/../..
 ./scripts/sauce/sauce_connect_setup.sh
 ./scripts/sauce/sauce_connect_block.sh
 ./node_modules/.bin/gulp build.js.dev
-./node_modules/.bin/gulp test.unit.js.sauce/ci
\ No newline at end of file
+./node_modules/.bin/gulp test.unit.js.sauce/ci --mode=$MODE

From 0b6e75a85eb9b6c14eb0399dd19994d9088827c0 Mon Sep 17 00:00:00 2001
From: Alex Eagle <alexeagle@google.com>
Date: Sun, 3 Jan 2016 09:18:33 -0800
Subject: [PATCH 06/12] chore(ci): cleanup artifact upload

This is no longer needed for g3sync.

Closes #6232
---
 .travis.yml                  | 21 ---------------------
 scripts/ci/build_and_test.sh |  1 -
 2 files changed, 22 deletions(-)

diff --git a/.travis.yml b/.travis.yml
index ec2f2e1..4199ab1 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -111,24 +111,3 @@ notifications:
   slack:
     secure: EP4MzZ8JMyNQJ4S3cd5LEPWSMjC7ZRdzt3veelDiOeorJ6GwZfCDHncR+4BahDzQAuqyE/yNpZqaLbwRWloDi15qIUsm09vgl/1IyNky1Sqc6lEknhzIXpWSalo4/T9ZP8w870EoDvM/UO+LCV99R3wS8Nm9o99eLoWVb2HIUu0=
 
-deploy:
-  - provider: gcs
-    # This is for project angular-github-babysitter
-    access_key_id: GOOGIOQTDBEOPBUAWFZQ
-    secret_access_key:
-      secure: "MEDggllZ5fw4wI9CEUi8WR6jKsKXqdRF/DLxSNC2JpzM5RlVeBm0uqjntYT1Cf1dASvQ2/+vZCUikL/3A48NcoEYRHXGmxu8D6t/SvleQD8Xv434xFOdsa2QqP/HiCtqCLOI5jJz1JVoB5nNyKKZ33ogTUL1LV1TfcrAioyizW8="
-    # this bucket has a lifecycle to delete after 90 days:
-    # $ echo '{"rule": [{"action": {"type": "Delete"}, "condition": {"age": 90}}]}' > lifecycle.json
-    # $ gsutil lifecycle set lifecycle.json gs://angular2-snapshots
-    bucket: angular2-snapshots
-    # don't delete generated files
-    skip_cleanup: true
-    # serve to public at https://storage.googleapis.com/angular2-snapshots/SHA/dist.tgz
-    acl: public-read
-    # upload the .tgz archive created in scripts/ci/build_and_test.sh
-    local-dir: deploy
-    # create a "subdirectory" for each commit
-    upload-dir: $TRAVIS_COMMIT
-    on:
-      repo: angular/angular
-      condition: "$MODE = build_only"
diff --git a/scripts/ci/build_and_test.sh b/scripts/ci/build_and_test.sh
index 02ab2c8..35ffaf6 100755
--- a/scripts/ci/build_and_test.sh
+++ b/scripts/ci/build_and_test.sh
@@ -19,7 +19,6 @@ elif [ "$MODE" = "lint" ]; then
 elif [ "$MODE" = "build_only" ]; then
   ${SCRIPT_DIR}/build_js.sh
   ${SCRIPT_DIR}/build_dart.sh
-  mkdir deploy; tar -czpf deploy/dist.tgz -C dist .
 elif [ "$MODE" = "payload" ]; then
   source ${SCRIPT_DIR}/env_dart.sh
   ./node_modules/.bin/gulp test.payload.dart/ci

From a08f50badd4397e897192e08909838dd6725fe32 Mon Sep 17 00:00:00 2001
From: Tobias Bosch <tbosch1009@gmail.com>
Date: Tue, 29 Dec 2015 17:01:10 -0800
Subject: [PATCH 07/12] chore(build): allow to run examples and benchmarks
 without bundles

The bundles will only be used if the flag `--useBundles` is passed to `gulp build.js`.
---
 gulpfile.js                                        | 31 ++++++++-----
 scripts/ci/build_js.sh                             |  2 +-
 tools/broccoli/angular_builder.ts                  |  7 ++-
 tools/broccoli/html-replace/SCRIPTS.html           | 54 +++++++++++++++-------
 .../broccoli/html-replace/SCRIPTS_benchmarks.html  | 52 +++++++++++++++------
 tools/broccoli/trees/browser_tree.ts               | 15 ++++--
 6 files changed, 113 insertions(+), 48 deletions(-)

diff --git a/gulpfile.js b/gulpfile.js
index 6d2b0aa..1415c67 100644
--- a/gulpfile.js
+++ b/gulpfile.js
@@ -369,7 +369,7 @@ function proxyServeDart() {
 
 // ------------------
 // web servers
-gulp.task('serve.js.dev', ['build.js'], function(neverDone) {
+gulp.task('serve.js.dev', ['build.js.dev'], function(neverDone) {
   var watch = require('./tools/build/watch');
 
   watch('modules/**', {ignoreInitial: true}, '!broccoli.js.dev');
@@ -980,15 +980,19 @@ gulp.task('!build.tools', function() {
 gulp.task('broccoli.js.dev', ['build.tools'],
           function(done) { runSequence('!broccoli.js.dev', sequenceComplete(done)); });
 
-gulp.task(
-    '!broccoli.js.dev',
-    () => angularBuilder.rebuildBrowserDevTree(
-        {generateEs6: generateEs6, projects: cliArgsProjects, noTypeChecks: cliArgs.noTypeChecks}));
+gulp.task('!broccoli.js.dev', () => angularBuilder.rebuildBrowserDevTree({
+  generateEs6: generateEs6,
+  projects: cliArgsProjects,
+  noTypeChecks: cliArgs.noTypeChecks,
+  useBundles: cliArgs.useBundles
+}));
 
-gulp.task(
-    '!broccoli.js.prod',
-    () => angularBuilder.rebuildBrowserProdTree(
-        {generateEs6: generateEs6, projects: cliArgsProjects, noTypeChecks: cliArgs.noTypeChecks}));
+gulp.task('!broccoli.js.prod', () => angularBuilder.rebuildBrowserProdTree({
+  generateEs6: generateEs6,
+  projects: cliArgsProjects,
+  noTypeChecks: cliArgs.noTypeChecks,
+  useBundles: cliArgs.useBundles
+}));
 
 gulp.task('build.js.dev', ['build/clean.js'], function(done) {
   runSequence('broccoli.js.dev', 'build.css.material', sequenceComplete(done));
@@ -1011,9 +1015,12 @@ var firstBuildJsCjs = true;
  * private task
  */
 gulp.task('!build.js.cjs', function() {
-  return angularBuilder
-      .rebuildNodeTree(
-          {generateEs6: generateEs6, projects: cliArgsProjects, noTypeChecks: cliArgs.noTypeChecks})
+  return angularBuilder.rebuildNodeTree({
+                         generateEs6: generateEs6,
+                         projects: cliArgsProjects,
+                         noTypeChecks: cliArgs.noTypeChecks,
+                         useBundles: cliArgs.useBundles
+                       })
       .then(function() {
         if (firstBuildJsCjs) {
           firstBuildJsCjs = false;
diff --git a/scripts/ci/build_js.sh b/scripts/ci/build_js.sh
index 7e9d7ff..78d5b59 100755
--- a/scripts/ci/build_js.sh
+++ b/scripts/ci/build_js.sh
@@ -8,4 +8,4 @@ SCRIPT_DIR=$(dirname $0)
 source $SCRIPT_DIR/env_dart.sh
 cd $SCRIPT_DIR/../..
 
-node --max-old-space-size=2000 ./node_modules/.bin/gulp build.js
\ No newline at end of file
+node --max-old-space-size=2000 ./node_modules/.bin/gulp build.js --useBundles
diff --git a/tools/broccoli/angular_builder.ts b/tools/broccoli/angular_builder.ts
index 66a857b..032278a 100644
--- a/tools/broccoli/angular_builder.ts
+++ b/tools/broccoli/angular_builder.ts
@@ -15,6 +15,7 @@ type Options = {
   projects: ProjectMap;
 noTypeChecks: boolean;
 generateEs6: boolean;
+useBundles: boolean;
 }
 ;
 
@@ -73,7 +74,8 @@ export class AngularBuilder {
           sourceMaps: true,
           projects: opts.projects,
           noTypeChecks: opts.noTypeChecks,
-          generateEs6: opts.generateEs6
+          generateEs6: opts.generateEs6,
+          useBundles: opts.useBundles
         },
         path.join(this.outputPath, 'js', 'dev'));
     return new broccoli.Builder(tree);
@@ -88,7 +90,8 @@ export class AngularBuilder {
           sourceMaps: false,
           projects: opts.projects,
           noTypeChecks: opts.noTypeChecks,
-          generateEs6: opts.generateEs6
+          generateEs6: opts.generateEs6,
+          useBundles: opts.useBundles
         },
         path.join(this.outputPath, 'js', 'prod'));
     return new broccoli.Builder(tree);
diff --git a/tools/broccoli/html-replace/SCRIPTS.html b/tools/broccoli/html-replace/SCRIPTS.html
index 6f7bea5..2195c9a 100644
--- a/tools/broccoli/html-replace/SCRIPTS.html
+++ b/tools/broccoli/html-replace/SCRIPTS.html
@@ -1,26 +1,48 @@
 <script src="es6-shim.js"></script>
 <script src="system.src.js"></script>
 <script>
+  var scriptUrls;
+  var loadRuntimePackages = [
+    'angular2_material',
+    'benchmarks',
+    'playground',
+    // TODO(rado): These helpers don't end up in the bundle, thus they should
+    // not even be in src/*. Move them!
+    'angular2/src/testing/benchmark_util',
+    'angular2/src/facade/browser',
+    'angular2/bootstrap',
+    'rxjs'
+  ];
+  if (@@USE_BUNDLES) {
+    scriptUrls = [
+      '/bundle/angular2-polyfills.js',
+      '/bundle/angular2.dev.js',
+      '/bundle/http.js',
+      '/bundle/router.dev.js',
+      '/rxjs/bundles/Rx.js'
+    ];
+  } else {
+    console.warn("Not using the Angular 2 bundle. "+
+        "Don't use this configuration for e2e/performance tests!")
+    loadRuntimePackages.push('angular2');
+    scriptUrls = [
+      'Reflect.js',
+      'zone-microtask.js',
+      'long-stack-trace-zone.js'
+    ];
+  }
+  var systemJsPackages = {};
+  loadRuntimePackages.forEach(function(pck) {
+    systemJsPackages[pck] = {defaultExtension: 'js'};
+  });
   System.config({
     baseURL: '/',
-    packages: {
-      'angular2_material': {defaultExtension: 'js'},
-      'benchmarks': {defaultExtension: 'js'},
-      'playground': {defaultExtension: 'js'},
-      // TODO(rado): These helpers don't end up in the bundle, thus they should
-      // not even be in src/*. Move them!
-      'angular2/src/testing/benchmark_util': {defaultExtension: 'js'},
-      'angular2/src/facade/browser': {defaultExtension: 'js'},
-      'angular2/bootstrap': {defaultExtension: 'js'},
-      'rxjs': {defaultExtension: 'js'},
-    }
+    packages: systemJsPackages
   });
+  for (var i=0; i<scriptUrls.length; i++) {
+    document.write('<script src="'+scriptUrls[i]+'"></'+'script>');
+  }
 </script>
-<script src="/bundle/angular2-polyfills.js"></script>
-<script src="/bundle/angular2.dev.js"></script>
-<script src="/bundle/http.js"></script>
-<script src="/bundle/router.dev.js"></script>
-<script src="/rxjs/bundles/Rx.js"></script>
 <script>
   var filename = '@@PATH/@@FILENAME';
   System.import(filename).then(function(m) { m.main(); }, console.error.bind(console));
diff --git a/tools/broccoli/html-replace/SCRIPTS_benchmarks.html b/tools/broccoli/html-replace/SCRIPTS_benchmarks.html
index 3996862..f18b58e 100644
--- a/tools/broccoli/html-replace/SCRIPTS_benchmarks.html
+++ b/tools/broccoli/html-replace/SCRIPTS_benchmarks.html
@@ -2,24 +2,48 @@
 <script src="url_params_to_form.js"></script>
 <script src="system.src.js"></script>
 <script>
+  var scriptUrls;
+  var loadRuntimePackages = [
+    'angular2_material',
+    'benchmarks',
+    'playground',
+    // TODO(rado): These helpers don't end up in the bundle, thus they should
+    // not even be in src/*. Move them!
+    'angular2/src/testing/benchmark_util',
+    'angular2/src/facade/browser',
+    'angular2/bootstrap',
+    'rxjs'
+  ];
+  if (@@USE_BUNDLES) {
+    scriptUrls = [
+      '/bundle/angular2-polyfills.js',
+      '/bundle/angular2.dev.js',
+      '/bundle/http.js',
+      '/bundle/router.dev.js',
+      '/rxjs/bundles/Rx.js'
+    ];
+  } else {
+    console.warn("Not using the Angular 2 bundle. "+
+        "Don't use this configuration for e2e/performance tests!")
+    loadRuntimePackages.push('angular2');
+    scriptUrls = [
+      'Reflect.js',
+      'zone-microtask.js',
+      'long-stack-trace-zone.js'
+    ];
+  }
+  var systemJsPackages = {};
+  loadRuntimePackages.forEach(function(pck) {
+    systemJsPackages[pck] = {defaultExtension: 'js'};
+  });
   System.config({
     baseURL: '/',
-    packages: {
-      'angular2_material': {defaultExtension: 'js'},
-      'benchmarks': {defaultExtension: 'js'},
-      'playground': {defaultExtension: 'js'},
-      // TODO(rado): These helpers don't end up in the bundle, thus they should
-      // not even be in src/*. Move them!
-      'angular2/src/testing/benchmark_util': {defaultExtension: 'js'},
-      'angular2/src/facade/browser': {defaultExtension: 'js'},
-      'angular2/bootstrap': {defaultExtension: 'js'},
-      'rxjs': {defaultExtension: 'js'},
-    }
+    packages: systemJsPackages
   });
+  for (var i=0; i<scriptUrls.length; i++) {
+    document.write('<script src="'+scriptUrls[i]+'"></'+'script>');
+  }
 </script>
-<script src="/bundle/angular2-polyfills.js"></script>
-<script src="/bundle/angular2.dev.js"></script>
-<script src="/rxjs/bundles/Rx.js"></script>
 <script>
   var filename = '@@PATH/@@FILENAME';
   System.import(filename).then(function(m) { m.main(); }, console.error.bind(console));
diff --git a/tools/broccoli/trees/browser_tree.ts b/tools/broccoli/trees/browser_tree.ts
index 3a2f030..6759a2b 100644
--- a/tools/broccoli/trees/browser_tree.ts
+++ b/tools/broccoli/trees/browser_tree.ts
@@ -77,6 +77,7 @@ module.exports = function makeBrowserTree(options, destinationPath) {
   const noTypeChecks = options.noTypeChecks;
   const generateEs6 = options.generateEs6;
   const sourceMaps = options.sourceMaps;
+  const useBundles = options.useBundles;
 
   if (modules.angular2) {
     var angular2Tree = new Funnel('modules/angular2', {
@@ -149,6 +150,11 @@ module.exports = function makeBrowserTree(options, destinationPath) {
     }
   };
 
+  var useBundlesPatternReplacement = {
+    match: '@@USE_BUNDLES',
+    replacement: function(replacement, relativePath) { return useBundles; }
+  };
+
   // Check that imports do not break barrel boundaries
   modulesTree = checkImports(modulesTree);
 
@@ -218,7 +224,8 @@ module.exports = function makeBrowserTree(options, destinationPath) {
       patterns: [
         {match: /\$SCRIPTS\$/, replacement: htmlReplace('SCRIPTS')},
         scriptPathPatternReplacement,
-        scriptFilePatternReplacement
+        scriptFilePatternReplacement,
+        useBundlesPatternReplacement
       ]
     });
   }
@@ -229,7 +236,8 @@ module.exports = function makeBrowserTree(options, destinationPath) {
       patterns: [
         {match: /\$SCRIPTS\$/, replacement: htmlReplace('SCRIPTS_benchmarks')},
         scriptPathPatternReplacement,
-        scriptFilePatternReplacement
+        scriptFilePatternReplacement,
+        useBundlesPatternReplacement
       ]
     });
   }
@@ -240,7 +248,8 @@ module.exports = function makeBrowserTree(options, destinationPath) {
       patterns: [
         {match: /\$SCRIPTS\$/, replacement: htmlReplace('SCRIPTS_benchmarks_external')},
         scriptPathPatternReplacement,
-        scriptFilePatternReplacement
+        scriptFilePatternReplacement,
+        useBundlesPatternReplacement
       ]
     });
   }

From 7ae23adaff2990cf6022af9792c449730d451d1d Mon Sep 17 00:00:00 2001
From: Tobias Bosch <tbosch1009@gmail.com>
Date: Wed, 2 Dec 2015 10:35:51 -0800
Subject: [PATCH 08/12] feat(core): speed up view creation via code gen for
 view factories.

BREAKING CHANGE:
- Platform pipes can only contain types and arrays of types,
  but no bindings any more.
- When using transformers, platform pipes need to be specified explicitly
  in the pubspec.yaml via the new config option
  `platform_pipes`.
- `Compiler.compileInHost` now returns a `HostViewFactoryRef`
- Component view is not yet created when component constructor is called.
  -> use `onInit` lifecycle callback to access the view of a component
- `ViewRef#setLocal` has been moved to new type `EmbeddedViewRef`
- `internalView` is gone, use `EmbeddedViewRef.rootNodes` to access
  the root nodes of an embedded view
- `renderer.setElementProperty`, `..setElementStyle`, `..setElementAttribute` now
  take a native element instead of an ElementRef
- `Renderer` interface now operates on plain native nodes,
  instead of `RenderElementRef`s or `RenderViewRef`s

Closes #5993
---
 modules/angular2/src/common/directives/ng_class.ts |    4 +-
 modules/angular2/src/common/directives/ng_for.ts   |    7 +-
 modules/angular2/src/common/directives/ng_style.ts |    2 +-
 .../forms/directives/checkbox_value_accessor.ts    |    2 +-
 .../forms/directives/default_value_accessor.ts     |    2 +-
 .../forms/directives/number_value_accessor.ts      |    2 +-
 .../directives/select_control_value_accessor.ts    |    2 +-
 .../angular2/src/common/forms/directives/shared.ts |    1 -
 .../src/compiler/change_definition_factory.ts      |   22 +-
 .../src/compiler/change_detector_compiler.ts       |   21 +-
 modules/angular2/src/compiler/command_compiler.ts  |  375 -------
 modules/angular2/src/compiler/compiler.ts          |    6 +-
 .../angular2/src/compiler/directive_metadata.ts    |   49 +-
 .../angular2/src/compiler/proto_view_compiler.ts   |  397 +++++++
 modules/angular2/src/compiler/runtime_compiler.ts  |   18 +-
 modules/angular2/src/compiler/runtime_metadata.ts  |   63 +-
 modules/angular2/src/compiler/source_module.ts     |    4 +
 modules/angular2/src/compiler/style_compiler.ts    |    5 +-
 modules/angular2/src/compiler/template_compiler.ts |  459 ++++++---
 modules/angular2/src/compiler/template_parser.ts   |   58 +-
 modules/angular2/src/compiler/util.ts              |   96 +-
 modules/angular2/src/compiler/view_compiler.ts     |  600 +++++++++++
 .../src/core/application_common_providers.ts       |    9 +-
 modules/angular2/src/core/application_ref.ts       |   13 +-
 .../change_detection/abstract_change_detector.ts   |   58 +-
 .../change_detection_jit_generator.ts              |   19 +-
 .../core/change_detection/change_detector_ref.ts   |    2 +-
 .../core/change_detection/codegen_logic_util.ts    |   38 +-
 .../src/core/change_detection/directive_record.ts  |   12 +-
 .../change_detection/dynamic_change_detector.ts    |   51 +-
 .../src/core/change_detection/exceptions.ts        |   17 +
 .../src/core/change_detection/interfaces.ts        |   15 +-
 .../jit_proto_change_detector.dart                 |    4 +-
 .../change_detection/jit_proto_change_detector.ts  |    2 +-
 .../src/core/change_detection/parser/locals.ts     |    2 +-
 .../pregen_proto_change_detector.dart              |   34 -
 .../pregen_proto_change_detector.ts                |   15 +-
 .../core/change_detection/proto_change_detector.ts |    9 +-
 modules/angular2/src/core/debug/debug_element.ts   |   64 +-
 modules/angular2/src/core/di/injector.ts           |   41 +-
 modules/angular2/src/core/di/provider.ts           |   96 +-
 modules/angular2/src/core/linker.ts                |    2 +-
 modules/angular2/src/core/linker/compiler.ts       |   36 +-
 .../angular2/src/core/linker/directive_resolver.ts |    2 +
 .../src/core/linker/dynamic_component_loader.ts    |   44 +-
 modules/angular2/src/core/linker/element.ts        |  867 ++++++++++++++++
 modules/angular2/src/core/linker/element_binder.ts |   16 -
 .../angular2/src/core/linker/element_injector.ts   | 1086 --------------------
 modules/angular2/src/core/linker/element_ref.ts    |   44 +-
 modules/angular2/src/core/linker/event_config.ts   |   22 -
 modules/angular2/src/core/linker/pipe_resolver.ts  |    2 +
 .../angular2/src/core/linker/proto_view_factory.ts |  341 ------
 .../src/core/linker/resolved_metadata_cache.ts     |   35 +
 .../angular2/src/core/linker/template_commands.ts  |  141 ---
 modules/angular2/src/core/linker/template_ref.ts   |   29 +-
 modules/angular2/src/core/linker/view.ts           |  433 ++++----
 .../angular2/src/core/linker/view_container_ref.ts |   75 +-
 modules/angular2/src/core/linker/view_manager.ts   |  374 +++----
 .../angular2/src/core/linker/view_manager_utils.ts |  266 -----
 modules/angular2/src/core/linker/view_pool.ts      |   42 -
 modules/angular2/src/core/linker/view_ref.ts       |  126 +--
 modules/angular2/src/core/linker/view_type.ts      |   11 +
 modules/angular2/src/core/pipes/pipes.ts           |    1 -
 modules/angular2/src/core/render.ts                |   19 +-
 modules/angular2/src/core/render/api.ts            |  383 +------
 modules/angular2/src/core/render/view.ts           |   65 --
 modules/angular2/src/core/render/view_factory.ts   |  321 ------
 modules/angular2/src/core/util/decorators.ts       |    6 +
 modules/angular2/src/facade/async.dart             |    4 +-
 modules/angular2/src/facade/lang.dart              |    4 +
 modules/angular2/src/facade/lang.ts                |   15 +
 modules/angular2/src/platform/browser_common.ts    |    8 +-
 .../dom/debug/debug_element_view_listener.ts       |   13 +-
 modules/angular2/src/platform/dom/dom_renderer.ts  |  459 ++++-----
 modules/angular2/src/platform/worker_app_common.ts |   20 +-
 .../angular2/src/platform/worker_render_common.ts  |   16 +-
 .../angular2/src/testing/test_component_builder.ts |    8 +-
 modules/angular2/src/testing/test_injector.ts      |   19 +-
 modules/angular2/src/upgrade/constants.ts          |    2 +-
 .../angular2/src/upgrade/downgrade_ng2_adapter.ts  |   20 +-
 modules/angular2/src/upgrade/upgrade_adapter.ts    |   40 +-
 modules/angular2/src/web_workers/shared/api.ts     |   71 --
 .../shared/render_proto_view_ref_store.ts          |   48 -
 .../src/web_workers/shared/render_store.ts         |   45 +
 .../shared/render_view_with_fragments_store.ts     |  162 ---
 .../angular2/src/web_workers/shared/serializer.ts  |  172 +---
 .../src/web_workers/ui/event_dispatcher.ts         |   33 +-
 modules/angular2/src/web_workers/ui/renderer.ts    |  235 +++--
 .../src/web_workers/worker/event_dispatcher.ts     |   47 -
 .../angular2/src/web_workers/worker/renderer.ts    |  403 ++++----
 .../test/common/directives/ng_class_spec.ts        |    3 -
 modules/angular2/test/common/spies.ts              |    7 +-
 .../compiler/change_definition_factory_spec.ts     |   18 +-
 .../test/compiler/change_detector_compiler_spec.ts |   41 +-
 .../test/compiler/change_detector_mocks.ts         |   10 +-
 .../test/compiler/command_compiler_spec.ts         |  597 -----------
 .../test/compiler/runtime_compiler_spec.ts         |   81 +-
 .../test/compiler/runtime_metadata_spec.ts         |   12 +-
 modules/angular2/test/compiler/spies.dart          |    8 +-
 modules/angular2/test/compiler/spies.ts            |    5 +
 .../test/compiler/template_compiler_spec.ts        |  323 +++---
 .../angular2/test/compiler/template_parser_spec.ts |   31 +-
 .../change_detection/change_detector_config.ts     |   13 +-
 .../change_detection/change_detector_ref_spec.ts   |    2 +-
 .../core/change_detection/change_detector_spec.ts  |  216 ++--
 .../core/change_detection/parser/locals_spec.ts    |    2 +-
 modules/angular2/test/core/di/injector_spec.ts     |   69 +-
 modules/angular2/test/core/linker/compiler_spec.ts |   46 +-
 .../core/linker/dynamic_component_loader_spec.ts   |   93 +-
 .../test/core/linker/element_injector_spec.ts      | 1038 -------------------
 modules/angular2/test/core/linker/element_spec.ts  |  843 +++++++++++++++
 .../angular2/test/core/linker/event_config_spec.ts |   31 -
 .../angular2/test/core/linker/integration_spec.ts  |   48 +-
 .../core/linker/projection_integration_spec.ts     |   49 +-
 .../test/core/linker/proto_view_factory_spec.ts    |   19 -
 .../test/core/linker/query_integration_spec.ts     |   13 +-
 .../test/core/linker/view_container_ref_spec.ts    |   60 --
 .../angular2/test/core/linker/view_manager_spec.ts |  520 ----------
 .../test/core/linker/view_manager_utils_spec.ts    |  293 ------
 .../angular2/test/core/linker/view_pool_spec.ts    |   74 --
 .../angular2/test/core/render/view_factory_spec.ts |  740 -------------
 modules/angular2/test/core/render/view_spec.ts     |   38 -
 modules/angular2/test/core/spies.dart              |   34 +-
 modules/angular2/test/core/spies.ts                |   87 +-
 .../debug/debug_element_view_listener_spec.ts      |    3 -
 modules/angular2/test/public_api_spec.ts           |  114 +-
 .../test/router/integration/bootstrap_spec.ts      |    1 -
 .../shared/render_proto_view_ref_store_spec.ts     |   56 -
 .../test/web_workers/shared/render_store_spec.ts   |   37 +
 .../render_view_with_fragments_store_spec.ts       |  144 ---
 .../shared/service_message_broker_spec.ts          |   11 +-
 .../web_workers/worker/event_dispatcher_spec.ts    |   71 --
 .../worker/renderer_integration_spec.ts            |  174 ++--
 .../benchmarks/e2e_test/element_injector_perf.dart |    3 -
 .../benchmarks/e2e_test/element_injector_perf.ts   |   31 -
 modules/benchmarks/e2e_test/largetable_perf.ts     |   15 -
 modules/benchmarks/e2e_test/static_tree_perf.ts    |   33 +-
 modules/benchmarks/e2e_test/tree_perf.ts           |   15 +-
 .../change_detection/change_detection_benchmark.ts |   22 +-
 .../element_injector_benchmark.html                |   21 -
 .../element_injector/element_injector_benchmark.ts |   54 -
 .../src/largetable/largetable_benchmark.ts         |    5 +-
 .../benchmarks/src/naive_infinite_scroll/index.ts  |    3 +-
 .../benchmarks/src/static_tree/tree_benchmark.ts   |    4 +-
 modules/benchmarks/src/tree/tree_benchmark.ts      |    4 +-
 modules/playground/src/hello_world/index.ts        |    4 +-
 .../playground/src/observable_models/index.dart    |    4 +-
 .../src/web_workers/kitchen_sink/index_common.ts   |    4 +-
 .../angular2_testing/lib/angular2_testing.dart     |    3 +-
 .../src/transform/common/annotation_matcher.dart   |   19 +
 .../common/code/reflection_info_code.dart          |   67 +-
 .../common/directive_metadata_reader.dart          |  552 ----------
 .../src/transform/common/interface_matcher.dart    |   12 +-
 .../common/model/reflection_info_model.pb.dart     |   55 +-
 .../common/model/reflection_info_model.proto       |   13 +-
 .../lib/src/transform/common/ng_compiler.dart      |   17 +-
 .../lib/src/transform/common/ng_meta.dart          |   13 +-
 .../lib/src/transform/common/options.dart          |   12 +-
 .../lib/src/transform/common/options_reader.dart   |    2 +
 .../src/transform/common/type_metadata_reader.dart |  680 ++++++++++++
 .../transform/directive_processor/rewriter.dart    |   17 +-
 .../template_compiler/change_detector_codegen.dart |   26 +-
 .../template_compiler/compile_data_creator.dart    |  136 +--
 .../src/transform/template_compiler/generator.dart |   15 +-
 .../template_compiler/reflection/model.dart        |   13 +-
 .../template_compiler/reflection/processor.dart    |   22 +-
 .../transform/template_compiler/transformer.dart   |    3 +-
 .../compile_directive_metadata/ng_for.ng_meta.dart |    1 +
 .../test/transform/common/ng_meta_helper.dart      |   18 +
 .../complex_deferred_example/hello.ng_meta.json    |    3 +-
 .../simple_deferred_example/hello.ng_meta.json     |    3 +-
 .../transform/directive_processor/all_tests.dart   |   79 +-
 .../bad_directives_files/pipes.dart                |    9 +
 .../directives_files/components.dart               |   13 +-
 .../directive_processor/directives_files/dep1.dart |    6 +-
 .../directive_processor/directives_files/dep2.dart |    6 +-
 .../directive_processor/pipe_files/pipes.dart      |    9 +
 .../deferred_files/expected/bar.ng_deps.dart       |    2 +-
 .../expected/bar.ng_deps.dart                      |    2 +-
 .../directive_dep_files/expected/bar.ng_deps.dart  |    2 +-
 .../empty_ng_deps_files/expected/foo.ng_deps.dart  |    2 +-
 .../event_getter_files/expected/bar.ng_deps.dart   |    2 +-
 .../list_of_types_files/expected/bar.ng_deps.dart  |    2 +-
 .../expected/bar.ng_deps.dart                      |    2 +-
 .../expected/bar.ng_deps.dart                      |    2 +-
 .../expected/bar.ng_deps.dart                      |    2 +-
 .../expected/bar.ng_deps.dart                      |    2 +-
 .../expected/bar.ng_meta.json                      |   28 -
 .../synthetic_ctor_files/expected/bar.ng_deps.dart |    2 +-
 .../expected/bar.ng_deps.dart                      |    2 +-
 .../two_deps_files/expected/bar.ng_deps.dart       |    2 +-
 .../transform/template_compiler/all_tests.dart     |   76 +-
 192 files changed, 6912 insertions(+), 10668 deletions(-)
 delete mode 100644 modules/angular2/src/compiler/command_compiler.ts
 create mode 100644 modules/angular2/src/compiler/proto_view_compiler.ts
 create mode 100644 modules/angular2/src/compiler/view_compiler.ts
 create mode 100644 modules/angular2/src/core/linker/element.ts
 delete mode 100644 modules/angular2/src/core/linker/element_binder.ts
 delete mode 100644 modules/angular2/src/core/linker/element_injector.ts
 delete mode 100644 modules/angular2/src/core/linker/event_config.ts
 delete mode 100644 modules/angular2/src/core/linker/proto_view_factory.ts
 create mode 100644 modules/angular2/src/core/linker/resolved_metadata_cache.ts
 delete mode 100644 modules/angular2/src/core/linker/template_commands.ts
 delete mode 100644 modules/angular2/src/core/linker/view_manager_utils.ts
 delete mode 100644 modules/angular2/src/core/linker/view_pool.ts
 create mode 100644 modules/angular2/src/core/linker/view_type.ts
 delete mode 100644 modules/angular2/src/core/render/view.ts
 delete mode 100644 modules/angular2/src/core/render/view_factory.ts
 delete mode 100644 modules/angular2/src/web_workers/shared/render_proto_view_ref_store.ts
 create mode 100644 modules/angular2/src/web_workers/shared/render_store.ts
 delete mode 100644 modules/angular2/src/web_workers/shared/render_view_with_fragments_store.ts
 delete mode 100644 modules/angular2/src/web_workers/worker/event_dispatcher.ts
 delete mode 100644 modules/angular2/test/compiler/command_compiler_spec.ts
 delete mode 100644 modules/angular2/test/core/linker/element_injector_spec.ts
 create mode 100644 modules/angular2/test/core/linker/element_spec.ts
 delete mode 100644 modules/angular2/test/core/linker/event_config_spec.ts
 delete mode 100644 modules/angular2/test/core/linker/proto_view_factory_spec.ts
 delete mode 100644 modules/angular2/test/core/linker/view_container_ref_spec.ts
 delete mode 100644 modules/angular2/test/core/linker/view_manager_spec.ts
 delete mode 100644 modules/angular2/test/core/linker/view_manager_utils_spec.ts
 delete mode 100644 modules/angular2/test/core/linker/view_pool_spec.ts
 delete mode 100644 modules/angular2/test/core/render/view_factory_spec.ts
 delete mode 100644 modules/angular2/test/core/render/view_spec.ts
 delete mode 100644 modules/angular2/test/web_workers/shared/render_proto_view_ref_store_spec.ts
 create mode 100644 modules/angular2/test/web_workers/shared/render_store_spec.ts
 delete mode 100644 modules/angular2/test/web_workers/shared/render_view_with_fragments_store_spec.ts
 delete mode 100644 modules/angular2/test/web_workers/worker/event_dispatcher_spec.ts
 delete mode 100644 modules/benchmarks/e2e_test/element_injector_perf.dart
 delete mode 100644 modules/benchmarks/e2e_test/element_injector_perf.ts
 delete mode 100644 modules/benchmarks/src/element_injector/element_injector_benchmark.html
 delete mode 100644 modules/benchmarks/src/element_injector/element_injector_benchmark.ts
 delete mode 100644 modules_dart/transform/lib/src/transform/common/directive_metadata_reader.dart
 create mode 100644 modules_dart/transform/lib/src/transform/common/type_metadata_reader.dart
 create mode 100644 modules_dart/transform/test/transform/directive_processor/bad_directives_files/pipes.dart
 create mode 100644 modules_dart/transform/test/transform/directive_processor/pipe_files/pipes.dart
 delete mode 100644 modules_dart/transform/test/transform/integration/simple_annotation_files/expected/bar.ng_meta.json

diff --git a/modules/angular2/src/common/directives/ng_class.ts b/modules/angular2/src/common/directives/ng_class.ts
index 2f77b07..cae1ca0 100644
--- a/modules/angular2/src/common/directives/ng_class.ts
+++ b/modules/angular2/src/common/directives/ng_class.ts
@@ -169,10 +169,10 @@ export class NgClass implements DoCheck, OnDestroy {
       if (className.indexOf(' ') > -1) {
         var classes = className.split(/\s+/g);
         for (var i = 0, len = classes.length; i < len; i++) {
-          this._renderer.setElementClass(this._ngEl, classes[i], enabled);
+          this._renderer.setElementClass(this._ngEl.nativeElement, classes[i], enabled);
         }
       } else {
-        this._renderer.setElementClass(this._ngEl, className, enabled);
+        this._renderer.setElementClass(this._ngEl.nativeElement, className, enabled);
       }
     }
   }
diff --git a/modules/angular2/src/common/directives/ng_for.ts b/modules/angular2/src/common/directives/ng_for.ts
index 7529f14..ec768c4 100644
--- a/modules/angular2/src/common/directives/ng_for.ts
+++ b/modules/angular2/src/common/directives/ng_for.ts
@@ -6,7 +6,7 @@ import {
   IterableDiffers,
   ViewContainerRef,
   TemplateRef,
-  ViewRef
+  EmbeddedViewRef
 } from 'angular2/core';
 import {isPresent, isBlank} from 'angular2/src/facade/lang';
 
@@ -110,7 +110,8 @@ export class NgFor implements DoCheck {
     }
 
     for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
-      this._viewContainer.get(i).setLocal('last', i === ilen - 1);
+      var viewRef = <EmbeddedViewRef>this._viewContainer.get(i);
+      viewRef.setLocal('last', i === ilen - 1);
     }
   }
 
@@ -153,7 +154,7 @@ export class NgFor implements DoCheck {
 }
 
 class RecordViewTuple {
-  view: ViewRef;
+  view: EmbeddedViewRef;
   record: any;
   constructor(record, view) {
     this.record = record;
diff --git a/modules/angular2/src/common/directives/ng_style.ts b/modules/angular2/src/common/directives/ng_style.ts
index 90b5d74..99d658a 100644
--- a/modules/angular2/src/common/directives/ng_style.ts
+++ b/modules/angular2/src/common/directives/ng_style.ts
@@ -92,6 +92,6 @@ export class NgStyle implements DoCheck {
   }
 
   private _setStyle(name: string, val: string): void {
-    this._renderer.setElementStyle(this._ngEl, name, val);
+    this._renderer.setElementStyle(this._ngEl.nativeElement, name, val);
   }
 }
diff --git a/modules/angular2/src/common/forms/directives/checkbox_value_accessor.ts b/modules/angular2/src/common/forms/directives/checkbox_value_accessor.ts
index 3e52b07..0943268 100644
--- a/modules/angular2/src/common/forms/directives/checkbox_value_accessor.ts
+++ b/modules/angular2/src/common/forms/directives/checkbox_value_accessor.ts
@@ -27,7 +27,7 @@ export class CheckboxControlValueAccessor implements ControlValueAccessor {
   constructor(private _renderer: Renderer, private _elementRef: ElementRef) {}
 
   writeValue(value: any): void {
-    this._renderer.setElementProperty(this._elementRef, 'checked', value);
+    this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
   }
   registerOnChange(fn: (_: any) => {}): void { this.onChange = fn; }
   registerOnTouched(fn: () => {}): void { this.onTouched = fn; }
diff --git a/modules/angular2/src/common/forms/directives/default_value_accessor.ts b/modules/angular2/src/common/forms/directives/default_value_accessor.ts
index 67c88b3..1cc8899 100644
--- a/modules/angular2/src/common/forms/directives/default_value_accessor.ts
+++ b/modules/angular2/src/common/forms/directives/default_value_accessor.ts
@@ -31,7 +31,7 @@ export class DefaultValueAccessor implements ControlValueAccessor {
 
   writeValue(value: any): void {
     var normalizedValue = isBlank(value) ? '' : value;
-    this._renderer.setElementProperty(this._elementRef, 'value', normalizedValue);
+    this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
   }
 
   registerOnChange(fn: (_: any) => void): void { this.onChange = fn; }
diff --git a/modules/angular2/src/common/forms/directives/number_value_accessor.ts b/modules/angular2/src/common/forms/directives/number_value_accessor.ts
index 41b04f0..1122c60 100644
--- a/modules/angular2/src/common/forms/directives/number_value_accessor.ts
+++ b/modules/angular2/src/common/forms/directives/number_value_accessor.ts
@@ -31,7 +31,7 @@ export class NumberValueAccessor implements ControlValueAccessor {
   constructor(private _renderer: Renderer, private _elementRef: ElementRef) {}
 
   writeValue(value: number): void {
-    this._renderer.setElementProperty(this._elementRef, 'value', value);
+    this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', value);
   }
 
   registerOnChange(fn: (_: number) => void): void {
diff --git a/modules/angular2/src/common/forms/directives/select_control_value_accessor.ts b/modules/angular2/src/common/forms/directives/select_control_value_accessor.ts
index 2fe527a..1cb88f6 100644
--- a/modules/angular2/src/common/forms/directives/select_control_value_accessor.ts
+++ b/modules/angular2/src/common/forms/directives/select_control_value_accessor.ts
@@ -51,7 +51,7 @@ export class SelectControlValueAccessor implements ControlValueAccessor {
 
   writeValue(value: any): void {
     this.value = value;
-    this._renderer.setElementProperty(this._elementRef, 'value', value);
+    this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', value);
   }
 
   registerOnChange(fn: () => any): void { this.onChange = fn; }
diff --git a/modules/angular2/src/common/forms/directives/shared.ts b/modules/angular2/src/common/forms/directives/shared.ts
index a0a5bb5..e9a232b 100644
--- a/modules/angular2/src/common/forms/directives/shared.ts
+++ b/modules/angular2/src/common/forms/directives/shared.ts
@@ -80,7 +80,6 @@ export function selectValueAccessor(dir: NgControl,
   var defaultAccessor;
   var builtinAccessor;
   var customAccessor;
-
   valueAccessors.forEach(v => {
     if (v instanceof DefaultValueAccessor) {
       defaultAccessor = v;
diff --git a/modules/angular2/src/compiler/change_definition_factory.ts b/modules/angular2/src/compiler/change_definition_factory.ts
index ce7c940..de12f8c 100644
--- a/modules/angular2/src/compiler/change_definition_factory.ts
+++ b/modules/angular2/src/compiler/change_definition_factory.ts
@@ -1,4 +1,4 @@
-import {ListWrapper} from 'angular2/src/facade/collection';
+import {ListWrapper, StringMapWrapper} from 'angular2/src/facade/collection';
 import {isPresent, isBlank} from 'angular2/src/facade/lang';
 import {reflector} from 'angular2/src/core/reflection/reflection';
 
@@ -43,7 +43,7 @@ export function createChangeDetectorDefinitions(
 
 class ProtoViewVisitor implements TemplateAstVisitor {
   viewIndex: number;
-  boundTextCount: number = 0;
+  nodeCount: number = 0;
   boundElementCount: number = 0;
   variableNames: string[] = [];
   bindingRecords: BindingRecord[] = [];
@@ -57,6 +57,7 @@ class ProtoViewVisitor implements TemplateAstVisitor {
   }
 
   visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {
+    this.nodeCount++;
     this.boundElementCount++;
     templateVisitAll(this, ast.outputs);
     for (var i = 0; i < ast.directives.length; i++) {
@@ -73,6 +74,7 @@ class ProtoViewVisitor implements TemplateAstVisitor {
   }
 
   visitElement(ast: ElementAst, context: any): any {
+    this.nodeCount++;
     if (ast.isBound()) {
       this.boundElementCount++;
     }
@@ -132,14 +134,20 @@ class ProtoViewVisitor implements TemplateAstVisitor {
   }
   visitAttr(ast: AttrAst, context: any): any { return null; }
   visitBoundText(ast: BoundTextAst, context: any): any {
-    var boundTextIndex = this.boundTextCount++;
-    this.bindingRecords.push(BindingRecord.createForTextNode(ast.value, boundTextIndex));
+    var nodeIndex = this.nodeCount++;
+    this.bindingRecords.push(BindingRecord.createForTextNode(ast.value, nodeIndex));
+    return null;
+  }
+  visitText(ast: TextAst, context: any): any {
+    this.nodeCount++;
     return null;
   }
-  visitText(ast: TextAst, context: any): any { return null; }
   visitDirective(ast: DirectiveAst, directiveIndexAsNumber: number): any {
     var directiveIndex = new DirectiveIndex(this.boundElementCount - 1, directiveIndexAsNumber);
     var directiveMetadata = ast.directive;
+    var outputsArray = [];
+    StringMapWrapper.forEach(ast.directive.outputs, (eventName, dirProperty) => outputsArray.push(
+                                                        [dirProperty, eventName]));
     var directiveRecord = new DirectiveRecord({
       directiveIndex: directiveIndex,
       callAfterContentInit:
@@ -153,7 +161,9 @@ class ProtoViewVisitor implements TemplateAstVisitor {
       callOnChanges: directiveMetadata.lifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1,
       callDoCheck: directiveMetadata.lifecycleHooks.indexOf(LifecycleHooks.DoCheck) !== -1,
       callOnInit: directiveMetadata.lifecycleHooks.indexOf(LifecycleHooks.OnInit) !== -1,
-      changeDetection: directiveMetadata.changeDetection
+      callOnDestroy: directiveMetadata.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1,
+      changeDetection: directiveMetadata.changeDetection,
+      outputs: outputsArray
     });
     this.directiveRecords.push(directiveRecord);
 
diff --git a/modules/angular2/src/compiler/change_detector_compiler.ts b/modules/angular2/src/compiler/change_detector_compiler.ts
index 1f42bd8..db3b727 100644
--- a/modules/angular2/src/compiler/change_detector_compiler.ts
+++ b/modules/angular2/src/compiler/change_detector_compiler.ts
@@ -3,6 +3,9 @@ import {SourceExpressions, moduleRef} from './source_module';
 import {
   ChangeDetectorJITGenerator
 } from 'angular2/src/core/change_detection/change_detection_jit_generator';
+import {AbstractChangeDetector} from 'angular2/src/core/change_detection/abstract_change_detector';
+import {ChangeDetectionUtil} from 'angular2/src/core/change_detection/change_detection_util';
+import {ChangeDetectorState} from 'angular2/src/core/change_detection/constants';
 
 import {createChangeDetectorDefinitions} from './change_definition_factory';
 import {IS_DART, isJsObject, CONST_EXPR} from 'angular2/src/facade/lang';
@@ -23,6 +26,12 @@ const ABSTRACT_CHANGE_DETECTOR = "AbstractChangeDetector";
 const UTIL = "ChangeDetectionUtil";
 const CHANGE_DETECTOR_STATE = "ChangeDetectorState";
 
+export const CHANGE_DETECTION_JIT_IMPORTS = CONST_EXPR({
+  'AbstractChangeDetector': AbstractChangeDetector,
+  'ChangeDetectionUtil': ChangeDetectionUtil,
+  'ChangeDetectorState': ChangeDetectorState
+});
+
 var ABSTRACT_CHANGE_DETECTOR_MODULE = moduleRef(
     `package:angular2/src/core/change_detection/abstract_change_detector${MODULE_SUFFIX}`);
 var UTIL_MODULE =
@@ -45,14 +54,8 @@ export class ChangeDetectionCompiler {
   }
 
   private _createChangeDetectorFactory(definition: ChangeDetectorDefinition): Function {
-    if (IS_DART || !this._genConfig.useJit) {
-      var proto = new DynamicProtoChangeDetector(definition);
-      return (dispatcher) => proto.instantiate(dispatcher);
-    } else {
-      return new ChangeDetectorJITGenerator(definition, UTIL, ABSTRACT_CHANGE_DETECTOR,
-                                            CHANGE_DETECTOR_STATE)
-          .generate();
-    }
+    var proto = new DynamicProtoChangeDetector(definition);
+    return () => proto.instantiate();
   }
 
   compileComponentCodeGen(componentType: CompileTypeMetadata, strategy: ChangeDetectionStrategy,
@@ -81,7 +84,7 @@ export class ChangeDetectionCompiler {
             definition, `${UTIL_MODULE}${UTIL}`,
             `${ABSTRACT_CHANGE_DETECTOR_MODULE}${ABSTRACT_CHANGE_DETECTOR}`,
             `${CONSTANTS_MODULE}${CHANGE_DETECTOR_STATE}`);
-        factories.push(`function(dispatcher) { return new ${codegen.typeName}(dispatcher); }`);
+        factories.push(`function() { return new ${codegen.typeName}(); }`);
         sourcePart = codegen.generateSource();
       }
       index++;
diff --git a/modules/angular2/src/compiler/command_compiler.ts b/modules/angular2/src/compiler/command_compiler.ts
deleted file mode 100644
index 5819b4d..0000000
--- a/modules/angular2/src/compiler/command_compiler.ts
+++ /dev/null
@@ -1,375 +0,0 @@
-import {isPresent, isBlank, Type, isString, StringWrapper, IS_DART} from 'angular2/src/facade/lang';
-import {SetWrapper, StringMapWrapper, ListWrapper} from 'angular2/src/facade/collection';
-import {
-  TemplateCmd,
-  TextCmd,
-  NgContentCmd,
-  BeginElementCmd,
-  EndElementCmd,
-  BeginComponentCmd,
-  EndComponentCmd,
-  EmbeddedTemplateCmd,
-  CompiledComponentTemplate
-} from 'angular2/src/core/linker/template_commands';
-import {
-  TemplateAst,
-  TemplateAstVisitor,
-  NgContentAst,
-  EmbeddedTemplateAst,
-  ElementAst,
-  VariableAst,
-  BoundEventAst,
-  BoundElementPropertyAst,
-  AttrAst,
-  BoundTextAst,
-  TextAst,
-  DirectiveAst,
-  BoundDirectivePropertyAst,
-  templateVisitAll
-} from './template_ast';
-import {CompileTypeMetadata, CompileDirectiveMetadata} from './directive_metadata';
-import {SourceExpressions, SourceExpression, moduleRef} from './source_module';
-
-import {ViewEncapsulation} from 'angular2/src/core/metadata/view';
-import {
-  escapeSingleQuoteString,
-  codeGenConstConstructorCall,
-  codeGenValueFn,
-  MODULE_SUFFIX
-} from './util';
-import {Injectable} from 'angular2/src/core/di';
-
-export var TEMPLATE_COMMANDS_MODULE_REF =
-    moduleRef(`package:angular2/src/core/linker/template_commands${MODULE_SUFFIX}`);
-
-const IMPLICIT_TEMPLATE_VAR = '\$implicit';
-const CLASS_ATTR = 'class';
-const STYLE_ATTR = 'style';
-
-@Injectable()
-export class CommandCompiler {
-  compileComponentRuntime(component: CompileDirectiveMetadata, template: TemplateAst[],
-                          changeDetectorFactories: Function[],
-                          componentTemplateFactory: Function): TemplateCmd[] {
-    var visitor = new CommandBuilderVisitor(
-        new RuntimeCommandFactory(component, componentTemplateFactory, changeDetectorFactories), 0);
-    templateVisitAll(visitor, template);
-    return visitor.result;
-  }
-
-  compileComponentCodeGen(component: CompileDirectiveMetadata, template: TemplateAst[],
-                          changeDetectorFactoryExpressions: string[],
-                          componentTemplateFactory: Function): SourceExpression {
-    var visitor =
-        new CommandBuilderVisitor(new CodegenCommandFactory(component, componentTemplateFactory,
-                                                            changeDetectorFactoryExpressions),
-                                  0);
-    templateVisitAll(visitor, template);
-    return new SourceExpression([], codeGenArray(visitor.result));
-  }
-}
-
-interface CommandFactory<R> {
-  createText(value: string, isBound: boolean, ngContentIndex: number): R;
-  createNgContent(index: number, ngContentIndex: number): R;
-  createBeginElement(name: string, attrNameAndValues: string[], eventTargetAndNames: string[],
-                     variableNameAndValues: string[], directives: CompileDirectiveMetadata[],
-                     isBound: boolean, ngContentIndex: number): R;
-  createEndElement(): R;
-  createBeginComponent(name: string, attrNameAndValues: string[], eventTargetAndNames: string[],
-                       variableNameAndValues: string[], directives: CompileDirectiveMetadata[],
-                       encapsulation: ViewEncapsulation, ngContentIndex: number): R;
-  createEndComponent(): R;
-  createEmbeddedTemplate(embeddedTemplateIndex: number, attrNameAndValues: string[],
-                         variableNameAndValues: string[], directives: CompileDirectiveMetadata[],
-                         isMerged: boolean, ngContentIndex: number, children: R[]): R;
-}
-
-class RuntimeCommandFactory implements CommandFactory<TemplateCmd> {
-  constructor(private component: CompileDirectiveMetadata,
-              private componentTemplateFactory: Function,
-              private changeDetectorFactories: Function[]) {}
-  private _mapDirectives(directives: CompileDirectiveMetadata[]): Type[] {
-    return directives.map(directive => directive.type.runtime);
-  }
-
-  createText(value: string, isBound: boolean, ngContentIndex: number): TemplateCmd {
-    return new TextCmd(value, isBound, ngContentIndex);
-  }
-  createNgContent(index: number, ngContentIndex: number): TemplateCmd {
-    return new NgContentCmd(index, ngContentIndex);
-  }
-  createBeginElement(name: string, attrNameAndValues: string[], eventTargetAndNames: string[],
-                     variableNameAndValues: string[], directives: CompileDirectiveMetadata[],
-                     isBound: boolean, ngContentIndex: number): TemplateCmd {
-    return new BeginElementCmd(name, attrNameAndValues, eventTargetAndNames, variableNameAndValues,
-                               this._mapDirectives(directives), isBound, ngContentIndex);
-  }
-  createEndElement(): TemplateCmd { return new EndElementCmd(); }
-  createBeginComponent(name: string, attrNameAndValues: string[], eventTargetAndNames: string[],
-                       variableNameAndValues: string[], directives: CompileDirectiveMetadata[],
-                       encapsulation: ViewEncapsulation, ngContentIndex: number): TemplateCmd {
-    var nestedTemplateAccessor = this.componentTemplateFactory(directives[0]);
-    return new BeginComponentCmd(name, attrNameAndValues, eventTargetAndNames,
-                                 variableNameAndValues, this._mapDirectives(directives),
-                                 encapsulation, ngContentIndex, nestedTemplateAccessor);
-  }
-  createEndComponent(): TemplateCmd { return new EndComponentCmd(); }
-  createEmbeddedTemplate(embeddedTemplateIndex: number, attrNameAndValues: string[],
-                         variableNameAndValues: string[], directives: CompileDirectiveMetadata[],
-                         isMerged: boolean, ngContentIndex: number,
-                         children: TemplateCmd[]): TemplateCmd {
-    return new EmbeddedTemplateCmd(attrNameAndValues, variableNameAndValues,
-                                   this._mapDirectives(directives), isMerged, ngContentIndex,
-                                   this.changeDetectorFactories[embeddedTemplateIndex], children);
-  }
-}
-
-class CodegenCommandFactory implements CommandFactory<Expression> {
-  constructor(private component: CompileDirectiveMetadata,
-              private componentTemplateFactory: Function,
-              private changeDetectorFactoryExpressions: string[]) {}
-
-  createText(value: string, isBound: boolean, ngContentIndex: number): Expression {
-    return new Expression(
-        `${codeGenConstConstructorCall(TEMPLATE_COMMANDS_MODULE_REF+'TextCmd')}(${escapeSingleQuoteString(value)}, ${isBound}, ${ngContentIndex})`);
-  }
-  createNgContent(index: number, ngContentIndex: number): Expression {
-    return new Expression(
-        `${codeGenConstConstructorCall(TEMPLATE_COMMANDS_MODULE_REF+'NgContentCmd')}(${index}, ${ngContentIndex})`);
-  }
-  createBeginElement(name: string, attrNameAndValues: string[], eventTargetAndNames: string[],
-                     variableNameAndValues: string[], directives: CompileDirectiveMetadata[],
-                     isBound: boolean, ngContentIndex: number): Expression {
-    var attrsExpression = codeGenArray(attrNameAndValues);
-    return new Expression(
-        `${codeGenConstConstructorCall(TEMPLATE_COMMANDS_MODULE_REF+'BeginElementCmd')}(${escapeSingleQuoteString(name)}, ${attrsExpression}, ` +
-        `${codeGenArray(eventTargetAndNames)}, ${codeGenArray(variableNameAndValues)}, ${codeGenDirectivesArray(directives)}, ${isBound}, ${ngContentIndex})`);
-  }
-  createEndElement(): Expression {
-    return new Expression(
-        `${codeGenConstConstructorCall(TEMPLATE_COMMANDS_MODULE_REF+'EndElementCmd')}()`);
-  }
-  createBeginComponent(name: string, attrNameAndValues: string[], eventTargetAndNames: string[],
-                       variableNameAndValues: string[], directives: CompileDirectiveMetadata[],
-                       encapsulation: ViewEncapsulation, ngContentIndex: number): Expression {
-    var attrsExpression = codeGenArray(attrNameAndValues);
-    return new Expression(
-        `${codeGenConstConstructorCall(TEMPLATE_COMMANDS_MODULE_REF+'BeginComponentCmd')}(${escapeSingleQuoteString(name)}, ${attrsExpression}, ` +
-        `${codeGenArray(eventTargetAndNames)}, ${codeGenArray(variableNameAndValues)}, ${codeGenDirectivesArray(directives)}, ${codeGenViewEncapsulation(encapsulation)}, ${ngContentIndex}, ${this.componentTemplateFactory(directives[0])})`);
-  }
-  createEndComponent(): Expression {
-    return new Expression(
-        `${codeGenConstConstructorCall(TEMPLATE_COMMANDS_MODULE_REF+'EndComponentCmd')}()`);
-  }
-  createEmbeddedTemplate(embeddedTemplateIndex: number, attrNameAndValues: string[],
-                         variableNameAndValues: string[], directives: CompileDirectiveMetadata[],
-                         isMerged: boolean, ngContentIndex: number,
-                         children: Expression[]): Expression {
-    return new Expression(
-        `${codeGenConstConstructorCall(TEMPLATE_COMMANDS_MODULE_REF+'EmbeddedTemplateCmd')}(${codeGenArray(attrNameAndValues)}, ${codeGenArray(variableNameAndValues)}, ` +
-        `${codeGenDirectivesArray(directives)}, ${isMerged}, ${ngContentIndex}, ${this.changeDetectorFactoryExpressions[embeddedTemplateIndex]}, ${codeGenArray(children)})`);
-  }
-}
-
-function visitAndReturnContext(visitor: TemplateAstVisitor, asts: TemplateAst[],
-                               context: any): any {
-  templateVisitAll(visitor, asts, context);
-  return context;
-}
-
-class CommandBuilderVisitor<R> implements TemplateAstVisitor {
-  result: R[] = [];
-  transitiveNgContentCount: number = 0;
-  constructor(public commandFactory: CommandFactory<R>, public embeddedTemplateIndex: number) {}
-
-  private _readAttrNameAndValues(directives: CompileDirectiveMetadata[],
-                                 attrAsts: TemplateAst[]): string[] {
-    var attrs = keyValueArrayToMap(visitAndReturnContext(this, attrAsts, []));
-    directives.forEach(directiveMeta => {
-      StringMapWrapper.forEach(directiveMeta.hostAttributes, (value, name) => {
-        var prevValue = attrs[name];
-        attrs[name] = isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
-      });
-    });
-    return mapToKeyValueArray(attrs);
-  }
-
-  visitNgContent(ast: NgContentAst, context: any): any {
-    this.transitiveNgContentCount++;
-    this.result.push(this.commandFactory.createNgContent(ast.index, ast.ngContentIndex));
-    return null;
-  }
-  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {
-    this.embeddedTemplateIndex++;
-    var childVisitor = new CommandBuilderVisitor(this.commandFactory, this.embeddedTemplateIndex);
-    templateVisitAll(childVisitor, ast.children);
-    var isMerged = childVisitor.transitiveNgContentCount > 0;
-    var variableNameAndValues = [];
-    ast.vars.forEach((varAst) => {
-      variableNameAndValues.push(varAst.name);
-      variableNameAndValues.push(varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR);
-    });
-    var directives = [];
-    ListWrapper.forEachWithIndex(ast.directives, (directiveAst: DirectiveAst, index: number) => {
-      directiveAst.visit(this, new DirectiveContext(index, [], [], directives));
-    });
-    this.result.push(this.commandFactory.createEmbeddedTemplate(
-        this.embeddedTemplateIndex, this._readAttrNameAndValues(directives, ast.attrs),
-        variableNameAndValues, directives, isMerged, ast.ngContentIndex, childVisitor.result));
-    this.transitiveNgContentCount += childVisitor.transitiveNgContentCount;
-    this.embeddedTemplateIndex = childVisitor.embeddedTemplateIndex;
-    return null;
-  }
-  visitElement(ast: ElementAst, context: any): any {
-    var component = ast.getComponent();
-    var eventTargetAndNames = visitAndReturnContext(this, ast.outputs, []);
-    var variableNameAndValues = [];
-    if (isBlank(component)) {
-      ast.exportAsVars.forEach((varAst) => {
-        variableNameAndValues.push(varAst.name);
-        variableNameAndValues.push(null);
-      });
-    }
-    var directives = [];
-    ListWrapper.forEachWithIndex(ast.directives, (directiveAst: DirectiveAst, index: number) => {
-      directiveAst.visit(this, new DirectiveContext(index, eventTargetAndNames,
-                                                    variableNameAndValues, directives));
-    });
-    eventTargetAndNames = removeKeyValueArrayDuplicates(eventTargetAndNames);
-
-    var attrNameAndValues = this._readAttrNameAndValues(directives, ast.attrs);
-    if (isPresent(component)) {
-      this.result.push(this.commandFactory.createBeginComponent(
-          ast.name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives,
-          component.template.encapsulation, ast.ngContentIndex));
-      templateVisitAll(this, ast.children);
-      this.result.push(this.commandFactory.createEndComponent());
-    } else {
-      this.result.push(this.commandFactory.createBeginElement(
-          ast.name, attrNameAndValues, eventTargetAndNames, variableNameAndValues, directives,
-          ast.isBound(), ast.ngContentIndex));
-      templateVisitAll(this, ast.children);
-      this.result.push(this.commandFactory.createEndElement());
-    }
-    return null;
-  }
-  visitVariable(ast: VariableAst, ctx: any): any { return null; }
-  visitAttr(ast: AttrAst, attrNameAndValues: string[]): any {
-    attrNameAndValues.push(ast.name);
-    attrNameAndValues.push(ast.value);
-    return null;
-  }
-  visitBoundText(ast: BoundTextAst, context: any): any {
-    this.result.push(this.commandFactory.createText(null, true, ast.ngContentIndex));
-    return null;
-  }
-  visitText(ast: TextAst, context: any): any {
-    this.result.push(this.commandFactory.createText(ast.value, false, ast.ngContentIndex));
-    return null;
-  }
-  visitDirective(ast: DirectiveAst, ctx: DirectiveContext): any {
-    ctx.targetDirectives.push(ast.directive);
-    templateVisitAll(this, ast.hostEvents, ctx.eventTargetAndNames);
-    ast.exportAsVars.forEach(varAst => {
-      ctx.targetVariableNameAndValues.push(varAst.name);
-      ctx.targetVariableNameAndValues.push(ctx.index);
-    });
-    return null;
-  }
-  visitEvent(ast: BoundEventAst, eventTargetAndNames: string[]): any {
-    eventTargetAndNames.push(ast.target);
-    eventTargetAndNames.push(ast.name);
-    return null;
-  }
-  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any { return null; }
-  visitElementProperty(ast: BoundElementPropertyAst, context: any): any { return null; }
-}
-
-function removeKeyValueArrayDuplicates(keyValueArray: string[]): string[] {
-  var knownPairs = new Set();
-  var resultKeyValueArray = [];
-  for (var i = 0; i < keyValueArray.length; i += 2) {
-    var key = keyValueArray[i];
-    var value = keyValueArray[i + 1];
-    var pairId = `${key}:${value}`;
-    if (!SetWrapper.has(knownPairs, pairId)) {
-      resultKeyValueArray.push(key);
-      resultKeyValueArray.push(value);
-      knownPairs.add(pairId);
-    }
-  }
-  return resultKeyValueArray;
-}
-
-function keyValueArrayToMap(keyValueArr: string[]): {[key: string]: string} {
-  var data: {[key: string]: string} = {};
-  for (var i = 0; i < keyValueArr.length; i += 2) {
-    data[keyValueArr[i]] = keyValueArr[i + 1];
-  }
-  return data;
-}
-
-function mapToKeyValueArray(data: {[key: string]: string}): string[] {
-  var entryArray = [];
-  StringMapWrapper.forEach(data, (value, name) => { entryArray.push([name, value]); });
-  // We need to sort to get a defined output order
-  // for tests and for caching generated artifacts...
-  ListWrapper.sort(entryArray, (entry1, entry2) => StringWrapper.compare(entry1[0], entry2[0]));
-  var keyValueArray = [];
-  entryArray.forEach((entry) => {
-    keyValueArray.push(entry[0]);
-    keyValueArray.push(entry[1]);
-  });
-  return keyValueArray;
-}
-
-function mergeAttributeValue(attrName: string, attrValue1: string, attrValue2: string): string {
-  if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {
-    return `${attrValue1} ${attrValue2}`;
-  } else {
-    return attrValue2;
-  }
-}
-
-class DirectiveContext {
-  constructor(public index: number, public eventTargetAndNames: string[],
-              public targetVariableNameAndValues: any[],
-              public targetDirectives: CompileDirectiveMetadata[]) {}
-}
-
-class Expression {
-  constructor(public value: string) {}
-}
-
-function escapeValue(value: any): string {
-  if (value instanceof Expression) {
-    return value.value;
-  } else if (isString(value)) {
-    return escapeSingleQuoteString(value);
-  } else if (isBlank(value)) {
-    return 'null';
-  } else {
-    return `${value}`;
-  }
-}
-
-function codeGenArray(data: any[]): string {
-  var base = `[${data.map(escapeValue).join(',')}]`;
-  return IS_DART ? `const ${base}` : base;
-}
-
-function codeGenDirectivesArray(directives: CompileDirectiveMetadata[]): string {
-  var expressions = directives.map(
-      directiveType => `${moduleRef(directiveType.type.moduleUrl)}${directiveType.type.name}`);
-  var base = `[${expressions.join(',')}]`;
-  return IS_DART ? `const ${base}` : base;
-}
-
-function codeGenViewEncapsulation(value: ViewEncapsulation): string {
-  if (IS_DART) {
-    return `${TEMPLATE_COMMANDS_MODULE_REF}${value}`;
-  } else {
-    return `${value}`;
-  }
-}
diff --git a/modules/angular2/src/compiler/compiler.ts b/modules/angular2/src/compiler/compiler.ts
index c35bc91..23426ce 100644
--- a/modules/angular2/src/compiler/compiler.ts
+++ b/modules/angular2/src/compiler/compiler.ts
@@ -17,7 +17,8 @@ import {TemplateNormalizer} from 'angular2/src/compiler/template_normalizer';
 import {RuntimeMetadataResolver} from 'angular2/src/compiler/runtime_metadata';
 import {ChangeDetectionCompiler} from 'angular2/src/compiler/change_detector_compiler';
 import {StyleCompiler} from 'angular2/src/compiler/style_compiler';
-import {CommandCompiler} from 'angular2/src/compiler/command_compiler';
+import {ViewCompiler} from 'angular2/src/compiler/view_compiler';
+import {ProtoViewCompiler} from 'angular2/src/compiler/proto_view_compiler';
 import {TemplateCompiler} from 'angular2/src/compiler/template_compiler';
 import {ChangeDetectorGenConfig} from 'angular2/src/core/change_detection/change_detection';
 import {Compiler} from 'angular2/src/core/linker/compiler';
@@ -44,7 +45,8 @@ export const COMPILER_PROVIDERS: Array<Type | Provider | any[]> = CONST_EXPR([
   RuntimeMetadataResolver,
   DEFAULT_PACKAGE_URL_PROVIDER,
   StyleCompiler,
-  CommandCompiler,
+  ProtoViewCompiler,
+  ViewCompiler,
   ChangeDetectionCompiler,
   new Provider(ChangeDetectorGenConfig, {useFactory: _createChangeDetectorGenConfig, deps: []}),
   TemplateCompiler,
diff --git a/modules/angular2/src/compiler/directive_metadata.ts b/modules/angular2/src/compiler/directive_metadata.ts
index f82f6b0..2fe7ef0 100644
--- a/modules/angular2/src/compiler/directive_metadata.ts
+++ b/modules/angular2/src/compiler/directive_metadata.ts
@@ -7,6 +7,7 @@ import {
   RegExpWrapper,
   StringWrapper
 } from 'angular2/src/facade/lang';
+import {unimplemented} from 'angular2/src/facade/exceptions';
 import {StringMapWrapper} from 'angular2/src/facade/collection';
 import {
   ChangeDetectionStrategy,
@@ -21,6 +22,16 @@ import {LifecycleHooks, LIFECYCLE_HOOKS_VALUES} from 'angular2/src/core/linker/i
 // group 2: "event" from "(event)"
 var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
 
+export abstract class CompileMetadataWithType {
+  static fromJson(data: {[key: string]: any}): CompileMetadataWithType {
+    return _COMPILE_METADATA_FROM_JSON[data['class']](data);
+  }
+
+  abstract toJson(): {[key: string]: any};
+
+  get type(): CompileTypeMetadata { return unimplemented(); }
+}
+
 /**
  * Metadata regarding compilation of a type.
  */
@@ -107,7 +118,7 @@ export class CompileTemplateMetadata {
 /**
  * Metadata regarding compilation of a directive.
  */
-export class CompileDirectiveMetadata {
+export class CompileDirectiveMetadata implements CompileMetadataWithType {
   static create({type, isComponent, dynamicLoadable, selector, exportAs, changeDetection, inputs,
                  outputs, host, lifecycleHooks, template}: {
     type?: CompileTypeMetadata,
@@ -241,6 +252,7 @@ export class CompileDirectiveMetadata {
 
   toJson(): {[key: string]: any} {
     return {
+      'class': 'Directive',
       'isComponent': this.isComponent,
       'dynamicLoadable': this.dynamicLoadable,
       'selector': this.selector,
@@ -284,3 +296,38 @@ export function createHostComponentMeta(componentType: CompileTypeMetadata,
     selector: '*'
   });
 }
+
+
+export class CompilePipeMetadata implements CompileMetadataWithType {
+  type: CompileTypeMetadata;
+  name: string;
+  pure: boolean;
+  constructor({type, name,
+               pure}: {type?: CompileTypeMetadata, name?: string, pure?: boolean} = {}) {
+    this.type = type;
+    this.name = name;
+    this.pure = normalizeBool(pure);
+  }
+
+  static fromJson(data: {[key: string]: any}): CompilePipeMetadata {
+    return new CompilePipeMetadata({
+      type: isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
+      name: data['name'],
+      pure: data['pure']
+    });
+  }
+
+  toJson(): {[key: string]: any} {
+    return {
+      'class': 'Pipe',
+      'type': isPresent(this.type) ? this.type.toJson() : null,
+      'name': this.name,
+      'pure': this.pure
+    };
+  }
+}
+
+var _COMPILE_METADATA_FROM_JSON = {
+  'Directive': CompileDirectiveMetadata.fromJson,
+  'Pipe': CompilePipeMetadata.fromJson
+};
diff --git a/modules/angular2/src/compiler/proto_view_compiler.ts b/modules/angular2/src/compiler/proto_view_compiler.ts
new file mode 100644
index 0000000..9b21139
--- /dev/null
+++ b/modules/angular2/src/compiler/proto_view_compiler.ts
@@ -0,0 +1,397 @@
+import {
+  isPresent,
+  isBlank,
+  Type,
+  isString,
+  StringWrapper,
+  IS_DART,
+  CONST_EXPR
+} from 'angular2/src/facade/lang';
+import {
+  SetWrapper,
+  StringMapWrapper,
+  ListWrapper,
+  MapWrapper
+} from 'angular2/src/facade/collection';
+import {
+  TemplateAst,
+  TemplateAstVisitor,
+  NgContentAst,
+  EmbeddedTemplateAst,
+  ElementAst,
+  VariableAst,
+  BoundEventAst,
+  BoundElementPropertyAst,
+  AttrAst,
+  BoundTextAst,
+  TextAst,
+  DirectiveAst,
+  BoundDirectivePropertyAst,
+  templateVisitAll
+} from './template_ast';
+import {
+  CompileTypeMetadata,
+  CompileDirectiveMetadata,
+  CompilePipeMetadata
+} from './directive_metadata';
+import {SourceExpressions, SourceExpression, moduleRef} from './source_module';
+import {AppProtoView, AppView} from 'angular2/src/core/linker/view';
+import {ViewType} from 'angular2/src/core/linker/view_type';
+import {AppProtoElement, AppElement} from 'angular2/src/core/linker/element';
+import {ResolvedMetadataCache} from 'angular2/src/core/linker/resolved_metadata_cache';
+import {
+  escapeSingleQuoteString,
+  codeGenConstConstructorCall,
+  codeGenValueFn,
+  codeGenFnHeader,
+  MODULE_SUFFIX,
+  codeGenStringMap,
+  Expression,
+  Statement
+} from './util';
+import {Injectable} from 'angular2/src/core/di';
+
+export const PROTO_VIEW_JIT_IMPORTS = CONST_EXPR(
+    {'AppProtoView': AppProtoView, 'AppProtoElement': AppProtoElement, 'ViewType': ViewType});
+
+// TODO: have a single file that reexports everything needed for
+// codegen explicitly
+// - helps understanding what codegen works against
+// - less imports in codegen code
+export var APP_VIEW_MODULE_REF = moduleRef('package:angular2/src/core/linker/view' + MODULE_SUFFIX);
+export var VIEW_TYPE_MODULE_REF =
+    moduleRef('package:angular2/src/core/linker/view_type' + MODULE_SUFFIX);
+export var APP_EL_MODULE_REF =
+    moduleRef('package:angular2/src/core/linker/element' + MODULE_SUFFIX);
+export var METADATA_MODULE_REF =
+    moduleRef('package:angular2/src/core/metadata/view' + MODULE_SUFFIX);
+
+const IMPLICIT_TEMPLATE_VAR = '\$implicit';
+const CLASS_ATTR = 'class';
+const STYLE_ATTR = 'style';
+
+@Injectable()
+export class ProtoViewCompiler {
+  constructor() {}
+
+  compileProtoViewRuntime(metadataCache: ResolvedMetadataCache, component: CompileDirectiveMetadata,
+                          template: TemplateAst[], pipes: CompilePipeMetadata[]):
+      CompileProtoViews<AppProtoView, AppProtoElement, any> {
+    var protoViewFactory = new RuntimeProtoViewFactory(metadataCache, component, pipes);
+    var allProtoViews = [];
+    protoViewFactory.createCompileProtoView(template, [], [], allProtoViews);
+    return new CompileProtoViews<AppProtoView, AppProtoElement, any>([], allProtoViews);
+  }
+
+  compileProtoViewCodeGen(resolvedMetadataCacheExpr: Expression,
+                          component: CompileDirectiveMetadata, template: TemplateAst[],
+                          pipes: CompilePipeMetadata[]):
+      CompileProtoViews<Expression, Expression, string> {
+    var protoViewFactory = new CodeGenProtoViewFactory(resolvedMetadataCacheExpr, component, pipes);
+    var allProtoViews = [];
+    var allStatements = [];
+    protoViewFactory.createCompileProtoView(template, [], allStatements, allProtoViews);
+    return new CompileProtoViews<Expression, Expression, string>(
+        allStatements.map(stmt => stmt.statement), allProtoViews);
+  }
+}
+
+export class CompileProtoViews<APP_PROTO_VIEW, APP_PROTO_EL, STATEMENT> {
+  constructor(public declarations: STATEMENT[],
+              public protoViews: CompileProtoView<APP_PROTO_VIEW, APP_PROTO_EL>[]) {}
+}
+
+
+export class CompileProtoView<APP_PROTO_VIEW, APP_PROTO_EL> {
+  constructor(public embeddedTemplateIndex: number,
+              public protoElements: CompileProtoElement<APP_PROTO_EL>[],
+              public protoView: APP_PROTO_VIEW) {}
+}
+
+export class CompileProtoElement<APP_PROTO_EL> {
+  constructor(public boundElementIndex, public attrNameAndValues: string[][],
+              public variableNameAndValues: string[][], public renderEvents: BoundEventAst[],
+              public directives: CompileDirectiveMetadata[], public embeddedTemplateIndex: number,
+              public appProtoEl: APP_PROTO_EL) {}
+}
+
+function visitAndReturnContext(visitor: TemplateAstVisitor, asts: TemplateAst[],
+                               context: any): any {
+  templateVisitAll(visitor, asts, context);
+  return context;
+}
+
+abstract class ProtoViewFactory<APP_PROTO_VIEW, APP_PROTO_EL, STATEMENT> {
+  constructor(public component: CompileDirectiveMetadata) {}
+
+  abstract createAppProtoView(embeddedTemplateIndex: number, viewType: ViewType,
+                              templateVariableBindings: string[][],
+                              targetStatements: STATEMENT[]): APP_PROTO_VIEW;
+
+  abstract createAppProtoElement(boundElementIndex: number, attrNameAndValues: string[][],
+                                 variableNameAndValues: string[][],
+                                 directives: CompileDirectiveMetadata[],
+                                 targetStatements: STATEMENT[]): APP_PROTO_EL;
+
+  createCompileProtoView(template: TemplateAst[], templateVariableBindings: string[][],
+                         targetStatements: STATEMENT[],
+                         targetProtoViews: CompileProtoView<APP_PROTO_VIEW, APP_PROTO_EL>[]):
+      CompileProtoView<APP_PROTO_VIEW, APP_PROTO_EL> {
+    var embeddedTemplateIndex = targetProtoViews.length;
+    // Note: targetProtoViews needs to be in depth first order.
+    // So we "reserve" a space here that we fill after the recursion is done
+    targetProtoViews.push(null);
+    var builder = new ProtoViewBuilderVisitor<APP_PROTO_VIEW, APP_PROTO_EL, any>(
+        this, targetStatements, targetProtoViews);
+    templateVisitAll(builder, template);
+    var viewType = getViewType(this.component, embeddedTemplateIndex);
+    var appProtoView = this.createAppProtoView(embeddedTemplateIndex, viewType,
+                                               templateVariableBindings, targetStatements);
+    var cpv = new CompileProtoView<APP_PROTO_VIEW, APP_PROTO_EL>(
+        embeddedTemplateIndex, builder.protoElements, appProtoView);
+    targetProtoViews[embeddedTemplateIndex] = cpv;
+    return cpv;
+  }
+}
+
+class CodeGenProtoViewFactory extends ProtoViewFactory<Expression, Expression, Statement> {
+  private _nextVarId: number = 0;
+
+  constructor(public resolvedMetadataCacheExpr: Expression, component: CompileDirectiveMetadata,
+              public pipes: CompilePipeMetadata[]) {
+    super(component);
+  }
+
+  private _nextProtoViewVar(embeddedTemplateIndex: number): string {
+    return `appProtoView${this._nextVarId++}_${this.component.type.name}${embeddedTemplateIndex}`;
+  }
+
+  createAppProtoView(embeddedTemplateIndex: number, viewType: ViewType,
+                     templateVariableBindings: string[][],
+                     targetStatements: Statement[]): Expression {
+    var protoViewVarName = this._nextProtoViewVar(embeddedTemplateIndex);
+    var viewTypeExpr = codeGenViewType(viewType);
+    var pipesExpr = embeddedTemplateIndex === 0 ?
+                        codeGenTypesArray(this.pipes.map(pipeMeta => pipeMeta.type)) :
+                        null;
+    var statement =
+        `var ${protoViewVarName} = ${APP_VIEW_MODULE_REF}AppProtoView.create(${this.resolvedMetadataCacheExpr.expression}, ${viewTypeExpr}, ${pipesExpr}, ${codeGenStringMap(templateVariableBindings)});`;
+    targetStatements.push(new Statement(statement));
+    return new Expression(protoViewVarName);
+  }
+
+  createAppProtoElement(boundElementIndex: number, attrNameAndValues: string[][],
+                        variableNameAndValues: string[][], directives: CompileDirectiveMetadata[],
+                        targetStatements: Statement[]): Expression {
+    var varName = `appProtoEl${this._nextVarId++}_${this.component.type.name}`;
+    var value = `${APP_EL_MODULE_REF}AppProtoElement.create(
+        ${this.resolvedMetadataCacheExpr.expression},
+        ${boundElementIndex},
+        ${codeGenStringMap(attrNameAndValues)},
+        ${codeGenDirectivesArray(directives)},
+        ${codeGenStringMap(variableNameAndValues)}
+      )`;
+    var statement = `var ${varName} = ${value};`;
+    targetStatements.push(new Statement(statement));
+    return new Expression(varName);
+  }
+}
+
+class RuntimeProtoViewFactory extends ProtoViewFactory<AppProtoView, AppProtoElement, any> {
+  constructor(public metadataCache: ResolvedMetadataCache, component: CompileDirectiveMetadata,
+              public pipes: CompilePipeMetadata[]) {
+    super(component);
+  }
+
+  createAppProtoView(embeddedTemplateIndex: number, viewType: ViewType,
+                     templateVariableBindings: string[][], targetStatements: any[]): AppProtoView {
+    var pipes =
+        embeddedTemplateIndex === 0 ? this.pipes.map(pipeMeta => pipeMeta.type.runtime) : [];
+    var templateVars = keyValueArrayToStringMap(templateVariableBindings);
+    return AppProtoView.create(this.metadataCache, viewType, pipes, templateVars);
+  }
+
+  createAppProtoElement(boundElementIndex: number, attrNameAndValues: string[][],
+                        variableNameAndValues: string[][], directives: CompileDirectiveMetadata[],
+                        targetStatements: any[]): AppProtoElement {
+    var attrs = keyValueArrayToStringMap(attrNameAndValues);
+    return AppProtoElement.create(this.metadataCache, boundElementIndex, attrs,
+                                  directives.map(dirMeta => dirMeta.type.runtime),
+                                  keyValueArrayToStringMap(variableNameAndValues));
+  }
+}
+
+class ProtoViewBuilderVisitor<APP_PROTO_VIEW, APP_PROTO_EL, STATEMENT> implements
+    TemplateAstVisitor {
+  protoElements: CompileProtoElement<APP_PROTO_EL>[] = [];
+  boundElementCount: number = 0;
+
+  constructor(public factory: ProtoViewFactory<APP_PROTO_VIEW, APP_PROTO_EL, STATEMENT>,
+              public allStatements: STATEMENT[],
+              public allProtoViews: CompileProtoView<APP_PROTO_VIEW, APP_PROTO_EL>[]) {}
+
+  private _readAttrNameAndValues(directives: CompileDirectiveMetadata[],
+                                 attrAsts: TemplateAst[]): string[][] {
+    var attrs = visitAndReturnContext(this, attrAsts, {});
+    directives.forEach(directiveMeta => {
+      StringMapWrapper.forEach(directiveMeta.hostAttributes, (value, name) => {
+        var prevValue = attrs[name];
+        attrs[name] = isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
+      });
+    });
+    return mapToKeyValueArray(attrs);
+  }
+
+  visitBoundText(ast: BoundTextAst, context: any): any { return null; }
+  visitText(ast: TextAst, context: any): any { return null; }
+
+  visitNgContent(ast: NgContentAst, context: any): any { return null; }
+
+  visitElement(ast: ElementAst, context: any): any {
+    var boundElementIndex = null;
+    if (ast.isBound()) {
+      boundElementIndex = this.boundElementCount++;
+    }
+    var component = ast.getComponent();
+
+    var variableNameAndValues: string[][] = [];
+    if (isBlank(component)) {
+      ast.exportAsVars.forEach((varAst) => { variableNameAndValues.push([varAst.name, null]); });
+    }
+    var directives = [];
+    var renderEvents: Map<string, BoundEventAst> =
+        visitAndReturnContext(this, ast.outputs, new Map<string, BoundEventAst>());
+    ListWrapper.forEachWithIndex(ast.directives, (directiveAst: DirectiveAst, index: number) => {
+      directiveAst.visit(this, new DirectiveContext(index, boundElementIndex, renderEvents,
+                                                    variableNameAndValues, directives));
+    });
+    var renderEventArray = [];
+    renderEvents.forEach((eventAst, _) => renderEventArray.push(eventAst));
+
+    var attrNameAndValues = this._readAttrNameAndValues(directives, ast.attrs);
+    this._addProtoElement(ast.isBound(), boundElementIndex, attrNameAndValues,
+                          variableNameAndValues, renderEventArray, directives, null);
+    templateVisitAll(this, ast.children);
+    return null;
+  }
+
+  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {
+    var boundElementIndex = this.boundElementCount++;
+    var directives: CompileDirectiveMetadata[] = [];
+    ListWrapper.forEachWithIndex(ast.directives, (directiveAst: DirectiveAst, index: number) => {
+      directiveAst.visit(
+          this, new DirectiveContext(index, boundElementIndex, new Map<string, BoundEventAst>(), [],
+                                     directives));
+    });
+
+    var attrNameAndValues = this._readAttrNameAndValues(directives, ast.attrs);
+    var templateVariableBindings = ast.vars.map(
+        varAst => [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name]);
+    var nestedProtoView = this.factory.createCompileProtoView(
+        ast.children, templateVariableBindings, this.allStatements, this.allProtoViews);
+    this._addProtoElement(true, boundElementIndex, attrNameAndValues, [], [], directives,
+                          nestedProtoView.embeddedTemplateIndex);
+    return null;
+  }
+
+  private _addProtoElement(isBound: boolean, boundElementIndex, attrNameAndValues: string[][],
+                           variableNameAndValues: string[][], renderEvents: BoundEventAst[],
+                           directives: CompileDirectiveMetadata[], embeddedTemplateIndex: number) {
+    var appProtoEl = null;
+    if (isBound) {
+      appProtoEl =
+          this.factory.createAppProtoElement(boundElementIndex, attrNameAndValues,
+                                             variableNameAndValues, directives, this.allStatements);
+    }
+    var compileProtoEl = new CompileProtoElement<APP_PROTO_EL>(
+        boundElementIndex, attrNameAndValues, variableNameAndValues, renderEvents, directives,
+        embeddedTemplateIndex, appProtoEl);
+    this.protoElements.push(compileProtoEl);
+  }
+
+  visitVariable(ast: VariableAst, ctx: any): any { return null; }
+  visitAttr(ast: AttrAst, attrNameAndValues: {[key: string]: string}): any {
+    attrNameAndValues[ast.name] = ast.value;
+    return null;
+  }
+  visitDirective(ast: DirectiveAst, ctx: DirectiveContext): any {
+    ctx.targetDirectives.push(ast.directive);
+    templateVisitAll(this, ast.hostEvents, ctx.hostEventTargetAndNames);
+    ast.exportAsVars.forEach(
+        varAst => { ctx.targetVariableNameAndValues.push([varAst.name, ctx.index]); });
+    return null;
+  }
+  visitEvent(ast: BoundEventAst, eventTargetAndNames: Map<string, BoundEventAst>): any {
+    eventTargetAndNames.set(ast.fullName, ast);
+    return null;
+  }
+  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any { return null; }
+  visitElementProperty(ast: BoundElementPropertyAst, context: any): any { return null; }
+}
+
+function mapToKeyValueArray(data: {[key: string]: string}): string[][] {
+  var entryArray = [];
+  StringMapWrapper.forEach(data, (value, name) => { entryArray.push([name, value]); });
+  // We need to sort to get a defined output order
+  // for tests and for caching generated artifacts...
+  ListWrapper.sort(entryArray, (entry1, entry2) => StringWrapper.compare(entry1[0], entry2[0]));
+  var keyValueArray = [];
+  entryArray.forEach((entry) => { keyValueArray.push([entry[0], entry[1]]); });
+  return keyValueArray;
+}
+
+function mergeAttributeValue(attrName: string, attrValue1: string, attrValue2: string): string {
+  if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {
+    return `${attrValue1} ${attrValue2}`;
+  } else {
+    return attrValue2;
+  }
+}
+
+class DirectiveContext {
+  constructor(public index: number, public boundElementIndex: number,
+              public hostEventTargetAndNames: Map<string, BoundEventAst>,
+              public targetVariableNameAndValues: any[][],
+              public targetDirectives: CompileDirectiveMetadata[]) {}
+}
+
+function keyValueArrayToStringMap(keyValueArray: any[][]): {[key: string]: any} {
+  var stringMap: {[key: string]: string} = {};
+  for (var i = 0; i < keyValueArray.length; i++) {
+    var entry = keyValueArray[i];
+    stringMap[entry[0]] = entry[1];
+  }
+  return stringMap;
+}
+
+function codeGenDirectivesArray(directives: CompileDirectiveMetadata[]): string {
+  var expressions = directives.map(directiveType => typeRef(directiveType.type));
+  return `[${expressions.join(',')}]`;
+}
+
+function codeGenTypesArray(types: CompileTypeMetadata[]): string {
+  var expressions = types.map(typeRef);
+  return `[${expressions.join(',')}]`;
+}
+
+function codeGenViewType(value: ViewType): string {
+  if (IS_DART) {
+    return `${VIEW_TYPE_MODULE_REF}${value}`;
+  } else {
+    return `${value}`;
+  }
+}
+
+function typeRef(type: CompileTypeMetadata): string {
+  return `${moduleRef(type.moduleUrl)}${type.name}`;
+}
+
+function getViewType(component: CompileDirectiveMetadata, embeddedTemplateIndex: number): ViewType {
+  if (embeddedTemplateIndex > 0) {
+    return ViewType.EMBEDDED;
+  } else if (component.type.isHost) {
+    return ViewType.HOST;
+  } else {
+    return ViewType.COMPONENT;
+  }
+}
diff --git a/modules/angular2/src/compiler/runtime_compiler.ts b/modules/angular2/src/compiler/runtime_compiler.ts
index 54ae61b..07ac299 100644
--- a/modules/angular2/src/compiler/runtime_compiler.ts
+++ b/modules/angular2/src/compiler/runtime_compiler.ts
@@ -1,23 +1,23 @@
-import {Compiler, Compiler_, internalCreateProtoView} from 'angular2/src/core/linker/compiler';
-import {ProtoViewRef} from 'angular2/src/core/linker/view_ref';
-import {ProtoViewFactory} from 'angular2/src/core/linker/proto_view_factory';
+import {Compiler, Compiler_} from 'angular2/src/core/linker/compiler';
+import {HostViewFactoryRef, HostViewFactoryRef_} from 'angular2/src/core/linker/view_ref';
 import {TemplateCompiler} from './template_compiler';
 
 import {Injectable} from 'angular2/src/core/di';
 import {Type} from 'angular2/src/facade/lang';
 import {Promise, PromiseWrapper} from 'angular2/src/facade/async';
 
-export abstract class RuntimeCompiler extends Compiler {}
+export abstract class RuntimeCompiler extends Compiler {
+  abstract compileInHost(componentType: Type): Promise<HostViewFactoryRef>;
+  abstract clearCache();
+}
 
 @Injectable()
 export class RuntimeCompiler_ extends Compiler_ implements RuntimeCompiler {
-  constructor(_protoViewFactory: ProtoViewFactory, private _templateCompiler: TemplateCompiler) {
-    super(_protoViewFactory);
-  }
+  constructor(private _templateCompiler: TemplateCompiler) { super(); }
 
-  compileInHost(componentType: Type): Promise<ProtoViewRef> {
+  compileInHost(componentType: Type): Promise<HostViewFactoryRef_> {
     return this._templateCompiler.compileHostComponentRuntime(componentType)
-        .then(compiledHostTemplate => internalCreateProtoView(this, compiledHostTemplate));
+        .then(hostViewFactory => new HostViewFactoryRef_(hostViewFactory));
   }
 
   clearCache() {
diff --git a/modules/angular2/src/compiler/runtime_metadata.ts b/modules/angular2/src/compiler/runtime_metadata.ts
index 1fceb0e..51b3494 100644
--- a/modules/angular2/src/compiler/runtime_metadata.ts
+++ b/modules/angular2/src/compiler/runtime_metadata.ts
@@ -11,25 +11,29 @@ import {BaseException} from 'angular2/src/facade/exceptions';
 import * as cpl from './directive_metadata';
 import * as md from 'angular2/src/core/metadata/directives';
 import {DirectiveResolver} from 'angular2/src/core/linker/directive_resolver';
+import {PipeResolver} from 'angular2/src/core/linker/pipe_resolver';
 import {ViewResolver} from 'angular2/src/core/linker/view_resolver';
 import {ViewMetadata} from 'angular2/src/core/metadata/view';
 import {hasLifecycleHook} from 'angular2/src/core/linker/directive_lifecycle_reflector';
 import {LifecycleHooks, LIFECYCLE_HOOKS_VALUES} from 'angular2/src/core/linker/interfaces';
 import {reflector} from 'angular2/src/core/reflection/reflection';
 import {Injectable, Inject, Optional} from 'angular2/src/core/di';
-import {PLATFORM_DIRECTIVES} from 'angular2/src/core/platform_directives_and_pipes';
+import {PLATFORM_DIRECTIVES, PLATFORM_PIPES} from 'angular2/src/core/platform_directives_and_pipes';
 import {MODULE_SUFFIX} from './util';
 import {getUrlScheme} from 'angular2/src/compiler/url_resolver';
 
 @Injectable()
 export class RuntimeMetadataResolver {
-  private _cache = new Map<Type, cpl.CompileDirectiveMetadata>();
+  private _directiveCache = new Map<Type, cpl.CompileDirectiveMetadata>();
+  private _pipeCache = new Map<Type, cpl.CompilePipeMetadata>();
 
-  constructor(private _directiveResolver: DirectiveResolver, private _viewResolver: ViewResolver,
-              @Optional() @Inject(PLATFORM_DIRECTIVES) private _platformDirectives: Type[]) {}
+  constructor(private _directiveResolver: DirectiveResolver, private _pipeResolver: PipeResolver,
+              private _viewResolver: ViewResolver,
+              @Optional() @Inject(PLATFORM_DIRECTIVES) private _platformDirectives: Type[],
+              @Optional() @Inject(PLATFORM_PIPES) private _platformPipes: Type[]) {}
 
-  getMetadata(directiveType: Type): cpl.CompileDirectiveMetadata {
-    var meta = this._cache.get(directiveType);
+  getDirectiveMetadata(directiveType: Type): cpl.CompileDirectiveMetadata {
+    var meta = this._directiveCache.get(directiveType);
     if (isBlank(meta)) {
       var dirMeta = this._directiveResolver.resolve(directiveType);
       var moduleUrl = null;
@@ -63,7 +67,23 @@ export class RuntimeMetadataResolver {
         host: dirMeta.host,
         lifecycleHooks: LIFECYCLE_HOOKS_VALUES.filter(hook => hasLifecycleHook(hook, directiveType))
       });
-      this._cache.set(directiveType, meta);
+      this._directiveCache.set(directiveType, meta);
+    }
+    return meta;
+  }
+
+  getPipeMetadata(pipeType: Type): cpl.CompilePipeMetadata {
+    var meta = this._pipeCache.get(pipeType);
+    if (isBlank(meta)) {
+      var pipeMeta = this._pipeResolver.resolve(pipeType);
+      var moduleUrl = reflector.importUri(pipeType);
+      meta = new cpl.CompilePipeMetadata({
+        type: new cpl.CompileTypeMetadata(
+            {name: stringify(pipeType), moduleUrl: moduleUrl, runtime: pipeType}),
+        name: pipeMeta.name,
+        pure: pipeMeta.pure
+      });
+      this._pipeCache.set(pipeType, meta);
     }
     return meta;
   }
@@ -72,13 +92,25 @@ export class RuntimeMetadataResolver {
     var view = this._viewResolver.resolve(component);
     var directives = flattenDirectives(view, this._platformDirectives);
     for (var i = 0; i < directives.length; i++) {
-      if (!isValidDirective(directives[i])) {
+      if (!isValidType(directives[i])) {
         throw new BaseException(
             `Unexpected directive value '${stringify(directives[i])}' on the View of component '${stringify(component)}'`);
       }
     }
 
-    return directives.map(type => this.getMetadata(type));
+    return directives.map(type => this.getDirectiveMetadata(type));
+  }
+
+  getViewPipesMetadata(component: Type): cpl.CompilePipeMetadata[] {
+    var view = this._viewResolver.resolve(component);
+    var pipes = flattenPipes(view, this._platformPipes);
+    for (var i = 0; i < pipes.length; i++) {
+      if (!isValidType(pipes[i])) {
+        throw new BaseException(
+            `Unexpected piped value '${stringify(pipes[i])}' on the View of component '${stringify(component)}'`);
+      }
+    }
+    return pipes.map(type => this.getPipeMetadata(type));
   }
 }
 
@@ -93,6 +125,17 @@ function flattenDirectives(view: ViewMetadata, platformDirectives: any[]): Type[
   return directives;
 }
 
+function flattenPipes(view: ViewMetadata, platformPipes: any[]): Type[] {
+  let pipes = [];
+  if (isPresent(platformPipes)) {
+    flattenArray(platformPipes, pipes);
+  }
+  if (isPresent(view.pipes)) {
+    flattenArray(view.pipes, pipes);
+  }
+  return pipes;
+}
+
 function flattenArray(tree: any[], out: Array<Type | any[]>): void {
   for (var i = 0; i < tree.length; i++) {
     var item = resolveForwardRef(tree[i]);
@@ -104,7 +147,7 @@ function flattenArray(tree: any[], out: Array<Type | any[]>): void {
   }
 }
 
-function isValidDirective(value: Type): boolean {
+function isValidType(value: Type): boolean {
   return isPresent(value) && (value instanceof Type);
 }
 
diff --git a/modules/angular2/src/compiler/source_module.ts b/modules/angular2/src/compiler/source_module.ts
index 49dc23a..c100d36 100644
--- a/modules/angular2/src/compiler/source_module.ts
+++ b/modules/angular2/src/compiler/source_module.ts
@@ -10,6 +10,10 @@ export function moduleRef(moduleUrl): string {
  * Represents generated source code with module references. Internal to the Angular compiler.
  */
 export class SourceModule {
+  static getSourceWithoutImports(sourceWithModuleRefs: string): string {
+    return StringWrapper.replaceAllMapped(sourceWithModuleRefs, MODULE_REGEXP, (match) => '');
+  }
+
   constructor(public moduleUrl: string, public sourceWithModuleRefs: string) {}
 
   getSourceWithImports(): SourceWithImports {
diff --git a/modules/angular2/src/compiler/style_compiler.ts b/modules/angular2/src/compiler/style_compiler.ts
index a4ee6fd..8cc5437 100644
--- a/modules/angular2/src/compiler/style_compiler.ts
+++ b/modules/angular2/src/compiler/style_compiler.ts
@@ -14,7 +14,10 @@ import {
   MODULE_SUFFIX
 } from './util';
 import {Injectable} from 'angular2/src/core/di';
-import {COMPONENT_VARIABLE, HOST_ATTR, CONTENT_ATTR} from 'angular2/src/core/render/view_factory';
+
+const COMPONENT_VARIABLE = '%COMP%';
+const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
+const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
 
 @Injectable()
 export class StyleCompiler {
diff --git a/modules/angular2/src/compiler/template_compiler.ts b/modules/angular2/src/compiler/template_compiler.ts
index 06b6300..54a5fcc 100644
--- a/modules/angular2/src/compiler/template_compiler.ts
+++ b/modules/angular2/src/compiler/template_compiler.ts
@@ -1,37 +1,74 @@
-import {IS_DART, Type, Json, isBlank, stringify} from 'angular2/src/facade/lang';
+import {
+  IS_DART,
+  Type,
+  Json,
+  isBlank,
+  isPresent,
+  stringify,
+  evalExpression
+} from 'angular2/src/facade/lang';
 import {BaseException} from 'angular2/src/facade/exceptions';
-import {ListWrapper, SetWrapper, MapWrapper} from 'angular2/src/facade/collection';
-import {PromiseWrapper, Promise} from 'angular2/src/facade/async';
 import {
-  CompiledComponentTemplate,
-  TemplateCmd,
-  CompiledHostTemplate,
-  BeginComponentCmd
-} from 'angular2/src/core/linker/template_commands';
+  ListWrapper,
+  SetWrapper,
+  MapWrapper,
+  StringMapWrapper
+} from 'angular2/src/facade/collection';
+import {PromiseWrapper, Promise} from 'angular2/src/facade/async';
 import {
   createHostComponentMeta,
   CompileDirectiveMetadata,
   CompileTypeMetadata,
-  CompileTemplateMetadata
+  CompileTemplateMetadata,
+  CompilePipeMetadata,
+  CompileMetadataWithType
 } from './directive_metadata';
-import {TemplateAst} from './template_ast';
+import {
+  TemplateAst,
+  TemplateAstVisitor,
+  NgContentAst,
+  EmbeddedTemplateAst,
+  ElementAst,
+  VariableAst,
+  BoundEventAst,
+  BoundElementPropertyAst,
+  AttrAst,
+  BoundTextAst,
+  TextAst,
+  DirectiveAst,
+  BoundDirectivePropertyAst,
+  templateVisitAll
+} from './template_ast';
 import {Injectable} from 'angular2/src/core/di';
-import {SourceModule, moduleRef} from './source_module';
-import {ChangeDetectionCompiler} from './change_detector_compiler';
+import {SourceModule, moduleRef, SourceExpression} from './source_module';
+import {ChangeDetectionCompiler, CHANGE_DETECTION_JIT_IMPORTS} from './change_detector_compiler';
 import {StyleCompiler} from './style_compiler';
-import {CommandCompiler} from './command_compiler';
-import {TemplateParser} from './template_parser';
+import {ViewCompiler, VIEW_JIT_IMPORTS} from './view_compiler';
+import {
+  ProtoViewCompiler,
+  APP_VIEW_MODULE_REF,
+  CompileProtoView,
+  PROTO_VIEW_JIT_IMPORTS
+} from './proto_view_compiler';
+import {TemplateParser, PipeCollector} from './template_parser';
 import {TemplateNormalizer} from './template_normalizer';
 import {RuntimeMetadataResolver} from './runtime_metadata';
+import {HostViewFactory} from 'angular2/src/core/linker/view';
+import {ChangeDetectorGenConfig} from 'angular2/src/core/change_detection/change_detection';
+import {ResolvedMetadataCache} from 'angular2/src/core/linker/resolved_metadata_cache';
 
-import {TEMPLATE_COMMANDS_MODULE_REF} from './command_compiler';
 import {
   codeGenExportVariable,
   escapeSingleQuoteString,
   codeGenValueFn,
-  MODULE_SUFFIX
+  MODULE_SUFFIX,
+  addAll,
+  Expression
 } from './util';
 
+export var METADATA_CACHE_MODULE_REF =
+    moduleRef('package:angular2/src/core/linker/resolved_metadata_cache' + MODULE_SUFFIX);
+
 /**
  * An internal module of the Angular compiler that begins with component types,
  * extracts templates, and eventually produces a compiled version of the component
@@ -40,15 +77,16 @@ import {
 @Injectable()
 export class TemplateCompiler {
   private _hostCacheKeys = new Map<Type, any>();
-  private _compiledTemplateCache = new Map<any, CompiledComponentTemplate>();
-  private _compiledTemplateDone = new Map<any, Promise<CompiledComponentTemplate>>();
-  private _nextTemplateId: number = 0;
+  private _compiledTemplateCache = new Map<any, CompiledTemplate>();
+  private _compiledTemplateDone = new Map<any, Promise<CompiledTemplate>>();
 
   constructor(private _runtimeMetadataResolver: RuntimeMetadataResolver,
               private _templateNormalizer: TemplateNormalizer,
               private _templateParser: TemplateParser, private _styleCompiler: StyleCompiler,
-              private _commandCompiler: CommandCompiler,
-              private _cdCompiler: ChangeDetectionCompiler) {}
+              private _cdCompiler: ChangeDetectionCompiler,
+              private _protoViewCompiler: ProtoViewCompiler, private _viewCompiler: ViewCompiler,
+              private _resolvedMetadataCache: ResolvedMetadataCache,
+              private _genConfig: ChangeDetectorGenConfig) {}
 
   normalizeDirectiveMetadata(directive: CompileDirectiveMetadata):
       Promise<CompileDirectiveMetadata> {
@@ -75,171 +113,203 @@ export class TemplateCompiler {
               }));
   }
 
-  compileHostComponentRuntime(type: Type): Promise<CompiledHostTemplate> {
+  compileHostComponentRuntime(type: Type): Promise<HostViewFactory> {
+    var compMeta: CompileDirectiveMetadata =
+        this._runtimeMetadataResolver.getDirectiveMetadata(type);
     var hostCacheKey = this._hostCacheKeys.get(type);
     if (isBlank(hostCacheKey)) {
       hostCacheKey = new Object();
       this._hostCacheKeys.set(type, hostCacheKey);
-      var compMeta: CompileDirectiveMetadata = this._runtimeMetadataResolver.getMetadata(type);
       assertComponent(compMeta);
       var hostMeta: CompileDirectiveMetadata =
           createHostComponentMeta(compMeta.type, compMeta.selector);
 
-      this._compileComponentRuntime(hostCacheKey, hostMeta, [compMeta], new Set());
+      this._compileComponentRuntime(hostCacheKey, hostMeta, [compMeta], [], new Set());
     }
     return this._compiledTemplateDone.get(hostCacheKey)
-        .then(compiledTemplate => new CompiledHostTemplate(compiledTemplate));
+        .then((compiledTemplate: CompiledTemplate) =>
+                  new HostViewFactory(compMeta.selector, compiledTemplate.viewFactory));
   }
 
   clearCache() {
-    this._hostCacheKeys.clear();
     this._styleCompiler.clearCache();
     this._compiledTemplateCache.clear();
     this._compiledTemplateDone.clear();
+    this._hostCacheKeys.clear();
+  }
+
+  compileTemplatesCodeGen(components: NormalizedComponentWithViewDirectives[]): SourceModule {
+    if (components.length === 0) {
+      throw new BaseException('No components given');
+    }
+    var declarations = [];
+    components.forEach(componentWithDirs => {
+      var compMeta = <CompileDirectiveMetadata>componentWithDirs.component;
+      assertComponent(compMeta);
+      this._compileComponentCodeGen(compMeta, componentWithDirs.directives, componentWithDirs.pipes,
+                                    declarations);
+      if (compMeta.dynamicLoadable) {
+        var hostMeta = createHostComponentMeta(compMeta.type, compMeta.selector);
+        var viewFactoryExpression =
+            this._compileComponentCodeGen(hostMeta, [compMeta], [], declarations);
+        var constructionKeyword = IS_DART ? 'const' : 'new';
+        var compiledTemplateExpr =
+            `${constructionKeyword} ${APP_VIEW_MODULE_REF}HostViewFactory('${compMeta.selector}',${viewFactoryExpression})`;
+        var varName = codeGenHostViewFactoryName(compMeta.type);
+        declarations.push(`${codeGenExportVariable(varName)}${compiledTemplateExpr};`);
+      }
+    });
+    var moduleUrl = components[0].component.type.moduleUrl;
+    return new SourceModule(`${templateModuleUrl(moduleUrl)}`, declarations.join('\n'));
   }
 
-  private _compileComponentRuntime(
-      cacheKey: any, compMeta: CompileDirectiveMetadata, viewDirectives: CompileDirectiveMetadata[],
-      compilingComponentCacheKeys: Set<any>): CompiledComponentTemplate {
-    let uniqViewDirectives = removeDuplicates(viewDirectives);
+  compileStylesheetCodeGen(stylesheetUrl: string, cssText: string): SourceModule[] {
+    return this._styleCompiler.compileStylesheetCodeGen(stylesheetUrl, cssText);
+  }
+
+
+
+  private _compileComponentRuntime(cacheKey: any, compMeta: CompileDirectiveMetadata,
+                                   viewDirectives: CompileDirectiveMetadata[],
+                                   pipes: CompilePipeMetadata[],
+                                   compilingComponentCacheKeys: Set<any>): CompiledTemplate {
+    let uniqViewDirectives = <CompileDirectiveMetadata[]>removeDuplicates(viewDirectives);
+    let uniqViewPipes = <CompilePipeMetadata[]>removeDuplicates(pipes);
     var compiledTemplate = this._compiledTemplateCache.get(cacheKey);
     var done = this._compiledTemplateDone.get(cacheKey);
     if (isBlank(compiledTemplate)) {
-      var styles = [];
-      var changeDetectorFactory;
-      var commands = [];
-      var templateId = `${stringify(compMeta.type.runtime)}Template${this._nextTemplateId++}`;
-      compiledTemplate = new CompiledComponentTemplate(
-          templateId, (dispatcher) => changeDetectorFactory(dispatcher), commands, styles);
+      compiledTemplate = new CompiledTemplate();
       this._compiledTemplateCache.set(cacheKey, compiledTemplate);
       compilingComponentCacheKeys.add(cacheKey);
       done = PromiseWrapper
                  .all([<any>this._styleCompiler.compileComponentRuntime(compMeta.template)].concat(
                      uniqViewDirectives.map(dirMeta => this.normalizeDirectiveMetadata(dirMeta))))
                  .then((stylesAndNormalizedViewDirMetas: any[]) => {
-                   var childPromises = [];
                    var normalizedViewDirMetas = stylesAndNormalizedViewDirMetas.slice(1);
+                   var styles = stylesAndNormalizedViewDirMetas[0];
                    var parsedTemplate = this._templateParser.parse(
-                       compMeta.template.template, normalizedViewDirMetas, compMeta.type.name);
-
-                   var changeDetectorFactories = this._cdCompiler.compileComponentRuntime(
-                       compMeta.type, compMeta.changeDetection, parsedTemplate);
-                   changeDetectorFactory = changeDetectorFactories[0];
-                   var tmpStyles: string[] = stylesAndNormalizedViewDirMetas[0];
-                   tmpStyles.forEach(style => styles.push(style));
-                   var tmpCommands: TemplateCmd[] = this._compileCommandsRuntime(
-                       compMeta, parsedTemplate, changeDetectorFactories,
-                       compilingComponentCacheKeys, childPromises);
-                   tmpCommands.forEach(cmd => commands.push(cmd));
-                   return PromiseWrapper.all(childPromises);
-                 })
-                 .then((_) => {
-                   SetWrapper.delete(compilingComponentCacheKeys, cacheKey);
-                   return compiledTemplate;
+                       compMeta.template.template, normalizedViewDirMetas, uniqViewPipes,
+                       compMeta.type.name);
+
+                   var childPromises = [];
+                   var usedDirectives = DirectiveCollector.findUsedDirectives(parsedTemplate);
+                   usedDirectives.components.forEach(
+                       component => this._compileNestedComponentRuntime(
+                           component, compilingComponentCacheKeys, childPromises));
+                   return PromiseWrapper.all(childPromises)
+                       .then((_) => {
+                         var filteredPipes = filterPipes(parsedTemplate, uniqViewPipes);
+                         compiledTemplate.init(this._createViewFactoryRuntime(
+                             compMeta, parsedTemplate, usedDirectives.directives, styles,
+                             filteredPipes));
+                         SetWrapper.delete(compilingComponentCacheKeys, cacheKey);
+                         return compiledTemplate;
+                       });
                  });
       this._compiledTemplateDone.set(cacheKey, done);
     }
     return compiledTemplate;
   }
 
-  private _compileCommandsRuntime(compMeta: CompileDirectiveMetadata, parsedTemplate: TemplateAst[],
-                                  changeDetectorFactories: Function[],
-                                  compilingComponentCacheKeys: Set<Type>,
-                                  childPromises: Promise<any>[]): TemplateCmd[] {
-    var cmds: TemplateCmd[] = this._commandCompiler.compileComponentRuntime(
-        compMeta, parsedTemplate, changeDetectorFactories,
-        (childComponentDir: CompileDirectiveMetadata) => {
-          var childCacheKey = childComponentDir.type.runtime;
-          var childViewDirectives: CompileDirectiveMetadata[] =
-              this._runtimeMetadataResolver.getViewDirectivesMetadata(
-                  childComponentDir.type.runtime);
-          var childIsRecursive = SetWrapper.has(compilingComponentCacheKeys, childCacheKey);
-          var childTemplate = this._compileComponentRuntime(
-              childCacheKey, childComponentDir, childViewDirectives, compilingComponentCacheKeys);
-          if (!childIsRecursive) {
-            // Only wait for a child if it is not a cycle
-            childPromises.push(this._compiledTemplateDone.get(childCacheKey));
-          }
-          return () => childTemplate;
-        });
-    cmds.forEach(cmd => {
-      if (cmd instanceof BeginComponentCmd) {
-        cmd.templateGetter();
-      }
-    });
-    return cmds;
+  private _compileNestedComponentRuntime(childComponentDir: CompileDirectiveMetadata,
+                                         compilingComponentCacheKeys: Set<Type>,
+                                         childPromises: Promise<any>[]) {
+    var childCacheKey = childComponentDir.type.runtime;
+    var childViewDirectives: CompileDirectiveMetadata[] =
+        this._runtimeMetadataResolver.getViewDirectivesMetadata(childComponentDir.type.runtime);
+    var childViewPipes: CompilePipeMetadata[] =
+        this._runtimeMetadataResolver.getViewPipesMetadata(childComponentDir.type.runtime);
+    var childIsRecursive = SetWrapper.has(compilingComponentCacheKeys, childCacheKey);
+    this._compileComponentRuntime(childCacheKey, childComponentDir, childViewDirectives,
+                                  childViewPipes, compilingComponentCacheKeys);
+    if (!childIsRecursive) {
+      // Only wait for a child if it is not a cycle
+      childPromises.push(this._compiledTemplateDone.get(childCacheKey));
+    }
   }
 
-  compileTemplatesCodeGen(components: NormalizedComponentWithViewDirectives[]): SourceModule {
-    if (components.length === 0) {
-      throw new BaseException('No components given');
+  private _createViewFactoryRuntime(compMeta: CompileDirectiveMetadata,
+                                    parsedTemplate: TemplateAst[],
+                                    directives: CompileDirectiveMetadata[], styles: string[],
+                                    pipes: CompilePipeMetadata[]): Function {
+    if (IS_DART || !this._genConfig.useJit) {
+      var changeDetectorFactories = this._cdCompiler.compileComponentRuntime(
+          compMeta.type, compMeta.changeDetection, parsedTemplate);
+      var protoViews = this._protoViewCompiler.compileProtoViewRuntime(
+          this._resolvedMetadataCache, compMeta, parsedTemplate, pipes);
+      return this._viewCompiler.compileComponentRuntime(
+          compMeta, parsedTemplate, styles, protoViews.protoViews, changeDetectorFactories,
+          (compMeta) => this._getNestedComponentViewFactory(compMeta));
+    } else {
+      var declarations = [];
+      var viewFactoryExpr = this._createViewFactoryCodeGen('resolvedMetadataCache', compMeta,
+                                                           new SourceExpression([], 'styles'),
+                                                           parsedTemplate, pipes, declarations);
+      var vars: {[key: string]: any} =
+          {'exports': {}, 'styles': styles, 'resolvedMetadataCache': this._resolvedMetadataCache};
+      directives.forEach(dirMeta => {
+        vars[dirMeta.type.name] = dirMeta.type.runtime;
+        if (dirMeta.isComponent && dirMeta.type.runtime !== compMeta.type.runtime) {
+          vars[`viewFactory_${dirMeta.type.name}0`] = this._getNestedComponentViewFactory(dirMeta);
+        }
+      });
+      pipes.forEach(pipeMeta => vars[pipeMeta.type.name] = pipeMeta.type.runtime);
+      var declarationsWithoutImports =
+          SourceModule.getSourceWithoutImports(declarations.join('\n'));
+      return evalExpression(
+          `viewFactory_${compMeta.type.name}`, viewFactoryExpr, declarationsWithoutImports,
+          mergeStringMaps(
+              [vars, CHANGE_DETECTION_JIT_IMPORTS, PROTO_VIEW_JIT_IMPORTS, VIEW_JIT_IMPORTS]));
     }
-    var declarations = [];
-    var templateArguments = [];
-    var componentMetas: CompileDirectiveMetadata[] = [];
-    components.forEach(componentWithDirs => {
-      var compMeta = <CompileDirectiveMetadata>componentWithDirs.component;
-      assertComponent(compMeta);
-      componentMetas.push(compMeta);
-
-      this._processTemplateCodeGen(compMeta, componentWithDirs.directives, declarations,
-                                   templateArguments);
-      if (compMeta.dynamicLoadable) {
-        var hostMeta = createHostComponentMeta(compMeta.type, compMeta.selector);
-        componentMetas.push(hostMeta);
-        this._processTemplateCodeGen(hostMeta, [compMeta], declarations, templateArguments);
-      }
-    });
-    ListWrapper.forEachWithIndex(componentMetas, (compMeta: CompileDirectiveMetadata,
-                                                  index: number) => {
-      var templateId = `${compMeta.type.moduleUrl}|${compMeta.type.name}`;
-      var constructionKeyword = IS_DART ? 'const' : 'new';
-      var compiledTemplateExpr =
-          `${constructionKeyword} ${TEMPLATE_COMMANDS_MODULE_REF}CompiledComponentTemplate('${templateId}',${(<any[]>templateArguments[index]).join(',')})`;
-      var variableValueExpr;
-      if (compMeta.type.isHost) {
-        variableValueExpr =
-            `${constructionKeyword} ${TEMPLATE_COMMANDS_MODULE_REF}CompiledHostTemplate(${compiledTemplateExpr})`;
-      } else {
-        variableValueExpr = compiledTemplateExpr;
-      }
-      var varName = templateVariableName(compMeta.type);
-      declarations.push(`${codeGenExportVariable(varName)}${variableValueExpr};`);
-      declarations.push(`${codeGenValueFn([], varName, templateGetterName(compMeta.type))};`);
-    });
-    var moduleUrl = components[0].component.type.moduleUrl;
-    return new SourceModule(`${templateModuleUrl(moduleUrl)}`, declarations.join('\n'));
   }
 
-  compileStylesheetCodeGen(stylesheetUrl: string, cssText: string): SourceModule[] {
-    return this._styleCompiler.compileStylesheetCodeGen(stylesheetUrl, cssText);
+  private _getNestedComponentViewFactory(compMeta: CompileDirectiveMetadata): Function {
+    return this._compiledTemplateCache.get(compMeta.type.runtime).viewFactory;
   }
 
-  private _processTemplateCodeGen(compMeta: CompileDirectiveMetadata,
-                                  directives: CompileDirectiveMetadata[],
-                                  targetDeclarations: string[], targetTemplateArguments: any[][]) {
-    let uniqueDirectives = removeDuplicates(directives);
+  private _compileComponentCodeGen(compMeta: CompileDirectiveMetadata,
+                                   directives: CompileDirectiveMetadata[],
+                                   pipes: CompilePipeMetadata[],
+                                   targetDeclarations: string[]): string {
+    let uniqueDirectives = <CompileDirectiveMetadata[]>removeDuplicates(directives);
+    let uniqPipes = <CompilePipeMetadata[]>removeDuplicates(pipes);
     var styleExpr = this._styleCompiler.compileComponentCodeGen(compMeta.template);
     var parsedTemplate = this._templateParser.parse(compMeta.template.template, uniqueDirectives,
-                                                    compMeta.type.name);
+                                                    uniqPipes, compMeta.type.name);
+    var filteredPipes = filterPipes(parsedTemplate, uniqPipes);
+    return this._createViewFactoryCodeGen(
+        `${METADATA_CACHE_MODULE_REF}CODEGEN_RESOLVED_METADATA_CACHE`, compMeta, styleExpr,
+        parsedTemplate, filteredPipes, targetDeclarations);
+  }
+
+  private _createViewFactoryCodeGen(resolvedMetadataCacheExpr: string,
+                                    compMeta: CompileDirectiveMetadata, styleExpr: SourceExpression,
+                                    parsedTemplate: TemplateAst[], pipes: CompilePipeMetadata[],
+                                    targetDeclarations: string[]): string {
     var changeDetectorsExprs = this._cdCompiler.compileComponentCodeGen(
         compMeta.type, compMeta.changeDetection, parsedTemplate);
-    var commandsExpr = this._commandCompiler.compileComponentCodeGen(
-        compMeta, parsedTemplate, changeDetectorsExprs.expressions,
-        codeGenComponentTemplateFactory);
+    var protoViewExprs = this._protoViewCompiler.compileProtoViewCodeGen(
+        new Expression(resolvedMetadataCacheExpr), compMeta, parsedTemplate, pipes);
+    var viewFactoryExpr = this._viewCompiler.compileComponentCodeGen(
+        compMeta, parsedTemplate, styleExpr, protoViewExprs.protoViews, changeDetectorsExprs,
+        codeGenComponentViewFactoryName);
 
-    addAll(styleExpr.declarations, targetDeclarations);
     addAll(changeDetectorsExprs.declarations, targetDeclarations);
-    addAll(commandsExpr.declarations, targetDeclarations);
+    addAll(protoViewExprs.declarations, targetDeclarations);
+    addAll(viewFactoryExpr.declarations, targetDeclarations);
 
-    targetTemplateArguments.push(
-        [changeDetectorsExprs.expressions[0], commandsExpr.expression, styleExpr.expression]);
+    return viewFactoryExpr.expression;
   }
 }
 
 export class NormalizedComponentWithViewDirectives {
   constructor(public component: CompileDirectiveMetadata,
-              public directives: CompileDirectiveMetadata[]) {}
+              public directives: CompileDirectiveMetadata[], public pipes: CompilePipeMetadata[]) {}
+}
+
+class CompiledTemplate {
+  viewFactory: Function = null;
+  init(viewFactory: Function) { this.viewFactory = viewFactory; }
 }
 
 function assertComponent(meta: CompileDirectiveMetadata) {
@@ -248,30 +318,28 @@ function assertComponent(meta: CompileDirectiveMetadata) {
   }
 }
 
-function templateVariableName(type: CompileTypeMetadata): string {
-  return `${type.name}Template`;
-}
-
-function templateGetterName(type: CompileTypeMetadata): string {
-  return `${templateVariableName(type)}Getter`;
-}
-
 function templateModuleUrl(moduleUrl: string): string {
   var urlWithoutSuffix = moduleUrl.substring(0, moduleUrl.length - MODULE_SUFFIX.length);
   return `${urlWithoutSuffix}.template${MODULE_SUFFIX}`;
 }
 
-function addAll(source: any[], target: any[]) {
-  for (var i = 0; i < source.length; i++) {
-    target.push(source[i]);
-  }
+
+function codeGenHostViewFactoryName(type: CompileTypeMetadata): string {
+  return `hostViewFactory_${type.name}`;
+}
+
+function codeGenComponentViewFactoryName(nestedCompType: CompileDirectiveMetadata): string {
+  return `${moduleRef(templateModuleUrl(nestedCompType.type.moduleUrl))}viewFactory_${nestedCompType.type.name}0`;
 }
 
-function codeGenComponentTemplateFactory(nestedCompType: CompileDirectiveMetadata): string {
-  return `${moduleRef(templateModuleUrl(nestedCompType.type.moduleUrl))}${templateGetterName(nestedCompType.type)}`;
+function mergeStringMaps(maps: Array<{[key: string]: any}>): {[key: string]: any} {
+  var result = {};
+  maps.forEach(
+      (map) => { StringMapWrapper.forEach(map, (value, key) => { result[key] = value; }); });
+  return result;
 }
 
-function removeDuplicates(items: CompileDirectiveMetadata[]): CompileDirectiveMetadata[] {
+function removeDuplicates(items: CompileMetadataWithType[]): CompileMetadataWithType[] {
   let res = [];
   items.forEach(item => {
     let hasMatch =
@@ -284,3 +352,100 @@ function removeDuplicates(items: CompileDirectiveMetadata[]): CompileDirectiveMe
   });
   return res;
 }
+
+class DirectiveCollector implements TemplateAstVisitor {
+  static findUsedDirectives(parsedTemplate: TemplateAst[]): DirectiveCollector {
+    var collector = new DirectiveCollector();
+    templateVisitAll(collector, parsedTemplate);
+    return collector;
+  }
+
+  directives: CompileDirectiveMetadata[] = [];
+  components: CompileDirectiveMetadata[] = [];
+
+  visitBoundText(ast: BoundTextAst, context: any): any { return null; }
+  visitText(ast: TextAst, context: any): any { return null; }
+
+  visitNgContent(ast: NgContentAst, context: any): any { return null; }
+
+  visitElement(ast: ElementAst, context: any): any {
+    templateVisitAll(this, ast.directives);
+    templateVisitAll(this, ast.children);
+    return null;
+  }
+
+  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {
+    templateVisitAll(this, ast.directives);
+    templateVisitAll(this, ast.children);
+    return null;
+  }
+  visitVariable(ast: VariableAst, ctx: any): any { return null; }
+  visitAttr(ast: AttrAst, attrNameAndValues: {[key: string]: string}): any { return null; }
+  visitDirective(ast: DirectiveAst, ctx: any): any {
+    if (ast.directive.isComponent) {
+      this.components.push(ast.directive);
+    }
+    this.directives.push(ast.directive);
+    return null;
+  }
+  visitEvent(ast: BoundEventAst, eventTargetAndNames: Map<string, BoundEventAst>): any {
+    return null;
+  }
+  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any { return null; }
+  visitElementProperty(ast: BoundElementPropertyAst, context: any): any { return null; }
+}
+
+
+function filterPipes(template: TemplateAst[],
+                     allPipes: CompilePipeMetadata[]): CompilePipeMetadata[] {
+  var visitor = new PipeVisitor();
+  templateVisitAll(visitor, template);
+  return allPipes.filter((pipeMeta) => SetWrapper.has(visitor.collector.pipes, pipeMeta.name));
+}
+
+class PipeVisitor implements TemplateAstVisitor {
+  collector: PipeCollector = new PipeCollector();
+
+  visitBoundText(ast: BoundTextAst, context: any): any {
+    ast.value.visit(this.collector);
+    return null;
+  }
+  visitText(ast: TextAst, context: any): any { return null; }
+
+  visitNgContent(ast: NgContentAst, context: any): any { return null; }
+
+  visitElement(ast: ElementAst, context: any): any {
+    templateVisitAll(this, ast.inputs);
+    templateVisitAll(this, ast.outputs);
+    templateVisitAll(this, ast.directives);
+    templateVisitAll(this, ast.children);
+    return null;
+  }
+
+  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {
+    templateVisitAll(this, ast.outputs);
+    templateVisitAll(this, ast.directives);
+    templateVisitAll(this, ast.children);
+    return null;
+  }
+  visitVariable(ast: VariableAst, ctx: any): any { return null; }
+  visitAttr(ast: AttrAst, attrNameAndValues: {[key: string]: string}): any { return null; }
+  visitDirective(ast: DirectiveAst, ctx: any): any {
+    templateVisitAll(this, ast.inputs);
+    templateVisitAll(this, ast.hostEvents);
+    templateVisitAll(this, ast.hostProperties);
+    return null;
+  }
+  visitEvent(ast: BoundEventAst, eventTargetAndNames: Map<string, BoundEventAst>): any {
+    ast.handler.visit(this.collector);
+    return null;
+  }
+  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {
+    ast.value.visit(this.collector);
+    return null;
+  }
+  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {
+    ast.value.visit(this.collector);
+    return null;
+  }
+}
diff --git a/modules/angular2/src/compiler/template_parser.ts b/modules/angular2/src/compiler/template_parser.ts
index c933073..deaae63 100644
--- a/modules/angular2/src/compiler/template_parser.ts
+++ b/modules/angular2/src/compiler/template_parser.ts
@@ -5,10 +5,11 @@ import {CONST_EXPR} from 'angular2/src/facade/lang';
 import {BaseException} from 'angular2/src/facade/exceptions';
 import {Parser, AST, ASTWithSource} from 'angular2/src/core/change_detection/change_detection';
 import {TemplateBinding} from 'angular2/src/core/change_detection/parser/ast';
-import {CompileDirectiveMetadata} from './directive_metadata';
+import {CompileDirectiveMetadata, CompilePipeMetadata} from './directive_metadata';
 import {HtmlParser} from './html_parser';
 import {splitNsName} from './html_tags';
 import {ParseSourceSpan, ParseError, ParseLocation} from './parse_util';
+import {RecursiveAstVisitor, BindingPipe} from 'angular2/src/core/change_detection/parser/ast';
 
 
 import {
@@ -88,9 +89,10 @@ export class TemplateParser {
               private _htmlParser: HtmlParser,
               @Optional() @Inject(TEMPLATE_TRANSFORMS) public transforms: TemplateAstVisitor[]) {}
 
-  parse(template: string, directives: CompileDirectiveMetadata[],
+  parse(template: string, directives: CompileDirectiveMetadata[], pipes: CompilePipeMetadata[],
         templateUrl: string): TemplateAst[] {
-    var parseVisitor = new TemplateParseVisitor(directives, this._exprParser, this._schemaRegistry);
+    var parseVisitor =
+        new TemplateParseVisitor(directives, pipes, this._exprParser, this._schemaRegistry);
     var htmlAstWithErrors = this._htmlParser.parse(template, templateUrl);
     var result = htmlVisitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_COMPONENT);
     var errors: ParseError[] = htmlAstWithErrors.errors.concat(parseVisitor.errors);
@@ -111,9 +113,10 @@ class TemplateParseVisitor implements HtmlAstVisitor {
   errors: TemplateParseError[] = [];
   directivesIndex = new Map<CompileDirectiveMetadata, number>();
   ngContentCount: number = 0;
+  pipesByName: Map<string, CompilePipeMetadata>;
 
-  constructor(directives: CompileDirectiveMetadata[], private _exprParser: Parser,
-              private _schemaRegistry: ElementSchemaRegistry) {
+  constructor(directives: CompileDirectiveMetadata[], pipes: CompilePipeMetadata[],
+              private _exprParser: Parser, private _schemaRegistry: ElementSchemaRegistry) {
     this.selectorMatcher = new SelectorMatcher();
     ListWrapper.forEachWithIndex(directives,
                                  (directive: CompileDirectiveMetadata, index: number) => {
@@ -121,6 +124,8 @@ class TemplateParseVisitor implements HtmlAstVisitor {
                                    this.selectorMatcher.addSelectables(selector, directive);
                                    this.directivesIndex.set(directive, index);
                                  });
+    this.pipesByName = new Map<string, CompilePipeMetadata>();
+    pipes.forEach(pipe => this.pipesByName.set(pipe.name, pipe));
   }
 
   private _reportError(message: string, sourceSpan: ParseSourceSpan) {
@@ -130,7 +135,9 @@ class TemplateParseVisitor implements HtmlAstVisitor {
   private _parseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {
     var sourceInfo = sourceSpan.start.toString();
     try {
-      return this._exprParser.parseInterpolation(value, sourceInfo);
+      var ast = this._exprParser.parseInterpolation(value, sourceInfo);
+      this._checkPipes(ast, sourceSpan);
+      return ast;
     } catch (e) {
       this._reportError(`${e}`, sourceSpan);
       return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
@@ -140,7 +147,9 @@ class TemplateParseVisitor implements HtmlAstVisitor {
   private _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {
     var sourceInfo = sourceSpan.start.toString();
     try {
-      return this._exprParser.parseAction(value, sourceInfo);
+      var ast = this._exprParser.parseAction(value, sourceInfo);
+      this._checkPipes(ast, sourceSpan);
+      return ast;
     } catch (e) {
       this._reportError(`${e}`, sourceSpan);
       return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
@@ -150,7 +159,9 @@ class TemplateParseVisitor implements HtmlAstVisitor {
   private _parseBinding(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {
     var sourceInfo = sourceSpan.start.toString();
     try {
-      return this._exprParser.parseBinding(value, sourceInfo);
+      var ast = this._exprParser.parseBinding(value, sourceInfo);
+      this._checkPipes(ast, sourceSpan);
+      return ast;
     } catch (e) {
       this._reportError(`${e}`, sourceSpan);
       return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
@@ -160,13 +171,31 @@ class TemplateParseVisitor implements HtmlAstVisitor {
   private _parseTemplateBindings(value: string, sourceSpan: ParseSourceSpan): TemplateBinding[] {
     var sourceInfo = sourceSpan.start.toString();
     try {
-      return this._exprParser.parseTemplateBindings(value, sourceInfo);
+      var bindings = this._exprParser.parseTemplateBindings(value, sourceInfo);
+      bindings.forEach((binding) => {
+        if (isPresent(binding.expression)) {
+          this._checkPipes(binding.expression, sourceSpan);
+        }
+      });
+      return bindings;
     } catch (e) {
       this._reportError(`${e}`, sourceSpan);
       return [];
     }
   }
 
+  private _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan) {
+    if (isPresent(ast)) {
+      var collector = new PipeCollector();
+      ast.visit(collector);
+      collector.pipes.forEach((pipeName) => {
+        if (!this.pipesByName.has(pipeName)) {
+          this._reportError(`The pipe '${pipeName}' could not be found`, sourceSpan);
+        }
+      });
+    }
+  }
+
   visitText(ast: HtmlTextAst, component: Component): any {
     var ngContentIndex = component.findNgContentIndex(TEXT_CSS_SELECTOR);
     var expr = this._parseInterpolation(ast.value, ast.sourceSpan);
@@ -714,3 +743,14 @@ function createElementCssSelector(elementName: string, matchableAttrs: string[][
 
 var EMPTY_COMPONENT = new Component(new SelectorMatcher(), null);
 var NON_BINDABLE_VISITOR = new NonBindableVisitor();
+
+
+export class PipeCollector extends RecursiveAstVisitor {
+  pipes: Set<string> = new Set<string>();
+  visitPipe(ast: BindingPipe): any {
+    this.pipes.add(ast.name);
+    ast.exp.visit(this);
+    this.visitAll(ast.args);
+    return null;
+  }
+}
diff --git a/modules/angular2/src/compiler/util.ts b/modules/angular2/src/compiler/util.ts
index ca0c6e8..f3ebdfd 100644
--- a/modules/angular2/src/compiler/util.ts
+++ b/modules/angular2/src/compiler/util.ts
@@ -1,4 +1,11 @@
-import {IS_DART, StringWrapper, isBlank} from 'angular2/src/facade/lang';
+import {
+  IS_DART,
+  StringWrapper,
+  isBlank,
+  isPresent,
+  isString,
+  isArray
+} from 'angular2/src/facade/lang';
 
 var CAMEL_CASE_REGEXP = /([A-Z])/g;
 var DASH_CASE_REGEXP = /-([a-z])/g;
@@ -7,6 +14,8 @@ var DOUBLE_QUOTE_ESCAPE_STRING_RE = /"|\\|\n|\r|\$/g;
 
 export var MODULE_SUFFIX = IS_DART ? '.dart' : '.js';
 
+export var CONST_VAR = IS_DART ? 'const' : 'var';
+
 export function camelCaseToDashCase(input: string): string {
   return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP,
                                         (m) => { return '-' + m[1].toLowerCase(); });
@@ -63,12 +72,19 @@ export function codeGenConstConstructorCall(name: string): string {
 
 export function codeGenValueFn(params: string[], value: string, fnName: string = ''): string {
   if (IS_DART) {
-    return `${fnName}(${params.join(',')}) => ${value}`;
+    return `${codeGenFnHeader(params, fnName)} => ${value}`;
   } else {
-    return `function ${fnName}(${params.join(',')}) { return ${value}; }`;
+    return `${codeGenFnHeader(params, fnName)} { return ${value}; }`;
   }
 }
 
+export function codeGenFnHeader(params: string[], fnName: string = ''): string {
+  if (IS_DART) {
+    return `${fnName}(${params.join(',')})`;
+  } else {
+    return `function ${fnName}(${params.join(',')})`;
+  }
+}
 export function codeGenToString(expr: string): string {
   if (IS_DART) {
     return `'\${${expr}}'`;
@@ -86,3 +102,77 @@ export function splitAtColon(input: string, defaultValues: string[]): string[] {
     return defaultValues;
   }
 }
+
+
+export class Statement {
+  constructor(public statement: string) {}
+}
+
+export class Expression {
+  constructor(public expression: string, public isArray = false) {}
+}
+
+export function escapeValue(value: any): string {
+  if (value instanceof Expression) {
+    return value.expression;
+  } else if (isString(value)) {
+    return escapeSingleQuoteString(value);
+  } else if (isBlank(value)) {
+    return 'null';
+  } else {
+    return `${value}`;
+  }
+}
+
+export function codeGenArray(data: any[]): string {
+  return `[${data.map(escapeValue).join(',')}]`;
+}
+
+export function codeGenFlatArray(values: any[]): string {
+  var result = '([';
+  var isFirstArrayEntry = true;
+  var concatFn = IS_DART ? '.addAll' : 'concat';
+  for (var i = 0; i < values.length; i++) {
+    var value = values[i];
+    if (value instanceof Expression && (<Expression>value).isArray) {
+      result += `]).${concatFn}(${value.expression}).${concatFn}([`;
+      isFirstArrayEntry = true;
+    } else {
+      if (!isFirstArrayEntry) {
+        result += ',';
+      }
+      isFirstArrayEntry = false;
+      result += escapeValue(value);
+    }
+  }
+  result += '])';
+  return result;
+}
+
+export function codeGenStringMap(keyValueArray: any[][]): string {
+  return `{${keyValueArray.map(codeGenKeyValue).join(',')}}`;
+}
+
+function codeGenKeyValue(keyValue: any[]): string {
+  return `${escapeValue(keyValue[0])}:${escapeValue(keyValue[1])}`;
+}
+
+export function addAll(source: any[], target: any[]) {
+  for (var i = 0; i < source.length; i++) {
+    target.push(source[i]);
+  }
+}
+
+export function flattenArray(source: any[], target: any[]): any[] {
+  if (isPresent(source)) {
+    for (var i = 0; i < source.length; i++) {
+      var item = source[i];
+      if (isArray(item)) {
+        flattenArray(item, target);
+      } else {
+        target.push(item);
+      }
+    }
+  }
+  return target;
+}
diff --git a/modules/angular2/src/compiler/view_compiler.ts b/modules/angular2/src/compiler/view_compiler.ts
new file mode 100644
index 0000000..2f6ec19
--- /dev/null
+++ b/modules/angular2/src/compiler/view_compiler.ts
@@ -0,0 +1,600 @@
+import {
+  isPresent,
+  isBlank,
+  Type,
+  isString,
+  StringWrapper,
+  IS_DART,
+  CONST_EXPR
+} from 'angular2/src/facade/lang';
+import {SetWrapper, StringMapWrapper, ListWrapper} from 'angular2/src/facade/collection';
+import {
+  TemplateAst,
+  TemplateAstVisitor,
+  NgContentAst,
+  EmbeddedTemplateAst,
+  ElementAst,
+  VariableAst,
+  BoundEventAst,
+  BoundElementPropertyAst,
+  AttrAst,
+  BoundTextAst,
+  TextAst,
+  DirectiveAst,
+  BoundDirectivePropertyAst,
+  templateVisitAll
+} from './template_ast';
+import {CompileTypeMetadata, CompileDirectiveMetadata} from './directive_metadata';
+import {SourceExpressions, SourceExpression, moduleRef} from './source_module';
+import {
+  AppProtoView,
+  AppView,
+  flattenNestedViewRenderNodes,
+  checkSlotCount
+} from 'angular2/src/core/linker/view';
+import {ViewType} from 'angular2/src/core/linker/view_type';
+import {AppViewManager_} from 'angular2/src/core/linker/view_manager';
+import {AppProtoElement, AppElement} from 'angular2/src/core/linker/element';
+import {Renderer, ParentRenderer} from 'angular2/src/core/render/api';
+import {ViewEncapsulation} from 'angular2/src/core/metadata/view';
+import {
+  escapeSingleQuoteString,
+  codeGenConstConstructorCall,
+  codeGenValueFn,
+  codeGenFnHeader,
+  MODULE_SUFFIX,
+  Statement,
+  escapeValue,
+  codeGenArray,
+  codeGenFlatArray,
+  Expression,
+  flattenArray,
+  CONST_VAR
+} from './util';
+import {ResolvedProvider, Injectable, Injector} from 'angular2/src/core/di';
+
+import {
+  APP_VIEW_MODULE_REF,
+  APP_EL_MODULE_REF,
+  METADATA_MODULE_REF,
+  CompileProtoView,
+  CompileProtoElement
+} from './proto_view_compiler';
+
+export const VIEW_JIT_IMPORTS = CONST_EXPR({
+  'AppView': AppView,
+  'AppElement': AppElement,
+  'flattenNestedViewRenderNodes': flattenNestedViewRenderNodes,
+  'checkSlotCount': checkSlotCount
+});
+
+
+@Injectable()
+export class ViewCompiler {
+  constructor() {}
+
+  compileComponentRuntime(component: CompileDirectiveMetadata, template: TemplateAst[],
+                          styles: Array<string | any[]>,
+                          protoViews: CompileProtoView<AppProtoView, AppProtoElement>[],
+                          changeDetectorFactories: Function[],
+                          componentViewFactory: Function): Function {
+    var viewFactory = new RuntimeViewFactory(component, styles, protoViews, changeDetectorFactories,
+                                             componentViewFactory);
+    return viewFactory.createViewFactory(template, 0, []);
+  }
+
+  compileComponentCodeGen(component: CompileDirectiveMetadata, template: TemplateAst[],
+                          styles: SourceExpression,
+                          protoViews: CompileProtoView<Expression, Expression>[],
+                          changeDetectorFactoryExpressions: SourceExpressions,
+                          componentViewFactory: Function): SourceExpression {
+    var viewFactory = new CodeGenViewFactory(
+        component, styles, protoViews, changeDetectorFactoryExpressions, componentViewFactory);
+    var targetStatements: Statement[] = [];
+    var viewFactoryExpression = viewFactory.createViewFactory(template, 0, targetStatements);
+    return new SourceExpression(targetStatements.map(stmt => stmt.statement),
+                                viewFactoryExpression.expression);
+  }
+}
+
+interface ViewFactory<EXPRESSION, STATEMENT> {
+  createText(renderer: EXPRESSION, parent: EXPRESSION, text: string,
+             targetStatements: STATEMENT[]): EXPRESSION;
+
+  createElement(renderer: EXPRESSION, parent: EXPRESSION, name: string, rootSelector: EXPRESSION,
+                targetStatements: STATEMENT[]): EXPRESSION;
+
+  createTemplateAnchor(renderer: EXPRESSION, parent: EXPRESSION,
+                       targetStatements: STATEMENT[]): EXPRESSION;
+
+  createGlobalEventListener(renderer: EXPRESSION, view: EXPRESSION, boundElementIndex: number,
+                            eventAst: BoundEventAst, targetStatements: STATEMENT[]): EXPRESSION;
+
+  createElementEventListener(renderer: EXPRESSION, view: EXPRESSION, boundElementIndex: number,
+                             renderNode: EXPRESSION, eventAst: BoundEventAst,
+                             targetStatements: STATEMENT[]);
+
+  setElementAttribute(renderer: EXPRESSION, renderNode: EXPRESSION, attrName: string,
+                      attrValue: string, targetStatements: STATEMENT[]);
+
+  createAppElement(appProtoEl: EXPRESSION, view: EXPRESSION, renderNode: EXPRESSION,
+                   parentAppEl: EXPRESSION, embeddedViewFactory: EXPRESSION,
+                   targetStatements: STATEMENT[]): EXPRESSION;
+
+  createAndSetComponentView(renderer: EXPRESSION, viewManager: EXPRESSION, view: EXPRESSION,
+                            appEl: EXPRESSION, component: CompileDirectiveMetadata,
+                            contentNodesByNgContentIndex: EXPRESSION[][],
+                            targetStatements: STATEMENT[]);
+
+  getProjectedNodes(projectableNodes: EXPRESSION, ngContentIndex: number): EXPRESSION;
+
+  appendProjectedNodes(renderer: EXPRESSION, parent: EXPRESSION, nodes: EXPRESSION,
+                       targetStatements: STATEMENT[]);
+
+  createViewFactory(asts: TemplateAst[], embeddedTemplateIndex: number,
+                    targetStatements: STATEMENT[]): EXPRESSION;
+}
+
+class CodeGenViewFactory implements ViewFactory<Expression, Statement> {
+  private _nextVarId: number = 0;
+  constructor(public component: CompileDirectiveMetadata, public styles: SourceExpression,
+              public protoViews: CompileProtoView<Expression, Expression>[],
+              public changeDetectorExpressions: SourceExpressions,
+              public componentViewFactory: Function) {}
+
+  private _nextVar(prefix: string): string {
+    return `${prefix}${this._nextVarId++}_${this.component.type.name}`;
+  }
+
+  private _nextRenderVar(): string { return this._nextVar('render'); }
+
+  private _nextAppVar(): string { return this._nextVar('app'); }
+
+  private _nextDisposableVar(): string {
+    return `disposable${this._nextVarId++}_${this.component.type.name}`;
+  }
+
+  createText(renderer: Expression, parent: Expression, text: string,
+             targetStatements: Statement[]): Expression {
+    var varName = this._nextRenderVar();
+    var statement =
+        `var ${varName} = ${renderer.expression}.createText(${isPresent(parent) ? parent.expression : null}, ${escapeSingleQuoteString(text)});`;
+    targetStatements.push(new Statement(statement));
+    return new Expression(varName);
+  }
+
+  createElement(renderer: Expression, parentRenderNode: Expression, name: string,
+                rootSelector: Expression, targetStatements: Statement[]): Expression {
+    var varName = this._nextRenderVar();
+    var valueExpr;
+    if (isPresent(rootSelector)) {
+      valueExpr = `${rootSelector.expression} == null ?
+        ${renderer.expression}.createElement(${isPresent(parentRenderNode) ? parentRenderNode.expression : null}, ${escapeSingleQuoteString(name)}) :
+        ${renderer.expression}.selectRootElement(${rootSelector.expression});`;
+    } else {
+      valueExpr =
+          `${renderer.expression}.createElement(${isPresent(parentRenderNode) ? parentRenderNode.expression : null}, ${escapeSingleQuoteString(name)})`;
+    }
+    var statement = `var ${varName} = ${valueExpr};`;
+    targetStatements.push(new Statement(statement));
+    return new Expression(varName);
+  }
+
+  createTemplateAnchor(renderer: Expression, parentRenderNode: Expression,
+                       targetStatements: Statement[]): Expression {
+    var varName = this._nextRenderVar();
+    var valueExpr =
+        `${renderer.expression}.createTemplateAnchor(${isPresent(parentRenderNode) ? parentRenderNode.expression : null});`;
+    targetStatements.push(new Statement(`var ${varName} = ${valueExpr}`));
+    return new Expression(varName);
+  }
+
+  createGlobalEventListener(renderer: Expression, appView: Expression, boundElementIndex: number,
+                            eventAst: BoundEventAst, targetStatements: Statement[]): Expression {
+    var disposableVar = this._nextDisposableVar();
+    var eventHandlerExpr = codeGenEventHandler(appView, boundElementIndex, eventAst.fullName);
+    targetStatements.push(new Statement(
+        `var ${disposableVar} = ${renderer.expression}.listenGlobal(${escapeValue(eventAst.target)}, ${escapeValue(eventAst.name)}, ${eventHandlerExpr});`));
+    return new Expression(disposableVar);
+  }
+
+  createElementEventListener(renderer: Expression, appView: Expression, boundElementIndex: number,
+                             renderNode: Expression, eventAst: BoundEventAst,
+                             targetStatements: Statement[]) {
+    var eventHandlerExpr = codeGenEventHandler(appView, boundElementIndex, eventAst.fullName);
+    targetStatements.push(new Statement(
+        `${renderer.expression}.listen(${renderNode.expression}, ${escapeValue(eventAst.name)}, ${eventHandlerExpr});`));
+  }
+
+  setElementAttribute(renderer: Expression, renderNode: Expression, attrName: string,
+                      attrValue: string, targetStatements: Statement[]) {
+    targetStatements.push(new Statement(
+        `${renderer.expression}.setElementAttribute(${renderNode.expression}, ${escapeSingleQuoteString(attrName)}, ${escapeSingleQuoteString(attrValue)});`));
+  }
+
+  createAppElement(appProtoEl: Expression, appView: Expression, renderNode: Expression,
+                   parentAppEl: Expression, embeddedViewFactory: Expression,
+                   targetStatements: Statement[]): Expression {
+    var appVar = this._nextAppVar();
+    var varValue =
+        `new ${APP_EL_MODULE_REF}AppElement(${appProtoEl.expression}, ${appView.expression},
+      ${isPresent(parentAppEl) ? parentAppEl.expression : null}, ${renderNode.expression}, ${isPresent(embeddedViewFactory) ? embeddedViewFactory.expression : null})`;
+    targetStatements.push(new Statement(`var ${appVar} = ${varValue};`));
+    return new Expression(appVar);
+  }
+
+  createAndSetComponentView(renderer: Expression, viewManager: Expression, view: Expression,
+                            appEl: Expression, component: CompileDirectiveMetadata,
+                            contentNodesByNgContentIndex: Expression[][],
+                            targetStatements: Statement[]) {
+    var codeGenContentNodes;
+    if (this.component.type.isHost) {
+      codeGenContentNodes = `${view.expression}.projectableNodes`;
+    } else {
+      codeGenContentNodes =
+          `[${contentNodesByNgContentIndex.map( nodes => codeGenFlatArray(nodes) ).join(',')}]`;
+    }
+    targetStatements.push(new Statement(
+        `${this.componentViewFactory(component)}(${renderer.expression}, ${viewManager.expression}, ${appEl.expression}, ${codeGenContentNodes}, null, null, null);`));
+  }
+
+  getProjectedNodes(projectableNodes: Expression, ngContentIndex: number): Expression {
+    return new Expression(`${projectableNodes.expression}[${ngContentIndex}]`, true);
+  }
+
+  appendProjectedNodes(renderer: Expression, parent: Expression, nodes: Expression,
+                       targetStatements: Statement[]) {
+    targetStatements.push(new Statement(
+        `${renderer.expression}.projectNodes(${parent.expression}, ${APP_VIEW_MODULE_REF}flattenNestedViewRenderNodes(${nodes.expression}));`));
+  }
+
+  createViewFactory(asts: TemplateAst[], embeddedTemplateIndex: number,
+                    targetStatements: Statement[]): Expression {
+    var compileProtoView = this.protoViews[embeddedTemplateIndex];
+    var isHostView = this.component.type.isHost;
+    var isComponentView = embeddedTemplateIndex === 0 && !isHostView;
+    var visitor = new ViewBuilderVisitor<Expression, Statement>(
+        new Expression('renderer'), new Expression('viewManager'),
+        new Expression('projectableNodes'), isHostView ? new Expression('rootSelector') : null,
+        new Expression('view'), compileProtoView, targetStatements, this);
+
+    templateVisitAll(
+        visitor, asts,
+        new ParentElement(isComponentView ? new Expression('parentRenderNode') : null, null, null));
+
+    var appProtoView = compileProtoView.protoView.expression;
+    var viewFactoryName = codeGenViewFactoryName(this.component, embeddedTemplateIndex);
+    var changeDetectorFactory = this.changeDetectorExpressions.expressions[embeddedTemplateIndex];
+    var factoryArgs = [
+      'parentRenderer',
+      'viewManager',
+      'containerEl',
+      'projectableNodes',
+      'rootSelector',
+      'dynamicallyCreatedProviders',
+      'rootInjector'
+    ];
+    var initRendererStmts = [];
+    var rendererExpr = `parentRenderer`;
+    if (embeddedTemplateIndex === 0) {
+      var renderCompTypeVar = this._nextVar('renderType');
+      targetStatements.push(new Statement(`var ${renderCompTypeVar} = null;`));
+      var stylesVar = this._nextVar('styles');
+      targetStatements.push(
+          new Statement(`${CONST_VAR} ${stylesVar} = ${this.styles.expression};`));
+      var encapsulation = this.component.template.encapsulation;
+      initRendererStmts.push(`if (${renderCompTypeVar} == null) {
+        ${renderCompTypeVar} = viewManager.createRenderComponentType(${codeGenViewEncapsulation(encapsulation)}, ${stylesVar});
+      }`);
+      rendererExpr = `parentRenderer.renderComponent(${renderCompTypeVar})`;
+    }
+    var statement = `
+${codeGenFnHeader(factoryArgs, viewFactoryName)}{
+  ${initRendererStmts.join('\n')}
+  var renderer = ${rendererExpr};
+  var view = new ${APP_VIEW_MODULE_REF}AppView(
+    ${appProtoView}, renderer, viewManager,
+    projectableNodes,
+    containerEl,
+    dynamicallyCreatedProviders, rootInjector,
+    ${changeDetectorFactory}()
+  );
+  ${APP_VIEW_MODULE_REF}checkSlotCount(${escapeValue(this.component.type.name)}, ${this.component.template.ngContentSelectors.length}, projectableNodes);
+  ${isComponentView ? 'var parentRenderNode = renderer.createViewRoot(view.containerAppElement.nativeElement);' : ''}
+  ${visitor.renderStmts.map(stmt => stmt.statement).join('\n')}
+  ${visitor.appStmts.map(stmt => stmt.statement).join('\n')}
+
+  view.init(${codeGenFlatArray(visitor.rootNodesOrAppElements)}, ${codeGenArray(visitor.renderNodes)}, ${codeGenArray(visitor.appDisposables)},
+            ${codeGenArray(visitor.appElements)});
+  return view;
+}`;
+    targetStatements.push(new Statement(statement));
+    return new Expression(viewFactoryName);
+  }
+}
+
+class RuntimeViewFactory implements ViewFactory<any, any> {
+  constructor(public component: CompileDirectiveMetadata, public styles: Array<string | any[]>,
+              public protoViews: CompileProtoView<AppProtoView, AppProtoElement>[],
+              public changeDetectorFactories: Function[], public componentViewFactory: Function) {}
+
+  createText(renderer: Renderer, parent: any, text: string, targetStatements: any[]): any {
+    return renderer.createText(parent, text);
+  }
+
+  createElement(renderer: Renderer, parent: any, name: string, rootSelector: string,
+                targetStatements: any[]): any {
+    var el;
+    if (isPresent(rootSelector)) {
+      el = renderer.selectRootElement(rootSelector);
+    } else {
+      el = renderer.createElement(parent, name);
+    }
+    return el;
+  }
+
+  createTemplateAnchor(renderer: Renderer, parent: any, targetStatements: any[]): any {
+    return renderer.createTemplateAnchor(parent);
+  }
+
+  createGlobalEventListener(renderer: Renderer, appView: AppView, boundElementIndex: number,
+                            eventAst: BoundEventAst, targetStatements: any[]): any {
+    return renderer.listenGlobal(
+        eventAst.target, eventAst.name,
+        (event) => appView.triggerEventHandlers(eventAst.fullName, event, boundElementIndex));
+  }
+
+  createElementEventListener(renderer: Renderer, appView: AppView, boundElementIndex: number,
+                             renderNode: any, eventAst: BoundEventAst, targetStatements: any[]) {
+    renderer.listen(renderNode, eventAst.name, (event) => appView.triggerEventHandlers(
+                                                   eventAst.fullName, event, boundElementIndex));
+  }
+
+  setElementAttribute(renderer: Renderer, renderNode: any, attrName: string, attrValue: string,
+                      targetStatements: any[]) {
+    renderer.setElementAttribute(renderNode, attrName, attrValue);
+  }
+
+  createAppElement(appProtoEl: AppProtoElement, appView: AppView, renderNode: any,
+                   parentAppEl: AppElement, embeddedViewFactory: Function,
+                   targetStatements: any[]): any {
+    return new AppElement(appProtoEl, appView, parentAppEl, renderNode, embeddedViewFactory);
+  }
+
+  createAndSetComponentView(renderer: Renderer, viewManager: AppViewManager_, appView: AppView,
+                            appEl: AppElement, component: CompileDirectiveMetadata,
+                            contentNodesByNgContentIndex: Array<Array<any | any[]>>,
+                            targetStatements: any[]) {
+    var flattenedContentNodes;
+    if (this.component.type.isHost) {
+      flattenedContentNodes = appView.projectableNodes;
+    } else {
+      flattenedContentNodes = ListWrapper.createFixedSize(contentNodesByNgContentIndex.length);
+      for (var i = 0; i < contentNodesByNgContentIndex.length; i++) {
+        flattenedContentNodes[i] = flattenArray(contentNodesByNgContentIndex[i], []);
+      }
+    }
+    this.componentViewFactory(component)(renderer, viewManager, appEl, flattenedContentNodes);
+  }
+
+  getProjectedNodes(projectableNodes: any[][], ngContentIndex: number): any[] {
+    return projectableNodes[ngContentIndex];
+  }
+
+  appendProjectedNodes(renderer: Renderer, parent: any, nodes: any[], targetStatements: any[]) {
+    renderer.projectNodes(parent, flattenNestedViewRenderNodes(nodes));
+  }
+
+  createViewFactory(asts: TemplateAst[], embeddedTemplateIndex: number,
+                    targetStatements: any[]): Function {
+    var compileProtoView = this.protoViews[embeddedTemplateIndex];
+    var isComponentView = compileProtoView.protoView.type === ViewType.COMPONENT;
+    var renderComponentType = null;
+    return (parentRenderer: ParentRenderer, viewManager: AppViewManager_, containerEl: AppElement,
+            projectableNodes: any[][], rootSelector: string = null,
+            dynamicallyCreatedProviders: ResolvedProvider[] = null,
+            rootInjector: Injector = null) => {
+      checkSlotCount(this.component.type.name, this.component.template.ngContentSelectors.length,
+                     projectableNodes);
+      var renderer;
+      if (embeddedTemplateIndex === 0) {
+        if (isBlank(renderComponentType)) {
+          renderComponentType = viewManager.createRenderComponentType(
+              this.component.template.encapsulation, this.styles);
+        }
+        renderer = parentRenderer.renderComponent(renderComponentType);
+      } else {
+        renderer = <Renderer>parentRenderer;
+      }
+      var changeDetector = this.changeDetectorFactories[embeddedTemplateIndex]();
+      var view =
+          new AppView(compileProtoView.protoView, renderer, viewManager, projectableNodes,
+                      containerEl, dynamicallyCreatedProviders, rootInjector, changeDetector);
+      var visitor = new ViewBuilderVisitor<any, any>(
+          renderer, viewManager, projectableNodes, rootSelector, view, compileProtoView, [], this);
+      var parentRenderNode =
+          isComponentView ? renderer.createViewRoot(containerEl.nativeElement) : null;
+      templateVisitAll(visitor, asts, new ParentElement(parentRenderNode, null, null));
+      view.init(flattenArray(visitor.rootNodesOrAppElements, []), visitor.renderNodes,
+                visitor.appDisposables, visitor.appElements);
+      return view;
+    };
+  }
+}
+
+class ParentElement<EXPRESSION> {
+  public contentNodesByNgContentIndex: Array<EXPRESSION>[];
+
+  constructor(public renderNode: EXPRESSION, public appEl: EXPRESSION,
+              public component: CompileDirectiveMetadata) {
+    if (isPresent(component)) {
+      this.contentNodesByNgContentIndex =
+          ListWrapper.createFixedSize(component.template.ngContentSelectors.length);
+      for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
+        this.contentNodesByNgContentIndex[i] = [];
+      }
+    } else {
+      this.contentNodesByNgContentIndex = null;
+    }
+  }
+
+  addContentNode(ngContentIndex: number, nodeExpr: EXPRESSION) {
+    this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
+  }
+}
+
+class ViewBuilderVisitor<EXPRESSION, STATEMENT> implements TemplateAstVisitor {
+  renderStmts: Array<STATEMENT> = [];
+  renderNodes: EXPRESSION[] = [];
+  appStmts: Array<STATEMENT> = [];
+  appElements: EXPRESSION[] = [];
+  appDisposables: EXPRESSION[] = [];
+
+  rootNodesOrAppElements: EXPRESSION[] = [];
+
+  elementCount: number = 0;
+
+  constructor(public renderer: EXPRESSION, public viewManager: EXPRESSION,
+              public projectableNodes: EXPRESSION, public rootSelector: EXPRESSION,
+              public view: EXPRESSION, public protoView: CompileProtoView<EXPRESSION, EXPRESSION>,
+              public targetStatements: STATEMENT[],
+              public factory: ViewFactory<EXPRESSION, STATEMENT>) {}
+
+  private _addRenderNode(renderNode: EXPRESSION, appEl: EXPRESSION, ngContentIndex: number,
+                         parent: ParentElement<EXPRESSION>) {
+    this.renderNodes.push(renderNode);
+    if (isPresent(parent.component)) {
+      if (isPresent(ngContentIndex)) {
+        parent.addContentNode(ngContentIndex, isPresent(appEl) ? appEl : renderNode);
+      }
+    } else if (isBlank(parent.renderNode)) {
+      this.rootNodesOrAppElements.push(isPresent(appEl) ? appEl : renderNode);
+    }
+  }
+
+  private _getParentRenderNode(ngContentIndex: number,
+                               parent: ParentElement<EXPRESSION>): EXPRESSION {
+    return isPresent(parent.component) &&
+                   parent.component.template.encapsulation !== ViewEncapsulation.Native ?
+               null :
+               parent.renderNode;
+  }
+
+  visitBoundText(ast: BoundTextAst, parent: ParentElement<EXPRESSION>): any {
+    return this._visitText('', ast.ngContentIndex, parent);
+  }
+  visitText(ast: TextAst, parent: ParentElement<EXPRESSION>): any {
+    return this._visitText(ast.value, ast.ngContentIndex, parent);
+  }
+  private _visitText(value: string, ngContentIndex: number, parent: ParentElement<EXPRESSION>) {
+    var renderNode = this.factory.createText(
+        this.renderer, this._getParentRenderNode(ngContentIndex, parent), value, this.renderStmts);
+    this._addRenderNode(renderNode, null, ngContentIndex, parent);
+    return null;
+  }
+
+  visitNgContent(ast: NgContentAst, parent: ParentElement<EXPRESSION>): any {
+    var nodesExpression = this.factory.getProjectedNodes(this.projectableNodes, ast.index);
+    if (isPresent(parent.component)) {
+      if (isPresent(ast.ngContentIndex)) {
+        parent.addContentNode(ast.ngContentIndex, nodesExpression);
+      }
+    } else {
+      if (isPresent(parent.renderNode)) {
+        this.factory.appendProjectedNodes(this.renderer, parent.renderNode, nodesExpression,
+                                          this.renderStmts);
+      } else {
+        this.rootNodesOrAppElements.push(nodesExpression);
+      }
+    }
+    return null;
+  }
+
+  visitElement(ast: ElementAst, parent: ParentElement<EXPRESSION>): any {
+    var renderNode = this.factory.createElement(
+        this.renderer, this._getParentRenderNode(ast.ngContentIndex, parent), ast.name,
+        this.rootSelector, this.renderStmts);
+
+    var component = ast.getComponent();
+    var elementIndex = this.elementCount++;
+    var protoEl = this.protoView.protoElements[elementIndex];
+
+    protoEl.renderEvents.forEach((eventAst) => {
+      if (isPresent(eventAst.target)) {
+        var disposable = this.factory.createGlobalEventListener(
+            this.renderer, this.view, protoEl.boundElementIndex, eventAst, this.renderStmts);
+        this.appDisposables.push(disposable);
+      } else {
+        this.factory.createElementEventListener(this.renderer, this.view, protoEl.boundElementIndex,
+                                                renderNode, eventAst, this.renderStmts);
+      }
+    });
+    for (var i = 0; i < protoEl.attrNameAndValues.length; i++) {
+      var attrName = protoEl.attrNameAndValues[i][0];
+      var attrValue = protoEl.attrNameAndValues[i][1];
+      this.factory.setElementAttribute(this.renderer, renderNode, attrName, attrValue,
+                                       this.renderStmts);
+    }
+    var appEl = null;
+    if (isPresent(protoEl.appProtoEl)) {
+      appEl = this.factory.createAppElement(protoEl.appProtoEl, this.view, renderNode, parent.appEl,
+                                            null, this.appStmts);
+      this.appElements.push(appEl);
+    }
+    this._addRenderNode(renderNode, appEl, ast.ngContentIndex, parent);
+
+    var newParent = new ParentElement<EXPRESSION>(
+        renderNode, isPresent(appEl) ? appEl : parent.appEl, component);
+    templateVisitAll(this, ast.children, newParent);
+    if (isPresent(appEl) && isPresent(component)) {
+      this.factory.createAndSetComponentView(this.renderer, this.viewManager, this.view, appEl,
+                                             component, newParent.contentNodesByNgContentIndex,
+                                             this.appStmts);
+    }
+    return null;
+  }
+
+  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, parent: ParentElement<EXPRESSION>): any {
+    var renderNode = this.factory.createTemplateAnchor(
+        this.renderer, this._getParentRenderNode(ast.ngContentIndex, parent), this.renderStmts);
+
+    var elementIndex = this.elementCount++;
+    var protoEl = this.protoView.protoElements[elementIndex];
+    var embeddedViewFactory = this.factory.createViewFactory(
+        ast.children, protoEl.embeddedTemplateIndex, this.targetStatements);
+
+    var appEl = this.factory.createAppElement(protoEl.appProtoEl, this.view, renderNode,
+                                              parent.appEl, embeddedViewFactory, this.appStmts);
+    this._addRenderNode(renderNode, appEl, ast.ngContentIndex, parent);
+    this.appElements.push(appEl);
+    return null;
+  }
+
+  visitVariable(ast: VariableAst, ctx: any): any { return null; }
+  visitAttr(ast: AttrAst, ctx: any): any { return null; }
+  visitDirective(ast: DirectiveAst, ctx: any): any { return null; }
+  visitEvent(ast: BoundEventAst, ctx: any): any { return null; }
+  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any { return null; }
+  visitElementProperty(ast: BoundElementPropertyAst, context: any): any { return null; }
+}
+
+
+function codeGenEventHandler(view: Expression, boundElementIndex: number,
+                             eventName: string): string {
+  return codeGenValueFn(
+      ['event'],
+      `${view.expression}.triggerEventHandlers(${escapeValue(eventName)}, event, ${boundElementIndex})`);
+}
+
+function codeGenViewFactoryName(component: CompileDirectiveMetadata,
+                                embeddedTemplateIndex: number): string {
+  return `viewFactory_${component.type.name}${embeddedTemplateIndex}`;
+}
+
+function codeGenViewEncapsulation(value: ViewEncapsulation): string {
+  if (IS_DART) {
+    return `${METADATA_MODULE_REF}${value}`;
+  } else {
+    return `${value}`;
+  }
+}
diff --git a/modules/angular2/src/core/application_common_providers.ts b/modules/angular2/src/core/application_common_providers.ts
index b0aa60b..bb75bf5 100644
--- a/modules/angular2/src/core/application_common_providers.ts
+++ b/modules/angular2/src/core/application_common_providers.ts
@@ -11,13 +11,11 @@ import {
   KeyValueDiffers,
   defaultKeyValueDiffers
 } from './change_detection/change_detection';
-import {AppViewPool, APP_VIEW_POOL_CAPACITY} from './linker/view_pool';
+import {ResolvedMetadataCache} from 'angular2/src/core/linker/resolved_metadata_cache';
 import {AppViewManager} from './linker/view_manager';
 import {AppViewManager_} from "./linker/view_manager";
-import {AppViewManagerUtils} from './linker/view_manager_utils';
 import {ViewResolver} from './linker/view_resolver';
 import {AppViewListener} from './linker/view_listener';
-import {ProtoViewFactory} from './linker/proto_view_factory';
 import {DirectiveResolver} from './linker/directive_resolver';
 import {PipeResolver} from './linker/pipe_resolver';
 import {Compiler} from './linker/compiler';
@@ -32,12 +30,9 @@ import {DynamicComponentLoader_} from "./linker/dynamic_component_loader";
 export const APPLICATION_COMMON_PROVIDERS: Array<Type | Provider | any[]> = CONST_EXPR([
   new Provider(Compiler, {useClass: Compiler_}),
   APP_ID_RANDOM_PROVIDER,
-  AppViewPool,
-  new Provider(APP_VIEW_POOL_CAPACITY, {useValue: 10000}),
+  ResolvedMetadataCache,
   new Provider(AppViewManager, {useClass: AppViewManager_}),
-  AppViewManagerUtils,
   AppViewListener,
-  ProtoViewFactory,
   ViewResolver,
   new Provider(IterableDiffers, {useValue: defaultIterableDiffers}),
   new Provider(KeyValueDiffers, {useValue: defaultKeyValueDiffers}),
diff --git a/modules/angular2/src/core/application_ref.ts b/modules/angular2/src/core/application_ref.ts
index 426c568..d4d799b 100644
--- a/modules/angular2/src/core/application_ref.ts
+++ b/modules/angular2/src/core/application_ref.ts
@@ -33,11 +33,11 @@ import {
   ExceptionHandler,
   unimplemented
 } from 'angular2/src/facade/exceptions';
-import {internalView} from 'angular2/src/core/linker/view_ref';
 import {Console} from 'angular2/src/core/console';
 import {wtfLeave, wtfCreateScope, WtfScopeFn} from './profile/profile';
 import {ChangeDetectorRef} from 'angular2/src/core/change_detection/change_detector_ref';
 import {lockMode} from 'angular2/src/facade/lang';
+import {ElementRef_} from 'angular2/src/core/linker/element_ref';
 
 /**
  * Construct providers specific to an individual root component.
@@ -56,10 +56,10 @@ function _componentProviders(appComponentType: Type): Array<Type | Provider | an
                                                          () => { appRef._unloadComponent(ref); })
                     .then((componentRef) => {
                       ref = componentRef;
-                      if (isPresent(componentRef.location.nativeElement)) {
+                      var testability = injector.getOptional(Testability);
+                      if (isPresent(testability)) {
                         injector.get(TestabilityRegistry)
-                            .registerApplication(componentRef.location.nativeElement,
-                                                 injector.get(Testability));
+                            .registerApplication(componentRef.location.nativeElement, testability);
                       }
                       return componentRef;
                     });
@@ -439,7 +439,7 @@ export class ApplicationRef_ extends ApplicationRef {
 
   /** @internal */
   _loadComponent(ref): void {
-    var appChangeDetector = internalView(ref.hostView).changeDetector;
+    var appChangeDetector = (<ElementRef_>ref.location).internalElement.parentView.changeDetector;
     this._changeDetectorRefs.push(appChangeDetector.ref);
     this.tick();
     this._rootComponents.push(ref);
@@ -451,7 +451,8 @@ export class ApplicationRef_ extends ApplicationRef {
     if (!ListWrapper.contains(this._rootComponents, ref)) {
       return;
     }
-    this.unregisterChangeDetector(internalView(ref.hostView).changeDetector.ref);
+    this.unregisterChangeDetector(
+        (<ElementRef_>ref.location).internalElement.parentView.changeDetector.ref);
     ListWrapper.remove(this._rootComponents, ref);
   }
 
diff --git a/modules/angular2/src/core/change_detection/abstract_change_detector.ts b/modules/angular2/src/core/change_detection/abstract_change_detector.ts
index 4a1ced9..e3ec39c 100644
--- a/modules/angular2/src/core/change_detection/abstract_change_detector.ts
+++ b/modules/angular2/src/core/change_detection/abstract_change_detector.ts
@@ -8,7 +8,9 @@ import {Pipes} from './pipes';
 import {
   ChangeDetectionError,
   ExpressionChangedAfterItHasBeenCheckedException,
-  DehydratedException
+  DehydratedException,
+  EventEvaluationErrorContext,
+  EventEvaluationError
 } from './exceptions';
 import {BindingTarget} from './binding_record';
 import {Locals} from './parser/locals';
@@ -43,9 +45,12 @@ export class AbstractChangeDetector<T> implements ChangeDetector {
   subscriptions: any[];
   streams: any[];
 
-  constructor(public id: string, public dispatcher: ChangeDispatcher,
-              public numberOfPropertyProtoRecords: number, public bindingTargets: BindingTarget[],
-              public directiveIndices: DirectiveIndex[], public strategy: ChangeDetectionStrategy) {
+  dispatcher: ChangeDispatcher;
+
+
+  constructor(public id: string, public numberOfPropertyProtoRecords: number,
+              public bindingTargets: BindingTarget[], public directiveIndices: DirectiveIndex[],
+              public strategy: ChangeDetectionStrategy) {
     this.ref = new ChangeDetectorRef_(this);
   }
 
@@ -65,10 +70,24 @@ export class AbstractChangeDetector<T> implements ChangeDetector {
 
   remove(): void { this.parent.removeContentChild(this); }
 
-  handleEvent(eventName: string, elIndex: number, locals: Locals): boolean {
-    var res = this.handleEventInternal(eventName, elIndex, locals);
-    this.markPathToRootAsCheckOnce();
-    return res;
+  handleEvent(eventName: string, elIndex: number, event: any): boolean {
+    if (!this.hydrated()) {
+      return true;
+    }
+    try {
+      var locals = new Map<string, any>();
+      locals.set('$event', event);
+      var res = !this.handleEventInternal(eventName, elIndex, new Locals(this.locals, locals));
+      this.markPathToRootAsCheckOnce();
+      return res;
+    } catch (e) {
+      var c = this.dispatcher.getDebugContext(null, elIndex, null);
+      var context = isPresent(c) ?
+                        new EventEvaluationErrorContext(c.element, c.componentElement, c.context,
+                                                        c.locals, c.injector) :
+                        null;
+      throw new EventEvaluationError(eventName, e, e.stack, context);
+    }
   }
 
   handleEventInternal(eventName: string, elIndex: number, locals: Locals): boolean { return false; }
@@ -133,7 +152,8 @@ export class AbstractChangeDetector<T> implements ChangeDetector {
 
   // This method is not intended to be overridden. Subclasses should instead provide an
   // implementation of `hydrateDirectives`.
-  hydrate(context: T, locals: Locals, directives: any, pipes: Pipes): void {
+  hydrate(context: T, locals: Locals, dispatcher: ChangeDispatcher, pipes: Pipes): void {
+    this.dispatcher = dispatcher;
     this.mode = ChangeDetectionUtil.changeDetectionMode(this.strategy);
     this.context = context;
 
@@ -143,12 +163,12 @@ export class AbstractChangeDetector<T> implements ChangeDetector {
 
     this.locals = locals;
     this.pipes = pipes;
-    this.hydrateDirectives(directives);
+    this.hydrateDirectives(dispatcher);
     this.state = ChangeDetectorState.NeverChecked;
   }
 
   // Subclasses should override this method to hydrate any directives.
-  hydrateDirectives(directives: any): void {}
+  hydrateDirectives(dispatcher: ChangeDispatcher): void {}
 
   // This method is not intended to be overridden. Subclasses should instead provide an
   // implementation of `dehydrateDirectives`.
@@ -160,6 +180,7 @@ export class AbstractChangeDetector<T> implements ChangeDetector {
       this._unsubsribeFromObservables();
     }
 
+    this.dispatcher = null;
     this.context = null;
     this.locals = null;
     this.pipes = null;
@@ -171,6 +192,19 @@ export class AbstractChangeDetector<T> implements ChangeDetector {
 
   hydrated(): boolean { return isPresent(this.context); }
 
+  destroyRecursive(): void {
+    this.dispatcher.notifyOnDestroy();
+    this.dehydrate();
+    var children = this.contentChildren;
+    for (var i = 0; i < children.length; i++) {
+      children[i].destroyRecursive();
+    }
+    children = this.viewChildren;
+    for (var i = 0; i < children.length; i++) {
+      children[i].destroyRecursive();
+    }
+  }
+
   afterContentLifecycleCallbacks(): void {
     this.dispatcher.notifyAfterContentChecked();
     this.afterContentLifecycleCallbacksInternal();
@@ -298,7 +332,7 @@ export class AbstractChangeDetector<T> implements ChangeDetector {
   private _throwError(exception: any, stack: any): void {
     var error;
     try {
-      var c = this.dispatcher.getDebugContext(this._currentBinding().elementIndex, null);
+      var c = this.dispatcher.getDebugContext(null, this._currentBinding().elementIndex, null);
       var context = isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals,
                                                 c.injector, this._currentBinding().debug) :
                                    null;
diff --git a/modules/angular2/src/core/change_detection/change_detection_jit_generator.ts b/modules/angular2/src/core/change_detection/change_detection_jit_generator.ts
index 14c9caf..98615d9 100644
--- a/modules/angular2/src/core/change_detection/change_detection_jit_generator.ts
+++ b/modules/angular2/src/core/change_detection/change_detection_jit_generator.ts
@@ -66,8 +66,8 @@ export class ChangeDetectorJITGenerator {
   generate(): Function {
     var factorySource = `
       ${this.generateSource()}
-      return function(dispatcher) {
-        return new ${this.typeName}(dispatcher);
+      return function() {
+        return new ${this.typeName}();
       }
     `;
     return new Function(this.abstractChangeDetectorVarName, this.changeDetectionUtilVarName,
@@ -77,9 +77,9 @@ export class ChangeDetectorJITGenerator {
 
   generateSource(): string {
     return `
-      var ${this.typeName} = function ${this.typeName}(dispatcher) {
+      var ${this.typeName} = function ${this.typeName}() {
         ${this.abstractChangeDetectorVarName}.call(
-            this, ${JSON.stringify(this.id)}, dispatcher, ${this.records.length},
+            this, ${JSON.stringify(this.id)}, ${this.records.length},
             ${this.typeName}.gen_propertyBindingTargets, ${this.typeName}.gen_directiveIndices,
             ${codify(this.changeDetectionStrategy)});
         this.dehydrateDirectives(false);
@@ -199,13 +199,14 @@ export class ChangeDetectorJITGenerator {
   /** @internal */
   _maybeGenDehydrateDirectives(): string {
     var destroyPipesCode = this._names.genPipeOnDestroy();
-    if (destroyPipesCode) {
-      destroyPipesCode = `if (destroyPipes) { ${destroyPipesCode} }`;
-    }
+    var destroyDirectivesCode = this._logic.genDirectivesOnDestroy(this.directiveRecords);
     var dehydrateFieldsCode = this._names.genDehydrateFields();
-    if (!destroyPipesCode && !dehydrateFieldsCode) return '';
+    if (!destroyPipesCode && !destroyDirectivesCode && !dehydrateFieldsCode) return '';
     return `${this.typeName}.prototype.dehydrateDirectives = function(destroyPipes) {
-        ${destroyPipesCode}
+        if (destroyPipes) {
+          ${destroyPipesCode}
+          ${destroyDirectivesCode}
+        }
         ${dehydrateFieldsCode}
     }`;
   }
diff --git a/modules/angular2/src/core/change_detection/change_detector_ref.ts b/modules/angular2/src/core/change_detection/change_detector_ref.ts
index e128dca..e34fe44 100644
--- a/modules/angular2/src/core/change_detection/change_detector_ref.ts
+++ b/modules/angular2/src/core/change_detection/change_detector_ref.ts
@@ -205,4 +205,4 @@ export class ChangeDetectorRef_ extends ChangeDetectorRef {
     this._cd.mode = ChangeDetectionStrategy.CheckAlways;
     this.markForCheck();
   }
-}
+}
\ No newline at end of file
diff --git a/modules/angular2/src/core/change_detection/codegen_logic_util.ts b/modules/angular2/src/core/change_detection/codegen_logic_util.ts
index 2c2e2ab..17cf95c 100644
--- a/modules/angular2/src/core/change_detection/codegen_logic_util.ts
+++ b/modules/angular2/src/core/change_detection/codegen_logic_util.ts
@@ -155,17 +155,49 @@ export class CodegenLogicUtil {
     var res = [];
     for (var i = 0; i < directiveRecords.length; ++i) {
       var r = directiveRecords[i];
-      res.push(`${this._names.getDirectiveName(r.directiveIndex)} = ${this._genReadDirective(i)};`);
+      var dirVarName = this._names.getDirectiveName(r.directiveIndex);
+      res.push(`${dirVarName} = ${this._genReadDirective(i)};`);
+      if (isPresent(r.outputs)) {
+        r.outputs.forEach(output => {
+          var eventHandlerExpr = this._genEventHandler(r.directiveIndex.elementIndex, output[1]);
+          if (IS_DART) {
+            res.push(`${dirVarName}.${output[0]}.listen(${eventHandlerExpr});`);
+          } else {
+            res.push(`${dirVarName}.${output[0]}.subscribe({next: ${eventHandlerExpr}});`);
+          }
+        });
+      }
     }
     return res.join("\n");
   }
 
+  genDirectivesOnDestroy(directiveRecords: DirectiveRecord[]): string {
+    var res = [];
+    for (var i = 0; i < directiveRecords.length; ++i) {
+      var r = directiveRecords[i];
+      if (r.callOnDestroy) {
+        var dirVarName = this._names.getDirectiveName(r.directiveIndex);
+        res.push(`${dirVarName}.ngOnDestroy();`);
+      }
+    }
+    return res.join("\n");
+  }
+
+  private _genEventHandler(boundElementIndex: number, eventName: string): string {
+    if (IS_DART) {
+      return `(event) => this.handleEvent('${eventName}', ${boundElementIndex}, event)`;
+    } else {
+      return `(function(event) { return this.handleEvent('${eventName}', ${boundElementIndex}, event); }).bind(this)`;
+    }
+  }
+
   private _genReadDirective(index: number) {
+    var directiveExpr = `this.getDirectiveFor(directives, ${index})`;
     // This is an experimental feature. Works only in Dart.
     if (this._changeDetection === ChangeDetectionStrategy.OnPushObserve) {
-      return `this.observeDirective(this.getDirectiveFor(directives, ${index}), ${index})`;
+      return `this.observeDirective(${directiveExpr}, ${index})`;
     } else {
-      return `this.getDirectiveFor(directives, ${index})`;
+      return directiveExpr;
     }
   }
 
diff --git a/modules/angular2/src/core/change_detection/directive_record.ts b/modules/angular2/src/core/change_detection/directive_record.ts
index 967034f..53c6f2e 100644
--- a/modules/angular2/src/core/change_detection/directive_record.ts
+++ b/modules/angular2/src/core/change_detection/directive_record.ts
@@ -16,10 +16,14 @@ export class DirectiveRecord {
   callOnChanges: boolean;
   callDoCheck: boolean;
   callOnInit: boolean;
+  callOnDestroy: boolean;
   changeDetection: ChangeDetectionStrategy;
+  // array of [emitter property name, eventName]
+  outputs: string[][];
 
   constructor({directiveIndex, callAfterContentInit, callAfterContentChecked, callAfterViewInit,
-               callAfterViewChecked, callOnChanges, callDoCheck, callOnInit, changeDetection}: {
+               callAfterViewChecked, callOnChanges, callDoCheck, callOnInit, callOnDestroy,
+               changeDetection, outputs}: {
     directiveIndex?: DirectiveIndex,
     callAfterContentInit?: boolean,
     callAfterContentChecked?: boolean,
@@ -28,7 +32,9 @@ export class DirectiveRecord {
     callOnChanges?: boolean,
     callDoCheck?: boolean,
     callOnInit?: boolean,
-    changeDetection?: ChangeDetectionStrategy
+    callOnDestroy?: boolean,
+    changeDetection?: ChangeDetectionStrategy,
+    outputs?: string[][]
   } = {}) {
     this.directiveIndex = directiveIndex;
     this.callAfterContentInit = normalizeBool(callAfterContentInit);
@@ -38,7 +44,9 @@ export class DirectiveRecord {
     this.callAfterViewChecked = normalizeBool(callAfterViewChecked);
     this.callDoCheck = normalizeBool(callDoCheck);
     this.callOnInit = normalizeBool(callOnInit);
+    this.callOnDestroy = normalizeBool(callOnDestroy);
     this.changeDetection = changeDetection;
+    this.outputs = outputs;
   }
 
   isDefaultChangeDetection(): boolean {
diff --git a/modules/angular2/src/core/change_detection/dynamic_change_detector.ts b/modules/angular2/src/core/change_detection/dynamic_change_detector.ts
index 344b71f..0b07abe 100644
--- a/modules/angular2/src/core/change_detection/dynamic_change_detector.ts
+++ b/modules/angular2/src/core/change_detection/dynamic_change_detector.ts
@@ -11,21 +11,21 @@ import {ChangeDispatcher, ChangeDetectorGenConfig} from './interfaces';
 import {ChangeDetectionUtil, SimpleChange} from './change_detection_util';
 import {ChangeDetectionStrategy, ChangeDetectorState} from './constants';
 import {ProtoRecord, RecordType} from './proto_record';
+import {reflector} from 'angular2/src/core/reflection/reflection';
+import {ObservableWrapper} from 'angular2/src/facade/async';
 
 export class DynamicChangeDetector extends AbstractChangeDetector<any> {
   values: any[];
   changes: any[];
   localPipes: any[];
   prevContexts: any[];
-  directives: any = null;
 
-  constructor(id: string, dispatcher: ChangeDispatcher, numberOfPropertyProtoRecords: number,
+  constructor(id: string, numberOfPropertyProtoRecords: number,
               propertyBindingTargets: BindingTarget[], directiveIndices: DirectiveIndex[],
               strategy: ChangeDetectionStrategy, private _records: ProtoRecord[],
               private _eventBindings: EventBinding[], private _directiveRecords: DirectiveRecord[],
               private _genConfig: ChangeDetectorGenConfig) {
-    super(id, dispatcher, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices,
-          strategy);
+    super(id, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy);
     var len = _records.length + 1;
     this.values = ListWrapper.createFixedSize(len);
     this.localPipes = ListWrapper.createFixedSize(len);
@@ -104,24 +104,41 @@ export class DynamicChangeDetector extends AbstractChangeDetector<any> {
     return this._eventBindings.filter(eb => eb.eventName == eventName && eb.elIndex === elIndex);
   }
 
-  hydrateDirectives(directives: any): void {
+  hydrateDirectives(dispatcher: ChangeDispatcher): void {
     this.values[0] = this.context;
-    this.directives = directives;
+    this.dispatcher = dispatcher;
 
     if (this.strategy === ChangeDetectionStrategy.OnPushObserve) {
       for (var i = 0; i < this.directiveIndices.length; ++i) {
         var index = this.directiveIndices[i];
-        super.observeDirective(directives.getDirectiveFor(index), i);
+        super.observeDirective(this._getDirectiveFor(index), i);
+      }
+    }
+    for (var i = 0; i < this._directiveRecords.length; ++i) {
+      var r = this._directiveRecords[i];
+      if (isPresent(r.outputs)) {
+        r.outputs.forEach(output => {
+          var eventHandler =
+              <any>this._createEventHandler(r.directiveIndex.elementIndex, output[1]);
+          var directive = this._getDirectiveFor(r.directiveIndex);
+          var getter = reflector.getter(output[0]);
+          ObservableWrapper.subscribe(getter(directive), eventHandler);
+        });
       }
     }
   }
 
+  private _createEventHandler(boundElementIndex: number, eventName: string): Function {
+    return (event) => this.handleEvent(eventName, boundElementIndex, event);
+  }
+
+
   dehydrateDirectives(destroyPipes: boolean) {
     if (destroyPipes) {
       this._destroyPipes();
+      this._destroyDirectives();
     }
     this.values[0] = null;
-    this.directives = null;
     ListWrapper.fill(this.values, ChangeDetectionUtil.uninitialized, 1);
     ListWrapper.fill(this.changes, false);
     ListWrapper.fill(this.localPipes, null);
@@ -137,6 +154,16 @@ export class DynamicChangeDetector extends AbstractChangeDetector<any> {
     }
   }
 
+  /** @internal */
+  _destroyDirectives() {
+    for (var i = 0; i < this._directiveRecords.length; ++i) {
+      var record = this._directiveRecords[i];
+      if (record.callOnDestroy) {
+        this._getDirectiveFor(record.directiveIndex).ngOnDestroy();
+      }
+    }
+  }
+
   checkNoChanges(): void { this.runDetectChanges(true); }
 
   detectChangesInRecordsInternal(throwOnChange: boolean) {
@@ -241,12 +268,14 @@ export class DynamicChangeDetector extends AbstractChangeDetector<any> {
   }
 
   /** @internal */
-  private _getDirectiveFor(directiveIndex) {
-    return this.directives.getDirectiveFor(directiveIndex);
+  private _getDirectiveFor(directiveIndex: DirectiveIndex) {
+    return this.dispatcher.getDirectiveFor(directiveIndex);
   }
 
   /** @internal */
-  private _getDetectorFor(directiveIndex) { return this.directives.getDetectorFor(directiveIndex); }
+  private _getDetectorFor(directiveIndex: DirectiveIndex) {
+    return this.dispatcher.getDetectorFor(directiveIndex);
+  }
 
   /** @internal */
   private _check(proto: ProtoRecord, throwOnChange: boolean, values: any[],
diff --git a/modules/angular2/src/core/change_detection/exceptions.ts b/modules/angular2/src/core/change_detection/exceptions.ts
index b8c7454..11d04ee 100644
--- a/modules/angular2/src/core/change_detection/exceptions.ts
+++ b/modules/angular2/src/core/change_detection/exceptions.ts
@@ -93,3 +93,20 @@ export class ChangeDetectionError extends WrappedException {
 export class DehydratedException extends BaseException {
   constructor() { super('Attempt to detect changes on a dehydrated detector.'); }
 }
+
+/**
+ * Wraps an exception thrown by an event handler.
+ */
+export class EventEvaluationError extends WrappedException {
+  constructor(eventName: string, originalException: any, originalStack: any, context: any) {
+    super(`Error during evaluation of "${eventName}"`, originalException, originalStack, context);
+  }
+}
+
+/**
+ * Error context included when an event handler throws an exception.
+ */
+export class EventEvaluationErrorContext {
+  constructor(public element: any, public componentElement: any, public context: any,
+              public locals: any, public injector: any) {}
+}
diff --git a/modules/angular2/src/core/change_detection/interfaces.ts b/modules/angular2/src/core/change_detection/interfaces.ts
index 803d962..0f3c165 100644
--- a/modules/angular2/src/core/change_detection/interfaces.ts
+++ b/modules/angular2/src/core/change_detection/interfaces.ts
@@ -1,6 +1,6 @@
 import {Locals} from './parser/locals';
 import {BindingTarget, BindingRecord} from './binding_record';
-import {DirectiveIndex, DirectiveRecord} from './directive_record';
+import {DirectiveRecord, DirectiveIndex} from './directive_record';
 import {ChangeDetectionStrategy} from './constants';
 import {ChangeDetectorRef} from './change_detector_ref';
 
@@ -10,11 +10,14 @@ export class DebugContext {
 }
 
 export interface ChangeDispatcher {
-  getDebugContext(elementIndex: number, directiveIndex: DirectiveIndex): DebugContext;
+  getDebugContext(appElement: any, elementIndex: number, directiveIndex: number): DebugContext;
   notifyOnBinding(bindingTarget: BindingTarget, value: any): void;
   logBindingUpdate(bindingTarget: BindingTarget, value: any): void;
   notifyAfterContentChecked(): void;
   notifyAfterViewChecked(): void;
+  notifyOnDestroy(): void;
+  getDetectorFor(directiveIndex: DirectiveIndex): ChangeDetector;
+  getDirectiveFor(directiveIndex: DirectiveIndex): any;
 }
 
 export interface ChangeDetector {
@@ -27,16 +30,18 @@ export interface ChangeDetector {
   removeContentChild(cd: ChangeDetector): void;
   removeViewChild(cd: ChangeDetector): void;
   remove(): void;
-  hydrate(context: any, locals: Locals, directives: any, pipes: any): void;
+  hydrate(context: any, locals: Locals, dispatcher: ChangeDispatcher, pipes: any): void;
   dehydrate(): void;
   markPathToRootAsCheckOnce(): void;
 
-  handleEvent(eventName: string, elIndex: number, locals: Locals);
+  handleEvent(eventName: string, elIndex: number, event: any);
   detectChanges(): void;
   checkNoChanges(): void;
+  destroyRecursive(): void;
+  markAsCheckOnce(): void;
 }
 
-export interface ProtoChangeDetector { instantiate(dispatcher: ChangeDispatcher): ChangeDetector; }
+export interface ProtoChangeDetector { instantiate(): ChangeDetector; }
 
 export class ChangeDetectorGenConfig {
   constructor(public genDebugInfo: boolean, public logBindingUpdate: boolean,
diff --git a/modules/angular2/src/core/change_detection/jit_proto_change_detector.dart b/modules/angular2/src/core/change_detection/jit_proto_change_detector.dart
index 46a3251..5fb02a8 100644
--- a/modules/angular2/src/core/change_detection/jit_proto_change_detector.dart
+++ b/modules/angular2/src/core/change_detection/jit_proto_change_detector.dart
@@ -3,11 +3,11 @@ library change_detection.jit_proto_change_detector;
 import 'interfaces.dart' show ChangeDetector, ProtoChangeDetector;
 
 class JitProtoChangeDetector implements ProtoChangeDetector {
-  JitProtoChangeDetector(definition) : super();
+  JitProtoChangeDetector(definition);
 
   static bool isSupported() => false;
 
-  ChangeDetector instantiate(dispatcher) {
+  ChangeDetector instantiate() {
     throw "Jit Change Detection not supported in Dart";
   }
 }
diff --git a/modules/angular2/src/core/change_detection/jit_proto_change_detector.ts b/modules/angular2/src/core/change_detection/jit_proto_change_detector.ts
index 3d4636e..bd747c4 100644
--- a/modules/angular2/src/core/change_detection/jit_proto_change_detector.ts
+++ b/modules/angular2/src/core/change_detection/jit_proto_change_detector.ts
@@ -14,7 +14,7 @@ export class JitProtoChangeDetector implements ProtoChangeDetector {
 
   static isSupported(): boolean { return true; }
 
-  instantiate(dispatcher: any): ChangeDetector { return this._factory(dispatcher); }
+  instantiate(): ChangeDetector { return this._factory(); }
 
   /** @internal */
   _createFactory(definition: ChangeDetectorDefinition) {
diff --git a/modules/angular2/src/core/change_detection/parser/locals.ts b/modules/angular2/src/core/change_detection/parser/locals.ts
index 92b1aaa..fb7fbd2 100644
--- a/modules/angular2/src/core/change_detection/parser/locals.ts
+++ b/modules/angular2/src/core/change_detection/parser/locals.ts
@@ -41,5 +41,5 @@ export class Locals {
     }
   }
 
-  clearValues(): void { MapWrapper.clearValues(this.current); }
+  clearLocalValues(): void { MapWrapper.clearValues(this.current); }
 }
diff --git a/modules/angular2/src/core/change_detection/pregen_proto_change_detector.dart b/modules/angular2/src/core/change_detection/pregen_proto_change_detector.dart
index bf95c75..301801d 100644
--- a/modules/angular2/src/core/change_detection/pregen_proto_change_detector.dart
+++ b/modules/angular2/src/core/change_detection/pregen_proto_change_detector.dart
@@ -1,8 +1,5 @@
 library angular2.src.change_detection.pregen_proto_change_detector;
 
-import 'package:angular2/src/core/change_detection/interfaces.dart';
-import 'package:angular2/src/facade/lang.dart' show looseIdentical;
-
 export 'dart:core' show List;
 export 'package:angular2/src/core/change_detection/abstract_change_detector.dart'
     show AbstractChangeDetector;
@@ -20,34 +17,3 @@ export 'package:angular2/src/core/change_detection/proto_record.dart'
 export 'package:angular2/src/core/change_detection/change_detection_util.dart'
     show ChangeDetectionUtil;
 export 'package:angular2/src/facade/lang.dart' show assertionsEnabled, looseIdentical;
-
-typedef ProtoChangeDetector PregenProtoChangeDetectorFactory(
-    ChangeDetectorDefinition definition);
-
-typedef ChangeDetector InstantiateMethod(dynamic dispatcher);
-
-/// Implementation of [ProtoChangeDetector] for use by pre-generated change
-/// detectors in Angular 2 Dart.
-/// Classes generated by the `TemplateCompiler` use this. The `export`s above
-/// allow the generated code to `import` a single library and get all
-/// dependencies.
-class PregenProtoChangeDetector extends ProtoChangeDetector {
-  /// The [ChangeDetectorDefinition#id]. Strictly informational.
-  final String id;
-
-  /// Closure used to generate an actual [ChangeDetector].
-  final InstantiateMethod _instantiateMethod;
-
-  /// Internal ctor.
-  PregenProtoChangeDetector._(this.id, this._instantiateMethod);
-
-  static bool isSupported() => true;
-
-  factory PregenProtoChangeDetector(
-      InstantiateMethod instantiateMethod, ChangeDetectorDefinition def) {
-    return new PregenProtoChangeDetector._(def.id, instantiateMethod);
-  }
-
-  @override
-  instantiate(dynamic dispatcher) => _instantiateMethod(dispatcher);
-}
diff --git a/modules/angular2/src/core/change_detection/pregen_proto_change_detector.ts b/modules/angular2/src/core/change_detection/pregen_proto_change_detector.ts
index 5ef1ead..da60b22 100644
--- a/modules/angular2/src/core/change_detection/pregen_proto_change_detector.ts
+++ b/modules/angular2/src/core/change_detection/pregen_proto_change_detector.ts
@@ -1,14 +1 @@
-import {BaseException} from 'angular2/src/facade/exceptions';
-
-import {ProtoChangeDetector, ChangeDetector} from './interfaces';
-import {coalesce} from './coalesce';
-
-export {Function as PregenProtoChangeDetectorFactory};
-
-export class PregenProtoChangeDetector implements ProtoChangeDetector {
-  static isSupported(): boolean { return false; }
-
-  instantiate(dispatcher: any): ChangeDetector {
-    throw new BaseException('Pregen change detection not supported in Js');
-  }
-}
+// empty file as we only need the dart version
\ No newline at end of file
diff --git a/modules/angular2/src/core/change_detection/proto_change_detector.ts b/modules/angular2/src/core/change_detection/proto_change_detector.ts
index c25cc54..ee0016a 100644
--- a/modules/angular2/src/core/change_detection/proto_change_detector.ts
+++ b/modules/angular2/src/core/change_detection/proto_change_detector.ts
@@ -54,12 +54,11 @@ export class DynamicProtoChangeDetector implements ProtoChangeDetector {
     this._directiveIndices = this._definition.directiveRecords.map(d => d.directiveIndex);
   }
 
-  instantiate(dispatcher: any): ChangeDetector {
+  instantiate(): ChangeDetector {
     return new DynamicChangeDetector(
-        this._definition.id, dispatcher, this._propertyBindingRecords.length,
-        this._propertyBindingTargets, this._directiveIndices, this._definition.strategy,
-        this._propertyBindingRecords, this._eventBindingRecords, this._definition.directiveRecords,
-        this._definition.genConfig);
+        this._definition.id, this._propertyBindingRecords.length, this._propertyBindingTargets,
+        this._directiveIndices, this._definition.strategy, this._propertyBindingRecords,
+        this._eventBindingRecords, this._definition.directiveRecords, this._definition.genConfig);
   }
 }
 
diff --git a/modules/angular2/src/core/debug/debug_element.ts b/modules/angular2/src/core/debug/debug_element.ts
index c26acb8..88b1962 100644
--- a/modules/angular2/src/core/debug/debug_element.ts
+++ b/modules/angular2/src/core/debug/debug_element.ts
@@ -1,9 +1,9 @@
 import {Type, isPresent, isBlank} from 'angular2/src/facade/lang';
 import {ListWrapper, MapWrapper, Predicate} from 'angular2/src/facade/collection';
 import {unimplemented} from 'angular2/src/facade/exceptions';
-import {ElementInjector} from 'angular2/src/core/linker/element_injector';
-import {AppView, ViewType} from 'angular2/src/core/linker/view';
-import {internalView} from 'angular2/src/core/linker/view_ref';
+
+import {AppElement} from 'angular2/src/core/linker/element';
+import {AppView} from 'angular2/src/core/linker/view';
 import {ElementRef, ElementRef_} from 'angular2/src/core/linker/element_ref';
 
 /**
@@ -103,79 +103,68 @@ export abstract class DebugElement {
 }
 
 export class DebugElement_ extends DebugElement {
-  /** @internal */
-  _elementInjector: ElementInjector;
-
-  constructor(private _parentView: AppView, private _boundElementIndex: number) {
-    super();
-    this._elementInjector = this._parentView.elementInjectors[this._boundElementIndex];
-  }
+  constructor(private _appElement: AppElement) { super(); }
 
   get componentInstance(): any {
-    if (!isPresent(this._elementInjector)) {
+    if (!isPresent(this._appElement)) {
       return null;
     }
-    return this._elementInjector.getComponent();
+    return this._appElement.getComponent();
   }
 
   get nativeElement(): any { return this.elementRef.nativeElement; }
 
-  get elementRef(): ElementRef { return this._parentView.elementRefs[this._boundElementIndex]; }
+  get elementRef(): ElementRef { return this._appElement.ref; }
 
   getDirectiveInstance(directiveIndex: number): any {
-    return this._elementInjector.getDirectiveAtIndex(directiveIndex);
+    return this._appElement.getDirectiveAtIndex(directiveIndex);
   }
 
   get children(): DebugElement[] {
-    return this._getChildElements(this._parentView, this._boundElementIndex);
+    return this._getChildElements(this._appElement.parentView, this._appElement);
   }
 
   get componentViewChildren(): DebugElement[] {
-    var shadowView = this._parentView.getNestedView(this._boundElementIndex);
-
-    if (!isPresent(shadowView) || shadowView.proto.type !== ViewType.COMPONENT) {
+    if (!isPresent(this._appElement.componentView)) {
       // The current element is not a component.
       return [];
     }
 
-    return this._getChildElements(shadowView, null);
+    return this._getChildElements(this._appElement.componentView, null);
   }
 
   triggerEventHandler(eventName: string, eventObj: Event): void {
-    this._parentView.triggerEventHandlers(eventName, eventObj, this._boundElementIndex);
+    this._appElement.parentView.triggerEventHandlers(eventName, eventObj,
+                                                     this._appElement.proto.index);
   }
 
   hasDirective(type: Type): boolean {
-    if (!isPresent(this._elementInjector)) {
+    if (!isPresent(this._appElement)) {
       return false;
     }
-    return this._elementInjector.hasDirective(type);
+    return this._appElement.hasDirective(type);
   }
 
   inject(type: Type): any {
-    if (!isPresent(this._elementInjector)) {
+    if (!isPresent(this._appElement)) {
       return null;
     }
-    return this._elementInjector.get(type);
+    return this._appElement.get(type);
   }
 
-  getLocal(name: string): any { return this._parentView.locals.get(name); }
+  getLocal(name: string): any { return this._appElement.parentView.locals.get(name); }
 
   /** @internal */
-  _getChildElements(view: AppView, parentBoundElementIndex: number): DebugElement[] {
+  _getChildElements(view: AppView, parentAppElement: AppElement): DebugElement[] {
     var els = [];
-    var parentElementBinder = null;
-    if (isPresent(parentBoundElementIndex)) {
-      parentElementBinder = view.proto.elementBinders[parentBoundElementIndex - view.elementOffset];
-    }
-    for (var i = 0; i < view.proto.elementBinders.length; ++i) {
-      var binder = view.proto.elementBinders[i];
-      if (binder.parent == parentElementBinder) {
-        els.push(new DebugElement_(view, view.elementOffset + i));
+    for (var i = 0; i < view.appElements.length; ++i) {
+      var appEl = view.appElements[i];
+      if (appEl.parent == parentAppElement) {
+        els.push(new DebugElement_(appEl));
 
-        var views = view.viewContainers[view.elementOffset + i];
+        var views = appEl.nestedViews;
         if (isPresent(views)) {
-          views.views.forEach(
+          views.forEach(
               (nextView) => { els = els.concat(this._getChildElements(nextView, null)); });
         }
       }
@@ -191,8 +180,7 @@ export class DebugElement_ extends DebugElement {
  * @return {DebugElement}
  */
 export function inspectElement(elementRef: ElementRef): DebugElement {
-  return new DebugElement_(internalView((<ElementRef_>elementRef).parentView),
-                           (<ElementRef_>elementRef).boundElementIndex);
+  return new DebugElement_((<ElementRef_>elementRef).internalElement);
 }
 
 /**
diff --git a/modules/angular2/src/core/di/injector.ts b/modules/angular2/src/core/di/injector.ts
index 40c7e20..4d499cc 100644
--- a/modules/angular2/src/core/di/injector.ts
+++ b/modules/angular2/src/core/di/injector.ts
@@ -194,6 +194,11 @@ export class ProtoInjectorDynamicStrategy implements ProtoInjectorStrategy {
 }
 
 export class ProtoInjector {
+  static fromResolvedProviders(providers: ResolvedProvider[]): ProtoInjector {
+    var bd = providers.map(b => new ProviderWithVisibility(b, Visibility.Public));
+    return new ProtoInjector(bd);
+  }
+
   /** @internal */
   _strategy: ProtoInjectorStrategy;
   numberOfProviders: number;
@@ -215,7 +220,6 @@ export interface InjectorStrategy {
   getObjAtIndex(index: number): any;
   getMaxNumberOfObjects(): number;
 
-  attach(parent: Injector, isHost: boolean): void;
   resetConstructionCounter(): void;
   instantiateProvider(provider: ResolvedProvider, visibility: Visibility): any;
 }
@@ -240,12 +244,6 @@ export class InjectorInlineStrategy implements InjectorStrategy {
     return this.injector._new(provider, visibility);
   }
 
-  attach(parent: Injector, isHost: boolean): void {
-    var inj = this.injector;
-    inj._parent = parent;
-    inj._isHost = isHost;
-  }
-
   getObjByKeyId(keyId: number, visibility: Visibility): any {
     var p = this.protoStrategy;
     var inj = this.injector;
@@ -346,12 +344,6 @@ export class InjectorDynamicStrategy implements InjectorStrategy {
     return this.injector._new(provider, visibility);
   }
 
-  attach(parent: Injector, isHost: boolean): void {
-    var inj = this.injector;
-    inj._parent = parent;
-    inj._isHost = isHost;
-  }
-
   getObjByKeyId(keyId: number, visibility: Visibility): any {
     var p = this.protoStrategy;
 
@@ -516,9 +508,7 @@ export class Injector {
    * ```
    */
   static fromResolvedProviders(providers: ResolvedProvider[]): Injector {
-    var bd = providers.map(b => new ProviderWithVisibility(b, Visibility.Public));
-    var proto = new ProtoInjector(bd);
-    return new Injector(proto, null, null);
+    return new Injector(ProtoInjector.fromResolvedProviders(providers));
   }
 
   /**
@@ -531,8 +521,6 @@ export class Injector {
   /** @internal */
   _strategy: InjectorStrategy;
   /** @internal */
-  _isHost: boolean = false;
-  /** @internal */
   _constructionCounter: number = 0;
   /** @internal */
   public _proto: any /* ProtoInjector */;
@@ -542,6 +530,7 @@ export class Injector {
    * Private
    */
   constructor(_proto: any /* ProtoInjector */, _parent: Injector = null,
+              private _isHostBoundary: boolean = false,
               private _depProvider: any /* DependencyProvider */ = null,
               private _debugContext: Function = null) {
     this._proto = _proto;
@@ -550,6 +539,12 @@ export class Injector {
   }
 
   /**
+   * Whether this injector is a boundary to a host.
+   * @internal
+   */
+  get hostBoundary() { return this._isHostBoundary; }
+
+  /**
    * @internal
    */
   debugContext(): any { return this._debugContext(); }
@@ -692,7 +687,7 @@ export class Injector {
   createChildFromResolved(providers: ResolvedProvider[]): Injector {
     var bd = providers.map(b => new ProviderWithVisibility(b, Visibility.Public));
     var proto = new ProtoInjector(bd);
-    var inj = new Injector(proto, null, null);
+    var inj = new Injector(proto);
     inj._parent = this;
     return inj;
   }
@@ -935,7 +930,7 @@ export class Injector {
     var inj: Injector = this;
 
     if (lowerBoundVisibility instanceof SkipSelfMetadata) {
-      if (inj._isHost) {
+      if (inj._isHostBoundary) {
         return this._getPrivateDependency(key, optional, inj);
       } else {
         inj = inj._parent;
@@ -946,7 +941,7 @@ export class Injector {
       var obj = inj._strategy.getObjByKeyId(key.id, providerVisibility);
       if (obj !== UNDEFINED) return obj;
 
-      if (isPresent(inj._parent) && inj._isHost) {
+      if (isPresent(inj._parent) && inj._isHostBoundary) {
         return this._getPrivateDependency(key, optional, inj);
       } else {
         inj = inj._parent;
@@ -968,7 +963,7 @@ export class Injector {
     var inj: Injector = this;
 
     if (lowerBoundVisibility instanceof SkipSelfMetadata) {
-      providerVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
+      providerVisibility = inj._isHostBoundary ? Visibility.PublicAndPrivate : Visibility.Public;
       inj = inj._parent;
     }
 
@@ -976,7 +971,7 @@ export class Injector {
       var obj = inj._strategy.getObjByKeyId(key.id, providerVisibility);
       if (obj !== UNDEFINED) return obj;
 
-      providerVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
+      providerVisibility = inj._isHostBoundary ? Visibility.PublicAndPrivate : Visibility.Public;
       inj = inj._parent;
     }
 
diff --git a/modules/angular2/src/core/di/provider.ts b/modules/angular2/src/core/di/provider.ts
index 2673812..753f0fd 100644
--- a/modules/angular2/src/core/di/provider.ts
+++ b/modules/angular2/src/core/di/provider.ts
@@ -538,50 +538,62 @@ export function resolveFactory(provider: Provider): ResolvedFactory {
  * convenience provider syntax.
  */
 export function resolveProvider(provider: Provider): ResolvedProvider {
-  return new ResolvedProvider_(Key.get(provider.token), [resolveFactory(provider)], false);
+  return new ResolvedProvider_(Key.get(provider.token), [resolveFactory(provider)], provider.multi);
 }
 
 /**
  * Resolve a list of Providers.
  */
 export function resolveProviders(providers: Array<Type | Provider | any[]>): ResolvedProvider[] {
-  var normalized = _createListOfProviders(_normalizeProviders(
-      providers, new Map<number, _NormalizedProvider | _NormalizedProvider[]>()));
-  return normalized.map(b => {
-    if (b instanceof _NormalizedProvider) {
-      return new ResolvedProvider_(b.key, [b.resolvedFactory], false);
-
-    } else {
-      var arr = <_NormalizedProvider[]>b;
-      return new ResolvedProvider_(arr[0].key, arr.map(_ => _.resolvedFactory), true);
-    }
-  });
+  var normalized = _normalizeProviders(providers, []);
+  var resolved = normalized.map(resolveProvider);
+  return MapWrapper.values(mergeResolvedProviders(resolved, new Map<number, ResolvedProvider>()));
 }
 
 /**
- * The algorithm works as follows:
- *
- * [Provider] -> [_NormalizedProvider|[_NormalizedProvider]] -> [ResolvedProvider]
- *
- * _NormalizedProvider is essentially a resolved provider before it was grouped by key.
+ * Merges a list of ResolvedProviders into a list where
+ * each key is contained exactly once and multi providers
+ * have been merged.
  */
-class _NormalizedProvider {
-  constructor(public key: Key, public resolvedFactory: ResolvedFactory) {}
-}
-
-function _createListOfProviders(flattenedProviders: Map<number, any>): any[] {
-  return MapWrapper.values(flattenedProviders);
+export function mergeResolvedProviders(
+    providers: ResolvedProvider[],
+    normalizedProvidersMap: Map<number, ResolvedProvider>): Map<number, ResolvedProvider> {
+  for (var i = 0; i < providers.length; i++) {
+    var provider = providers[i];
+    var existing = normalizedProvidersMap.get(provider.key.id);
+    if (isPresent(existing)) {
+      if (provider.multiProvider !== existing.multiProvider) {
+        throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);
+      }
+      if (provider.multiProvider) {
+        for (var j = 0; j < provider.resolvedFactories.length; j++) {
+          existing.resolvedFactories.push(provider.resolvedFactories[j]);
+        }
+      } else {
+        normalizedProvidersMap.set(provider.key.id, provider);
+      }
+    } else {
+      var resolvedProvider;
+      if (provider.multiProvider) {
+        resolvedProvider = new ResolvedProvider_(
+            provider.key, ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);
+      } else {
+        resolvedProvider = provider;
+      }
+      normalizedProvidersMap.set(provider.key.id, resolvedProvider);
+    }
+  }
+  return normalizedProvidersMap;
 }
 
 function _normalizeProviders(providers: Array<Type | Provider | ProviderBuilder | any[]>,
-                             res: Map<number, _NormalizedProvider | _NormalizedProvider[]>):
-    Map<number, _NormalizedProvider | _NormalizedProvider[]> {
+                             res: Provider[]): Provider[] {
   providers.forEach(b => {
     if (b instanceof Type) {
-      _normalizeProvider(provide(b, {useClass: b}), res);
+      res.push(provide(b, {useClass: b}));
 
     } else if (b instanceof Provider) {
-      _normalizeProvider(b, res);
+      res.push(b);
 
     } else if (b instanceof Array) {
       _normalizeProviders(b, res);
@@ -597,36 +609,6 @@ function _normalizeProviders(providers: Array<Type | Provider | ProviderBuilder
   return res;
 }
 
-function _normalizeProvider(b: Provider,
-                            res: Map<number, _NormalizedProvider | _NormalizedProvider[]>): void {
-  var key = Key.get(b.token);
-  var factory = resolveFactory(b);
-  var normalized = new _NormalizedProvider(key, factory);
-
-  if (b.multi) {
-    var existingProvider = res.get(key.id);
-
-    if (existingProvider instanceof Array) {
-      existingProvider.push(normalized);
-
-    } else if (isBlank(existingProvider)) {
-      res.set(key.id, [normalized]);
-
-    } else {
-      throw new MixingMultiProvidersWithRegularProvidersError(existingProvider, b);
-    }
-
-  } else {
-    var existingProvider = res.get(key.id);
-
-    if (existingProvider instanceof Array) {
-      throw new MixingMultiProvidersWithRegularProvidersError(existingProvider, b);
-    }
-
-    res.set(key.id, normalized);
-  }
-}
-
 function _constructDependencies(factoryFunction: Function, dependencies: any[]): Dependency[] {
   if (isBlank(dependencies)) {
     return _dependenciesFor(factoryFunction);
diff --git a/modules/angular2/src/core/linker.ts b/modules/angular2/src/core/linker.ts
index b43b697..b04229c 100644
--- a/modules/angular2/src/core/linker.ts
+++ b/modules/angular2/src/core/linker.ts
@@ -17,6 +17,6 @@ export {QueryList} from './linker/query_list';
 export {DynamicComponentLoader} from './linker/dynamic_component_loader';
 export {ElementRef} from './linker/element_ref';
 export {TemplateRef} from './linker/template_ref';
-export {ViewRef, HostViewRef, ProtoViewRef} from './linker/view_ref';
+export {EmbeddedViewRef, HostViewRef, ViewRef, HostViewFactoryRef} from './linker/view_ref';
 export {ViewContainerRef} from './linker/view_container_ref';
 export {ComponentRef} from './linker/dynamic_component_loader';
\ No newline at end of file
diff --git a/modules/angular2/src/core/linker/compiler.ts b/modules/angular2/src/core/linker/compiler.ts
index c4fdaea..9447952 100644
--- a/modules/angular2/src/core/linker/compiler.ts
+++ b/modules/angular2/src/core/linker/compiler.ts
@@ -1,12 +1,12 @@
-import {ProtoViewRef} from 'angular2/src/core/linker/view_ref';
-import {ProtoViewFactory} from 'angular2/src/core/linker/proto_view_factory';
+import {HostViewFactoryRef} from 'angular2/src/core/linker/view_ref';
 
 import {Injectable} from 'angular2/src/core/di';
 import {Type, isBlank, stringify} from 'angular2/src/facade/lang';
 import {BaseException} from 'angular2/src/facade/exceptions';
 import {Promise, PromiseWrapper} from 'angular2/src/facade/async';
 import {reflector} from 'angular2/src/core/reflection/reflection';
-import {CompiledHostTemplate} from 'angular2/src/core/linker/template_commands';
+import {HostViewFactory} from 'angular2/src/core/linker/view';
+import {HostViewFactoryRef_} from 'angular2/src/core/linker/view_ref';
 
 /**
  * Low-level service for compiling {@link Component}s into {@link ProtoViewRef ProtoViews}s, which
@@ -16,37 +16,25 @@ import {CompiledHostTemplate} from 'angular2/src/core/linker/template_commands';
  * both compiles and instantiates a Component.
  */
 export abstract class Compiler {
-  abstract compileInHost(componentType: Type): Promise<ProtoViewRef>;
+  abstract compileInHost(componentType: Type): Promise<HostViewFactoryRef>;
   abstract clearCache();
 }
 
-function _isCompiledHostTemplate(type: any): boolean {
-  return type instanceof CompiledHostTemplate;
+function isHostViewFactory(type: any): boolean {
+  return type instanceof HostViewFactory;
 }
 
 @Injectable()
 export class Compiler_ extends Compiler {
-  constructor(private _protoViewFactory: ProtoViewFactory) { super(); }
-
-  compileInHost(componentType: Type): Promise<ProtoViewRef> {
+  compileInHost(componentType: Type): Promise<HostViewFactoryRef_> {
     var metadatas = reflector.annotations(componentType);
-    var compiledHostTemplate = metadatas.find(_isCompiledHostTemplate);
+    var hostViewFactory = metadatas.find(isHostViewFactory);
 
-    if (isBlank(compiledHostTemplate)) {
-      throw new BaseException(
-          `No precompiled template for component ${stringify(componentType)} found`);
+    if (isBlank(hostViewFactory)) {
+      throw new BaseException(`No precompiled component ${stringify(componentType)} found`);
     }
-    return PromiseWrapper.resolve(this._createProtoView(compiledHostTemplate));
-  }
-
-  private _createProtoView(compiledHostTemplate: CompiledHostTemplate): ProtoViewRef {
-    return this._protoViewFactory.createHost(compiledHostTemplate).ref;
+    return PromiseWrapper.resolve(new HostViewFactoryRef_(hostViewFactory));
   }
 
-  clearCache() { this._protoViewFactory.clearCache(); }
-}
-
-export function internalCreateProtoView(compiler: Compiler,
-                                        compiledHostTemplate: CompiledHostTemplate): ProtoViewRef {
-  return (<any>compiler)._createProtoView(compiledHostTemplate);
+  clearCache() {}
 }
diff --git a/modules/angular2/src/core/linker/directive_resolver.ts b/modules/angular2/src/core/linker/directive_resolver.ts
index 1d19c4e..ae52c0c 100644
--- a/modules/angular2/src/core/linker/directive_resolver.ts
+++ b/modules/angular2/src/core/linker/directive_resolver.ts
@@ -138,3 +138,5 @@ export class DirectiveResolver {
     }
   }
 }
+
+export var CODEGEN_DIRECTIVE_RESOLVER = new DirectiveResolver();
diff --git a/modules/angular2/src/core/linker/dynamic_component_loader.ts b/modules/angular2/src/core/linker/dynamic_component_loader.ts
index 7613835..e885ab8 100644
--- a/modules/angular2/src/core/linker/dynamic_component_loader.ts
+++ b/modules/angular2/src/core/linker/dynamic_component_loader.ts
@@ -3,8 +3,8 @@ import {Compiler} from './compiler';
 import {isType, Type, stringify, isPresent} from 'angular2/src/facade/lang';
 import {Promise} from 'angular2/src/facade/async';
 import {AppViewManager} from 'angular2/src/core/linker/view_manager';
-import {ElementRef} from './element_ref';
-import {ViewRef, HostViewRef} from './view_ref';
+import {ElementRef, ElementRef_} from './element_ref';
+import {HostViewRef} from './view_ref';
 
 /**
  * Represents an instance of a Component created via {@link DynamicComponentLoader}.
@@ -42,7 +42,9 @@ export abstract class ComponentRef {
   /**
    * The {@link ViewRef} of the Host View of this Component instance.
    */
-  get hostView(): HostViewRef { return this.location.parentView; }
+  get hostView(): HostViewRef {
+    return (<ElementRef_>this.location).internalElement.parentView.ref;
+  }
 
   /**
    * @internal
@@ -140,7 +142,7 @@ export abstract class DynamicComponentLoader {
    * ```
    */
   abstract loadAsRoot(type: Type, overrideSelector: string, injector: Injector,
-                      onDispose?: () => void): Promise<ComponentRef>;
+                      onDispose?: () => void, projectableNodes?: any[][]): Promise<ComponentRef>;
 
   /**
    * Creates an instance of a Component and attaches it to a View Container located inside of the
@@ -190,7 +192,8 @@ export abstract class DynamicComponentLoader {
    * ```
    */
   abstract loadIntoLocation(type: Type, hostLocation: ElementRef, anchorName: string,
-                            providers?: ResolvedProvider[]): Promise<ComponentRef>;
+                            providers?: ResolvedProvider[],
+                            projectableNodes?: any[][]): Promise<ComponentRef>;
 
   /**
    * Creates an instance of a Component and attaches it to the View Container found at the
@@ -232,19 +235,19 @@ export abstract class DynamicComponentLoader {
    * <child-component>Child</child-component>
    * ```
    */
-  abstract loadNextToLocation(type: Type, location: ElementRef,
-                              providers?: ResolvedProvider[]): Promise<ComponentRef>;
+  abstract loadNextToLocation(type: Type, location: ElementRef, providers?: ResolvedProvider[],
+                              projectableNodes?: any[][]): Promise<ComponentRef>;
 }
 
 @Injectable()
 export class DynamicComponentLoader_ extends DynamicComponentLoader {
   constructor(private _compiler: Compiler, private _viewManager: AppViewManager) { super(); }
 
-  loadAsRoot(type: Type, overrideSelector: string, injector: Injector,
-             onDispose?: () => void): Promise<ComponentRef> {
+  loadAsRoot(type: Type, overrideSelector: string, injector: Injector, onDispose?: () => void,
+             projectableNodes?: any[][]): Promise<ComponentRef> {
     return this._compiler.compileInHost(type).then(hostProtoViewRef => {
-      var hostViewRef =
-          this._viewManager.createRootHostView(hostProtoViewRef, overrideSelector, injector);
+      var hostViewRef = this._viewManager.createRootHostView(hostProtoViewRef, overrideSelector,
+                                                             injector, projectableNodes);
       var newLocation = this._viewManager.getHostElement(hostViewRef);
       var component = this._viewManager.getComponent(newLocation);
 
@@ -259,24 +262,25 @@ export class DynamicComponentLoader_ extends DynamicComponentLoader {
   }
 
   loadIntoLocation(type: Type, hostLocation: ElementRef, anchorName: string,
-                   providers: ResolvedProvider[] = null): Promise<ComponentRef> {
+                   providers: ResolvedProvider[] = null,
+                   projectableNodes: any[][] = null): Promise<ComponentRef> {
     return this.loadNextToLocation(
-        type, this._viewManager.getNamedElementInComponentView(hostLocation, anchorName),
-        providers);
+        type, this._viewManager.getNamedElementInComponentView(hostLocation, anchorName), providers,
+        projectableNodes);
   }
 
-  loadNextToLocation(type: Type, location: ElementRef,
-                     providers: ResolvedProvider[] = null): Promise<ComponentRef> {
+  loadNextToLocation(type: Type, location: ElementRef, providers: ResolvedProvider[] = null,
+                     projectableNodes: any[][] = null): Promise<ComponentRef> {
     return this._compiler.compileInHost(type).then(hostProtoViewRef => {
       var viewContainer = this._viewManager.getViewContainer(location);
-      var hostViewRef =
-          viewContainer.createHostView(hostProtoViewRef, viewContainer.length, providers);
+      var hostViewRef = viewContainer.createHostView(hostProtoViewRef, viewContainer.length,
+                                                     providers, projectableNodes);
       var newLocation = this._viewManager.getHostElement(hostViewRef);
       var component = this._viewManager.getComponent(newLocation);
 
       var dispose = () => {
-        var index = viewContainer.indexOf(<ViewRef>hostViewRef);
-        if (index !== -1) {
+        var index = viewContainer.indexOf(hostViewRef);
+        if (!hostViewRef.destroyed && index !== -1) {
           viewContainer.remove(index);
         }
       };
diff --git a/modules/angular2/src/core/linker/element.ts b/modules/angular2/src/core/linker/element.ts
new file mode 100644
index 0000000..7911e35
--- /dev/null
+++ b/modules/angular2/src/core/linker/element.ts
@@ -0,0 +1,867 @@
+import {
+  isPresent,
+  isBlank,
+  Type,
+  stringify,
+  CONST_EXPR,
+  StringWrapper
+} from 'angular2/src/facade/lang';
+import {BaseException} from 'angular2/src/facade/exceptions';
+import {ListWrapper, MapWrapper, StringMapWrapper} from 'angular2/src/facade/collection';
+import {
+  Injector,
+  Key,
+  Dependency,
+  provide,
+  Provider,
+  ResolvedProvider,
+  NoProviderError,
+  AbstractProviderError,
+  CyclicDependencyError,
+  resolveForwardRef,
+  Injectable
+} from 'angular2/src/core/di';
+import {mergeResolvedProviders} from 'angular2/src/core/di/provider';
+import {
+  UNDEFINED,
+  ProtoInjector,
+  Visibility,
+  InjectorInlineStrategy,
+  InjectorDynamicStrategy,
+  ProviderWithVisibility,
+  DependencyProvider
+} from 'angular2/src/core/di/injector';
+import {resolveProvider, ResolvedFactory, ResolvedProvider_} from 'angular2/src/core/di/provider';
+
+import {AttributeMetadata, QueryMetadata} from '../metadata/di';
+
+import {AppView} from './view';
+import {ViewType} from './view_type';
+import {ElementRef_} from './element_ref';
+
+import {ViewContainerRef} from './view_container_ref';
+import {ElementRef} from './element_ref';
+import {Renderer} from 'angular2/src/core/render/api';
+import {TemplateRef, TemplateRef_} from './template_ref';
+import {DirectiveMetadata, ComponentMetadata} from '../metadata/directives';
+import {
+  ChangeDetector,
+  ChangeDetectorRef
+} from 'angular2/src/core/change_detection/change_detection';
+import {QueryList} from './query_list';
+import {reflector} from 'angular2/src/core/reflection/reflection';
+import {SetterFn} from 'angular2/src/core/reflection/types';
+import {AfterViewChecked} from 'angular2/src/core/linker/interfaces';
+import {PipeProvider} from 'angular2/src/core/pipes/pipe_provider';
+
+import {ViewContainerRef_} from "./view_container_ref";
+import {ResolvedMetadataCache} from './resolved_metadata_cache';
+
+var _staticKeys;
+
+export class StaticKeys {
+  templateRefId: number;
+  viewContainerId: number;
+  changeDetectorRefId: number;
+  elementRefId: number;
+  rendererId: number;
+
+  constructor() {
+    this.templateRefId = Key.get(TemplateRef).id;
+    this.viewContainerId = Key.get(ViewContainerRef).id;
+    this.changeDetectorRefId = Key.get(ChangeDetectorRef).id;
+    this.elementRefId = Key.get(ElementRef).id;
+    this.rendererId = Key.get(Renderer).id;
+  }
+
+  static instance(): StaticKeys {
+    if (isBlank(_staticKeys)) _staticKeys = new StaticKeys();
+    return _staticKeys;
+  }
+}
+
+export class DirectiveDependency extends Dependency {
+  constructor(key: Key, optional: boolean, lowerBoundVisibility: Object,
+              upperBoundVisibility: Object, properties: any[], public attributeName: string,
+              public queryDecorator: QueryMetadata) {
+    super(key, optional, lowerBoundVisibility, upperBoundVisibility, properties);
+    this._verify();
+  }
+
+  /** @internal */
+  _verify(): void {
+    var count = 0;
+    if (isPresent(this.queryDecorator)) count++;
+    if (isPresent(this.attributeName)) count++;
+    if (count > 1)
+      throw new BaseException(
+          'A directive injectable can contain only one of the following @Attribute or @Query.');
+  }
+
+  static createFrom(d: Dependency): DirectiveDependency {
+    return new DirectiveDependency(
+        d.key, d.optional, d.lowerBoundVisibility, d.upperBoundVisibility, d.properties,
+        DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));
+  }
+
+  /** @internal */
+  static _attributeName(properties: any[]): string {
+    var p = <AttributeMetadata>properties.find(p => p instanceof AttributeMetadata);
+    return isPresent(p) ? p.attributeName : null;
+  }
+
+  /** @internal */
+  static _query(properties: any[]): QueryMetadata {
+    return <QueryMetadata>properties.find(p => p instanceof QueryMetadata);
+  }
+}
+
+export class DirectiveProvider extends ResolvedProvider_ {
+  constructor(key: Key, factory: Function, deps: Dependency[], public isComponent: boolean,
+              public providers: ResolvedProvider[], public viewProviders: ResolvedProvider[],
+              public queries: QueryMetadataWithSetter[]) {
+    super(key, [new ResolvedFactory(factory, deps)], false);
+  }
+
+  get displayName(): string { return this.key.displayName; }
+
+  static createFromType(type: Type, meta: DirectiveMetadata): DirectiveProvider {
+    var provider = new Provider(type, {useClass: type});
+    if (isBlank(meta)) {
+      meta = new DirectiveMetadata();
+    }
+    var rb = resolveProvider(provider);
+    var rf = rb.resolvedFactories[0];
+    var deps: DirectiveDependency[] = rf.dependencies.map(DirectiveDependency.createFrom);
+    var isComponent = meta instanceof ComponentMetadata;
+    var resolvedProviders = isPresent(meta.providers) ? Injector.resolve(meta.providers) : null;
+    var resolvedViewProviders = meta instanceof ComponentMetadata && isPresent(meta.viewProviders) ?
+                                    Injector.resolve(meta.viewProviders) :
+                                    null;
+    var queries = [];
+    if (isPresent(meta.queries)) {
+      StringMapWrapper.forEach(meta.queries, (meta, fieldName) => {
+        var setter = reflector.setter(fieldName);
+        queries.push(new QueryMetadataWithSetter(setter, meta));
+      });
+    }
+    // queries passed into the constructor.
+    // TODO: remove this after constructor queries are no longer supported
+    deps.forEach(d => {
+      if (isPresent(d.queryDecorator)) {
+        queries.push(new QueryMetadataWithSetter(null, d.queryDecorator));
+      }
+    });
+    return new DirectiveProvider(rb.key, rf.factory, deps, isComponent, resolvedProviders,
+                                 resolvedViewProviders, queries);
+  }
+}
+
+export class QueryMetadataWithSetter {
+  constructor(public setter: SetterFn, public metadata: QueryMetadata) {}
+}
+
+
+function setProvidersVisibility(providers: ResolvedProvider[], visibility: Visibility,
+                                result: Map<number, Visibility>) {
+  for (var i = 0; i < providers.length; i++) {
+    result.set(providers[i].key.id, visibility);
+  }
+}
+
+export class AppProtoElement {
+  protoInjector: ProtoInjector;
+
+  static create(metadataCache: ResolvedMetadataCache, index: number,
+                attributes: {[key: string]: string}, directiveTypes: Type[],
+                directiveVariableBindings: {[key: string]: number}): AppProtoElement {
+    var componentDirProvider = null;
+    var mergedProvidersMap: Map<number, ResolvedProvider> = new Map<number, ResolvedProvider>();
+    var providerVisibilityMap: Map<number, Visibility> = new Map<number, Visibility>();
+    var providers = ListWrapper.createGrowableSize(directiveTypes.length);
+
+    var protoQueryRefs = [];
+    for (var i = 0; i < directiveTypes.length; i++) {
+      var dirProvider = metadataCache.getResolvedDirectiveMetadata(directiveTypes[i]);
+      providers[i] = new ProviderWithVisibility(
+          dirProvider, dirProvider.isComponent ? Visibility.PublicAndPrivate : Visibility.Public);
+
+      if (dirProvider.isComponent) {
+        componentDirProvider = dirProvider;
+      } else {
+        if (isPresent(dirProvider.providers)) {
+          mergeResolvedProviders(dirProvider.providers, mergedProvidersMap);
+          setProvidersVisibility(dirProvider.providers, Visibility.Public, providerVisibilityMap);
+        }
+      }
+      if (isPresent(dirProvider.viewProviders)) {
+        mergeResolvedProviders(dirProvider.viewProviders, mergedProvidersMap);
+        setProvidersVisibility(dirProvider.viewProviders, Visibility.Private,
+                               providerVisibilityMap);
+      }
+      for (var queryIdx = 0; queryIdx < dirProvider.queries.length; queryIdx++) {
+        var q = dirProvider.queries[queryIdx];
+        protoQueryRefs.push(new ProtoQueryRef(i, q.setter, q.metadata));
+      }
+    }
+    if (isPresent(componentDirProvider) && isPresent(componentDirProvider.providers)) {
+      // directive providers need to be prioritized over component providers
+      mergeResolvedProviders(componentDirProvider.providers, mergedProvidersMap);
+      setProvidersVisibility(componentDirProvider.providers, Visibility.Public,
+                             providerVisibilityMap);
+    }
+    mergedProvidersMap.forEach((provider, _) => {
+      providers.push(
+          new ProviderWithVisibility(provider, providerVisibilityMap.get(provider.key.id)));
+    });
+
+    return new AppProtoElement(isPresent(componentDirProvider), index, attributes, providers,
+                               protoQueryRefs, directiveVariableBindings);
+  }
+
+  constructor(public firstProviderIsComponent: boolean, public index: number,
+              public attributes: {[key: string]: string}, pwvs: ProviderWithVisibility[],
+              public protoQueryRefs: ProtoQueryRef[],
+              public directiveVariableBindings: {[key: string]: number}) {
+    var length = pwvs.length;
+    if (length > 0) {
+      this.protoInjector = new ProtoInjector(pwvs);
+    } else {
+      this.protoInjector = null;
+      this.protoQueryRefs = [];
+    }
+  }
+
+  getProviderAtIndex(index: number): any { return this.protoInjector.getProviderAtIndex(index); }
+}
+
+class _Context {
+  constructor(public element: any, public componentElement: any, public injector: any) {}
+}
+
+export class InjectorWithHostBoundary {
+  constructor(public injector: Injector, public hostInjectorBoundary: boolean) {}
+}
+
+export class AppElement implements DependencyProvider, ElementRef, AfterViewChecked {
+  static getViewParentInjector(parentViewType: ViewType, containerAppElement: AppElement,
+                               imperativelyCreatedProviders: ResolvedProvider[],
+                               rootInjector: Injector): InjectorWithHostBoundary {
+    var parentInjector;
+    var hostInjectorBoundary;
+    switch (parentViewType) {
+      case ViewType.COMPONENT:
+        parentInjector = containerAppElement._injector;
+        hostInjectorBoundary = true;
+        break;
+      case ViewType.EMBEDDED:
+        parentInjector = isPresent(containerAppElement.proto.protoInjector) ?
+                             containerAppElement._injector.parent :
+                             containerAppElement._injector;
+        hostInjectorBoundary = containerAppElement._injector.hostBoundary;
+        break;
+      case ViewType.HOST:
+        if (isPresent(containerAppElement)) {
+          // host view is attached to a container
+          parentInjector = isPresent(containerAppElement.proto.protoInjector) ?
+                               containerAppElement._injector.parent :
+                               containerAppElement._injector;
+          if (isPresent(imperativelyCreatedProviders)) {
+            var imperativeProvidersWithVisibility = imperativelyCreatedProviders.map(
+                p => new ProviderWithVisibility(p, Visibility.Public));
+            // The imperative injector is similar to having an element between
+            // the dynamic-loaded component and its parent => no boundary between
+            // the component and imperativelyCreatedInjector.
+            parentInjector = new Injector(new ProtoInjector(imperativeProvidersWithVisibility),
+                                          parentInjector, true, null, null);
+            hostInjectorBoundary = false;
+          } else {
+            hostInjectorBoundary = containerAppElement._injector.hostBoundary;
+          }
+        } else {
+          // bootstrap
+          parentInjector = rootInjector;
+          hostInjectorBoundary = true;
+        }
+        break;
+    }
+    return new InjectorWithHostBoundary(parentInjector, hostInjectorBoundary);
+  }
+
+  public nestedViews: AppView[] = null;
+  public componentView: AppView = null;
+
+  private _queryStrategy: _QueryStrategy;
+  private _injector: Injector;
+  private _strategy: _ElementDirectiveStrategy;
+  public ref: ElementRef_;
+
+  constructor(public proto: AppProtoElement, public parentView: AppView, public parent: AppElement,
+              public nativeElement: any, public embeddedViewFactory: Function) {
+    this.ref = new ElementRef_(this);
+    var parentInjector = isPresent(parent) ? parent._injector : parentView.parentInjector;
+    if (isPresent(this.proto.protoInjector)) {
+      var isBoundary;
+      if (isPresent(parent) && isPresent(parent.proto.protoInjector)) {
+        isBoundary = false;
+      } else {
+        isBoundary = parentView.hostInjectorBoundary;
+      }
+      this._queryStrategy = this._buildQueryStrategy();
+      this._injector = new Injector(this.proto.protoInjector, parentInjector, isBoundary, this,
+                                    () => this._debugContext());
+
+      // we couple ourselves to the injector strategy to avoid polymorphic calls
+      var injectorStrategy = <any>this._injector.internalStrategy;
+      this._strategy = injectorStrategy instanceof InjectorInlineStrategy ?
+                           new ElementDirectiveInlineStrategy(injectorStrategy, this) :
+                           new ElementDirectiveDynamicStrategy(injectorStrategy, this);
+      this._strategy.init();
+    } else {
+      this._queryStrategy = null;
+      this._injector = parentInjector;
+      this._strategy = null;
+    }
+  }
+
+  attachComponentView(componentView: AppView) { this.componentView = componentView; }
+
+  private _debugContext(): any {
+    var c = this.parentView.getDebugContext(this, null, null);
+    return isPresent(c) ? new _Context(c.element, c.componentElement, c.injector) : null;
+  }
+
+  hasVariableBinding(name: string): boolean {
+    var vb = this.proto.directiveVariableBindings;
+    return isPresent(vb) && StringMapWrapper.contains(vb, name);
+  }
+
+  getVariableBinding(name: string): any {
+    var index = this.proto.directiveVariableBindings[name];
+    return isPresent(index) ? this.getDirectiveAtIndex(<number>index) : this.getElementRef();
+  }
+
+  get(token: any): any { return this._injector.get(token); }
+
+  hasDirective(type: Type): boolean { return isPresent(this._injector.getOptional(type)); }
+
+  getComponent(): any { return isPresent(this._strategy) ? this._strategy.getComponent() : null; }
+
+  getInjector(): Injector { return this._injector; }
+
+  getElementRef(): ElementRef { return this.ref; }
+
+  getViewContainerRef(): ViewContainerRef { return new ViewContainerRef_(this); }
+
+  getTemplateRef(): TemplateRef {
+    if (isPresent(this.embeddedViewFactory)) {
+      return new TemplateRef_(this.ref);
+    }
+    return null;
+  }
+
+  getDependency(injector: Injector, provider: ResolvedProvider, dep: Dependency): any {
+    if (provider instanceof DirectiveProvider) {
+      var dirDep = <DirectiveDependency>dep;
+
+      if (isPresent(dirDep.attributeName)) return this._buildAttribute(dirDep);
+
+      if (isPresent(dirDep.queryDecorator))
+        return this._queryStrategy.findQuery(dirDep.queryDecorator).list;
+
+      if (dirDep.key.id === StaticKeys.instance().changeDetectorRefId) {
+        // We provide the component's view change detector to components and
+        // the surrounding component's change detector to directives.
+        if (this.proto.firstProviderIsComponent) {
+          // Note: The component view is not yet created when
+          // this method is called!
+          return new _ComponentViewChangeDetectorRef(this);
+        } else {
+          return this.parentView.changeDetector.ref;
+        }
+      }
+
+      if (dirDep.key.id === StaticKeys.instance().elementRefId) {
+        return this.getElementRef();
+      }
+
+      if (dirDep.key.id === StaticKeys.instance().viewContainerId) {
+        return this.getViewContainerRef();
+      }
+
+      if (dirDep.key.id === StaticKeys.instance().templateRefId) {
+        var tr = this.getTemplateRef();
+        if (isBlank(tr) && !dirDep.optional) {
+          throw new NoProviderError(null, dirDep.key);
+        }
+        return tr;
+      }
+
+      if (dirDep.key.id === StaticKeys.instance().rendererId) {
+        return this.parentView.renderer;
+      }
+
+    } else if (provider instanceof PipeProvider) {
+      if (dep.key.id === StaticKeys.instance().changeDetectorRefId) {
+        // We provide the component's view change detector to components and
+        // the surrounding component's change detector to directives.
+        if (this.proto.firstProviderIsComponent) {
+          // Note: The component view is not yet created when
+          // this method is called!
+          return new _ComponentViewChangeDetectorRef(this);
+        } else {
+          return this.parentView.changeDetector;
+        }
+      }
+    }
+
+    return UNDEFINED;
+  }
+
+  private _buildAttribute(dep: DirectiveDependency): string {
+    var attributes = this.proto.attributes;
+    if (isPresent(attributes) && StringMapWrapper.contains(attributes, dep.attributeName)) {
+      return attributes[dep.attributeName];
+    } else {
+      return null;
+    }
+  }
+
+  addDirectivesMatchingQuery(query: QueryMetadata, list: any[]): void {
+    var templateRef = this.getTemplateRef();
+    if (query.selector === TemplateRef && isPresent(templateRef)) {
+      list.push(templateRef);
+    }
+    if (this._strategy != null) {
+      this._strategy.addDirectivesMatchingQuery(query, list);
+    }
+  }
+
+  private _buildQueryStrategy(): _QueryStrategy {
+    if (this.proto.protoQueryRefs.length === 0) {
+      return _emptyQueryStrategy;
+    } else if (this.proto.protoQueryRefs.length <=
+               InlineQueryStrategy.NUMBER_OF_SUPPORTED_QUERIES) {
+      return new InlineQueryStrategy(this);
+    } else {
+      return new DynamicQueryStrategy(this);
+    }
+  }
+
+
+  getDirectiveAtIndex(index: number): any { return this._injector.getAt(index); }
+
+  ngAfterViewChecked(): void {
+    if (isPresent(this._queryStrategy)) this._queryStrategy.updateViewQueries();
+  }
+
+  ngAfterContentChecked(): void {
+    if (isPresent(this._queryStrategy)) this._queryStrategy.updateContentQueries();
+  }
+
+  traverseAndSetQueriesAsDirty(): void {
+    var inj: AppElement = this;
+    while (isPresent(inj)) {
+      inj._setQueriesAsDirty();
+      inj = inj.parent;
+    }
+  }
+
+  private _setQueriesAsDirty(): void {
+    if (isPresent(this._queryStrategy)) {
+      this._queryStrategy.setContentQueriesAsDirty();
+    }
+    if (this.parentView.proto.type === ViewType.COMPONENT) {
+      this.parentView.containerAppElement._queryStrategy.setViewQueriesAsDirty();
+    }
+  }
+}
+
+interface _QueryStrategy {
+  setContentQueriesAsDirty(): void;
+  setViewQueriesAsDirty(): void;
+  updateContentQueries(): void;
+  updateViewQueries(): void;
+  findQuery(query: QueryMetadata): QueryRef;
+}
+
+class _EmptyQueryStrategy implements _QueryStrategy {
+  setContentQueriesAsDirty(): void {}
+  setViewQueriesAsDirty(): void {}
+  updateContentQueries(): void {}
+  updateViewQueries(): void {}
+  findQuery(query: QueryMetadata): QueryRef {
+    throw new BaseException(`Cannot find query for directive ${query}.`);
+  }
+}
+
+var _emptyQueryStrategy = new _EmptyQueryStrategy();
+
+class InlineQueryStrategy implements _QueryStrategy {
+  static NUMBER_OF_SUPPORTED_QUERIES = 3;
+
+  query0: QueryRef;
+  query1: QueryRef;
+  query2: QueryRef;
+
+  constructor(ei: AppElement) {
+    var protoRefs = ei.proto.protoQueryRefs;
+    if (protoRefs.length > 0) this.query0 = new QueryRef(protoRefs[0], ei);
+    if (protoRefs.length > 1) this.query1 = new QueryRef(protoRefs[1], ei);
+    if (protoRefs.length > 2) this.query2 = new QueryRef(protoRefs[2], ei);
+  }
+
+  setContentQueriesAsDirty(): void {
+    if (isPresent(this.query0) && !this.query0.isViewQuery) this.query0.dirty = true;
+    if (isPresent(this.query1) && !this.query1.isViewQuery) this.query1.dirty = true;
+    if (isPresent(this.query2) && !this.query2.isViewQuery) this.query2.dirty = true;
+  }
+
+  setViewQueriesAsDirty(): void {
+    if (isPresent(this.query0) && this.query0.isViewQuery) this.query0.dirty = true;
+    if (isPresent(this.query1) && this.query1.isViewQuery) this.query1.dirty = true;
+    if (isPresent(this.query2) && this.query2.isViewQuery) this.query2.dirty = true;
+  }
+
+  updateContentQueries() {
+    if (isPresent(this.query0) && !this.query0.isViewQuery) {
+      this.query0.update();
+    }
+    if (isPresent(this.query1) && !this.query1.isViewQuery) {
+      this.query1.update();
+    }
+    if (isPresent(this.query2) && !this.query2.isViewQuery) {
+      this.query2.update();
+    }
+  }
+
+  updateViewQueries() {
+    if (isPresent(this.query0) && this.query0.isViewQuery) {
+      this.query0.update();
+    }
+    if (isPresent(this.query1) && this.query1.isViewQuery) {
+      this.query1.update();
+    }
+    if (isPresent(this.query2) && this.query2.isViewQuery) {
+      this.query2.update();
+    }
+  }
+
+  findQuery(query: QueryMetadata): QueryRef {
+    if (isPresent(this.query0) && this.query0.protoQueryRef.query === query) {
+      return this.query0;
+    }
+    if (isPresent(this.query1) && this.query1.protoQueryRef.query === query) {
+      return this.query1;
+    }
+    if (isPresent(this.query2) && this.query2.protoQueryRef.query === query) {
+      return this.query2;
+    }
+    throw new BaseException(`Cannot find query for directive ${query}.`);
+  }
+}
+
+class DynamicQueryStrategy implements _QueryStrategy {
+  queries: QueryRef[];
+
+  constructor(ei: AppElement) {
+    this.queries = ei.proto.protoQueryRefs.map(p => new QueryRef(p, ei));
+  }
+
+  setContentQueriesAsDirty(): void {
+    for (var i = 0; i < this.queries.length; ++i) {
+      var q = this.queries[i];
+      if (!q.isViewQuery) q.dirty = true;
+    }
+  }
+
+  setViewQueriesAsDirty(): void {
+    for (var i = 0; i < this.queries.length; ++i) {
+      var q = this.queries[i];
+      if (q.isViewQuery) q.dirty = true;
+    }
+  }
+
+  updateContentQueries() {
+    for (var i = 0; i < this.queries.length; ++i) {
+      var q = this.queries[i];
+      if (!q.isViewQuery) {
+        q.update();
+      }
+    }
+  }
+
+  updateViewQueries() {
+    for (var i = 0; i < this.queries.length; ++i) {
+      var q = this.queries[i];
+      if (q.isViewQuery) {
+        q.update();
+      }
+    }
+  }
+
+  findQuery(query: QueryMetadata): QueryRef {
+    for (var i = 0; i < this.queries.length; ++i) {
+      var q = this.queries[i];
+      if (q.protoQueryRef.query === query) {
+        return q;
+      }
+    }
+    throw new BaseException(`Cannot find query for directive ${query}.`);
+  }
+}
+
+interface _ElementDirectiveStrategy {
+  getComponent(): any;
+  isComponentKey(key: Key): boolean;
+  addDirectivesMatchingQuery(q: QueryMetadata, res: any[]): void;
+  init(): void;
+}
+
+/**
+ * Strategy used by the `ElementInjector` when the number of providers is 10 or less.
+ * In such a case, inlining fields is beneficial for performances.
+ */
+class ElementDirectiveInlineStrategy implements _ElementDirectiveStrategy {
+  constructor(public injectorStrategy: InjectorInlineStrategy, public _ei: AppElement) {}
+
+  init(): void {
+    var i = this.injectorStrategy;
+    var p = i.protoStrategy;
+    i.resetConstructionCounter();
+
+    if (p.provider0 instanceof DirectiveProvider && isPresent(p.keyId0) && i.obj0 === UNDEFINED)
+      i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);
+    if (p.provider1 instanceof DirectiveProvider && isPresent(p.keyId1) && i.obj1 === UNDEFINED)
+      i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);
+    if (p.provider2 instanceof DirectiveProvider && isPresent(p.keyId2) && i.obj2 === UNDEFINED)
+      i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);
+    if (p.provider3 instanceof DirectiveProvider && isPresent(p.keyId3) && i.obj3 === UNDEFINED)
+      i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);
+    if (p.provider4 instanceof DirectiveProvider && isPresent(p.keyId4) && i.obj4 === UNDEFINED)
+      i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);
+    if (p.provider5 instanceof DirectiveProvider && isPresent(p.keyId5) && i.obj5 === UNDEFINED)
+      i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);
+    if (p.provider6 instanceof DirectiveProvider && isPresent(p.keyId6) && i.obj6 === UNDEFINED)
+      i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);
+    if (p.provider7 instanceof DirectiveProvider && isPresent(p.keyId7) && i.obj7 === UNDEFINED)
+      i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);
+    if (p.provider8 instanceof DirectiveProvider && isPresent(p.keyId8) && i.obj8 === UNDEFINED)
+      i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);
+    if (p.provider9 instanceof DirectiveProvider && isPresent(p.keyId9) && i.obj9 === UNDEFINED)
+      i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);
+  }
+
+  getComponent(): any { return this.injectorStrategy.obj0; }
+
+  isComponentKey(key: Key): boolean {
+    return this._ei.proto.firstProviderIsComponent && isPresent(key) &&
+           key.id === this.injectorStrategy.protoStrategy.keyId0;
+  }
+
+  addDirectivesMatchingQuery(query: QueryMetadata, list: any[]): void {
+    var i = this.injectorStrategy;
+    var p = i.protoStrategy;
+    if (isPresent(p.provider0) && p.provider0.key.token === query.selector) {
+      if (i.obj0 === UNDEFINED) i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);
+      list.push(i.obj0);
+    }
+    if (isPresent(p.provider1) && p.provider1.key.token === query.selector) {
+      if (i.obj1 === UNDEFINED) i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);
+      list.push(i.obj1);
+    }
+    if (isPresent(p.provider2) && p.provider2.key.token === query.selector) {
+      if (i.obj2 === UNDEFINED) i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);
+      list.push(i.obj2);
+    }
+    if (isPresent(p.provider3) && p.provider3.key.token === query.selector) {
+      if (i.obj3 === UNDEFINED) i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);
+      list.push(i.obj3);
+    }
+    if (isPresent(p.provider4) && p.provider4.key.token === query.selector) {
+      if (i.obj4 === UNDEFINED) i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);
+      list.push(i.obj4);
+    }
+    if (isPresent(p.provider5) && p.provider5.key.token === query.selector) {
+      if (i.obj5 === UNDEFINED) i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);
+      list.push(i.obj5);
+    }
+    if (isPresent(p.provider6) && p.provider6.key.token === query.selector) {
+      if (i.obj6 === UNDEFINED) i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);
+      list.push(i.obj6);
+    }
+    if (isPresent(p.provider7) && p.provider7.key.token === query.selector) {
+      if (i.obj7 === UNDEFINED) i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);
+      list.push(i.obj7);
+    }
+    if (isPresent(p.provider8) && p.provider8.key.token === query.selector) {
+      if (i.obj8 === UNDEFINED) i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);
+      list.push(i.obj8);
+    }
+    if (isPresent(p.provider9) && p.provider9.key.token === query.selector) {
+      if (i.obj9 === UNDEFINED) i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);
+      list.push(i.obj9);
+    }
+  }
+}
+
+/**
+ * Strategy used by the `ElementInjector` when the number of bindings is 11 or more.
+ * In such a case, there are too many fields to inline (see ElementInjectorInlineStrategy).
+ */
+class ElementDirectiveDynamicStrategy implements _ElementDirectiveStrategy {
+  constructor(public injectorStrategy: InjectorDynamicStrategy, public _ei: AppElement) {}
+
+  init(): void {
+    var inj = this.injectorStrategy;
+    var p = inj.protoStrategy;
+    inj.resetConstructionCounter();
+
+    for (var i = 0; i < p.keyIds.length; i++) {
+      if (p.providers[i] instanceof DirectiveProvider && isPresent(p.keyIds[i]) &&
+          inj.objs[i] === UNDEFINED) {
+        inj.objs[i] = inj.instantiateProvider(p.providers[i], p.visibilities[i]);
+      }
+    }
+  }
+
+  getComponent(): any { return this.injectorStrategy.objs[0]; }
+
+  isComponentKey(key: Key): boolean {
+    var p = this.injectorStrategy.protoStrategy;
+    return this._ei.proto.firstProviderIsComponent && isPresent(key) && key.id === p.keyIds[0];
+  }
+
+  addDirectivesMatchingQuery(query: QueryMetadata, list: any[]): void {
+    var ist = this.injectorStrategy;
+    var p = ist.protoStrategy;
+
+    for (var i = 0; i < p.providers.length; i++) {
+      if (p.providers[i].key.token === query.selector) {
+        if (ist.objs[i] === UNDEFINED) {
+          ist.objs[i] = ist.instantiateProvider(p.providers[i], p.visibilities[i]);
+        }
+        list.push(ist.objs[i]);
+      }
+    }
+  }
+}
+
+export class ProtoQueryRef {
+  constructor(public dirIndex: number, public setter: SetterFn, public query: QueryMetadata) {}
+
+  get usesPropertySyntax(): boolean { return isPresent(this.setter); }
+}
+
+export class QueryRef {
+  public list: QueryList<any>;
+  public dirty: boolean;
+
+  constructor(public protoQueryRef: ProtoQueryRef, private originator: AppElement) {
+    this.list = new QueryList<any>();
+    this.dirty = true;
+  }
+
+  get isViewQuery(): boolean { return this.protoQueryRef.query.isViewQuery; }
+
+  update(): void {
+    if (!this.dirty) return;
+    this._update();
+    this.dirty = false;
+
+    // TODO delete the check once only field queries are supported
+    if (this.protoQueryRef.usesPropertySyntax) {
+      var dir = this.originator.getDirectiveAtIndex(this.protoQueryRef.dirIndex);
+      if (this.protoQueryRef.query.first) {
+        this.protoQueryRef.setter(dir, this.list.length > 0 ? this.list.first : null);
+      } else {
+        this.protoQueryRef.setter(dir, this.list);
+      }
+    }
+
+    this.list.notifyOnChanges();
+  }
+
+  private _update(): void {
+    var aggregator = [];
+    if (this.protoQueryRef.query.isViewQuery) {
+      // intentionally skipping originator for view queries.
+      var nestedView = this.originator.componentView;
+      if (isPresent(nestedView)) this._visitView(nestedView, aggregator);
+    } else {
+      this._visit(this.originator, aggregator);
+    }
+    this.list.reset(aggregator);
+  };
+
+  private _visit(inj: AppElement, aggregator: any[]): void {
+    var view = inj.parentView;
+    var startIdx = inj.proto.index;
+    for (var i = startIdx; i < view.appElements.length; i++) {
+      var curInj = view.appElements[i];
+      // The first injector after inj, that is outside the subtree rooted at
+      // inj has to have a null parent or a parent that is an ancestor of inj.
+      if (i > startIdx && (isBlank(curInj.parent) || curInj.parent.proto.index < startIdx)) {
+        break;
+      }
+
+      if (!this.protoQueryRef.query.descendants &&
+          !(curInj.parent == this.originator || curInj == this.originator))
+        continue;
+
+      // We visit the view container(VC) views right after the injector that contains
+      // the VC. Theoretically, that might not be the right order if there are
+      // child injectors of said injector. Not clear whether if such case can
+      // even be constructed with the current apis.
+      this._visitInjector(curInj, aggregator);
+      this._visitViewContainerViews(curInj.nestedViews, aggregator);
+    }
+  }
+
+  private _visitInjector(inj: AppElement, aggregator: any[]) {
+    if (this.protoQueryRef.query.isVarBindingQuery) {
+      this._aggregateVariableBinding(inj, aggregator);
+    } else {
+      this._aggregateDirective(inj, aggregator);
+    }
+  }
+
+  private _visitViewContainerViews(views: AppView[], aggregator: any[]) {
+    if (isPresent(views)) {
+      for (var j = 0; j < views.length; j++) {
+        this._visitView(views[j], aggregator);
+      }
+    }
+  }
+
+  private _visitView(view: AppView, aggregator: any[]) {
+    for (var i = 0; i < view.appElements.length; i++) {
+      var inj = view.appElements[i];
+      this._visitInjector(inj, aggregator);
+      this._visitViewContainerViews(inj.nestedViews, aggregator);
+    }
+  }
+
+  private _aggregateVariableBinding(inj: AppElement, aggregator: any[]): void {
+    var vb = this.protoQueryRef.query.varBindings;
+    for (var i = 0; i < vb.length; ++i) {
+      if (inj.hasVariableBinding(vb[i])) {
+        aggregator.push(inj.getVariableBinding(vb[i]));
+      }
+    }
+  }
+
+  private _aggregateDirective(inj: AppElement, aggregator: any[]): void {
+    inj.addDirectivesMatchingQuery(this.protoQueryRef.query, aggregator);
+  }
+}
+
+class _ComponentViewChangeDetectorRef extends ChangeDetectorRef {
+  constructor(private _appElement: AppElement) { super(); }
+
+  markForCheck(): void { this._appElement.componentView.changeDetector.ref.markForCheck(); }
+  detach(): void { this._appElement.componentView.changeDetector.ref.detach(); }
+  detectChanges(): void { this._appElement.componentView.changeDetector.ref.detectChanges(); }
+  checkNoChanges(): void { this._appElement.componentView.changeDetector.ref.checkNoChanges(); }
+  reattach(): void { this._appElement.componentView.changeDetector.ref.reattach(); }
+}
diff --git a/modules/angular2/src/core/linker/element_binder.ts b/modules/angular2/src/core/linker/element_binder.ts
deleted file mode 100644
index 00da679..0000000
--- a/modules/angular2/src/core/linker/element_binder.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-import {isBlank} from 'angular2/src/facade/lang';
-import {BaseException} from 'angular2/src/facade/exceptions';
-import * as eiModule from './element_injector';
-import {DirectiveProvider} from './element_injector';
-import * as viewModule from './view';
-
-export class ElementBinder {
-  constructor(public index: number, public parent: ElementBinder, public distanceToParent: number,
-              public protoElementInjector: eiModule.ProtoElementInjector,
-              public componentDirective: DirectiveProvider,
-              public nestedProtoView: viewModule.AppProtoView) {
-    if (isBlank(index)) {
-      throw new BaseException('null index not allowed.');
-    }
-  }
-}
diff --git a/modules/angular2/src/core/linker/element_injector.ts b/modules/angular2/src/core/linker/element_injector.ts
deleted file mode 100644
index cbfa777..0000000
--- a/modules/angular2/src/core/linker/element_injector.ts
+++ /dev/null
@@ -1,1086 +0,0 @@
-import {
-  isPresent,
-  isBlank,
-  Type,
-  stringify,
-  CONST_EXPR,
-  StringWrapper
-} from 'angular2/src/facade/lang';
-import {BaseException} from 'angular2/src/facade/exceptions';
-import {EventEmitter, ObservableWrapper} from 'angular2/src/facade/async';
-import {ListWrapper, MapWrapper, StringMapWrapper} from 'angular2/src/facade/collection';
-import {
-  Injector,
-  Key,
-  Dependency,
-  provide,
-  Provider,
-  ResolvedProvider,
-  NoProviderError,
-  AbstractProviderError,
-  CyclicDependencyError,
-  resolveForwardRef
-} from 'angular2/src/core/di';
-import {
-  UNDEFINED,
-  ProtoInjector,
-  Visibility,
-  InjectorInlineStrategy,
-  InjectorDynamicStrategy,
-  ProviderWithVisibility,
-  DependencyProvider
-} from 'angular2/src/core/di/injector';
-import {resolveProvider, ResolvedFactory, ResolvedProvider_} from 'angular2/src/core/di/provider';
-
-import {AttributeMetadata, QueryMetadata} from '../metadata/di';
-
-import {AppViewContainer, AppView} from './view';
-/* circular */ import * as avmModule from './view_manager';
-import {ViewContainerRef} from './view_container_ref';
-import {ElementRef} from './element_ref';
-import {TemplateRef} from './template_ref';
-import {DirectiveMetadata, ComponentMetadata} from '../metadata/directives';
-import {hasLifecycleHook} from './directive_lifecycle_reflector';
-import {
-  ChangeDetector,
-  ChangeDetectorRef
-} from 'angular2/src/core/change_detection/change_detection';
-import {QueryList} from './query_list';
-import {reflector} from 'angular2/src/core/reflection/reflection';
-import {SetterFn} from 'angular2/src/core/reflection/types';
-import {EventConfig} from 'angular2/src/core/linker/event_config';
-import {AfterViewChecked} from 'angular2/src/core/linker/interfaces';
-import {PipeProvider} from 'angular2/src/core/pipes/pipe_provider';
-
-import {LifecycleHooks} from './interfaces';
-import {ViewContainerRef_} from "./view_container_ref";
-
-var _staticKeys;
-
-export class StaticKeys {
-  viewManagerId: number;
-  templateRefId: number;
-  viewContainerId: number;
-  changeDetectorRefId: number;
-  elementRefId: number;
-
-  constructor() {
-    this.viewManagerId = Key.get(avmModule.AppViewManager).id;
-    this.templateRefId = Key.get(TemplateRef).id;
-    this.viewContainerId = Key.get(ViewContainerRef).id;
-    this.changeDetectorRefId = Key.get(ChangeDetectorRef).id;
-    this.elementRefId = Key.get(ElementRef).id;
-  }
-
-  static instance(): StaticKeys {
-    if (isBlank(_staticKeys)) _staticKeys = new StaticKeys();
-    return _staticKeys;
-  }
-}
-
-export class TreeNode<T extends TreeNode<any>> {
-  /** @internal */
-  _parent: T;
-  constructor(parent: T) {
-    if (isPresent(parent)) {
-      parent.addChild(this);
-    } else {
-      this._parent = null;
-    }
-  }
-
-  addChild(child: T): void { child._parent = this; }
-
-  remove(): void { this._parent = null; }
-
-  get parent() { return this._parent; }
-}
-
-export class DirectiveDependency extends Dependency {
-  constructor(key: Key, optional: boolean, lowerBoundVisibility: Object,
-              upperBoundVisibility: Object, properties: any[], public attributeName: string,
-              public queryDecorator: QueryMetadata) {
-    super(key, optional, lowerBoundVisibility, upperBoundVisibility, properties);
-    this._verify();
-  }
-
-  /** @internal */
-  _verify(): void {
-    var count = 0;
-    if (isPresent(this.queryDecorator)) count++;
-    if (isPresent(this.attributeName)) count++;
-    if (count > 1)
-      throw new BaseException(
-          'A directive injectable can contain only one of the following @Attribute or @Query.');
-  }
-
-  static createFrom(d: Dependency): Dependency {
-    return new DirectiveDependency(
-        d.key, d.optional, d.lowerBoundVisibility, d.upperBoundVisibility, d.properties,
-        DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));
-  }
-
-  /** @internal */
-  static _attributeName(properties: any[]): string {
-    var p = <AttributeMetadata>properties.find(p => p instanceof AttributeMetadata);
-    return isPresent(p) ? p.attributeName : null;
-  }
-
-  /** @internal */
-  static _query(properties: any[]): QueryMetadata {
-    return <QueryMetadata>properties.find(p => p instanceof QueryMetadata);
-  }
-}
-
-export class DirectiveProvider extends ResolvedProvider_ {
-  public callOnDestroy: boolean;
-
-  constructor(key: Key, factory: Function, deps: Dependency[], public metadata: DirectiveMetadata,
-              public providers: Array<Type | Provider | any[]>,
-              public viewProviders: Array<Type | Provider | any[]>) {
-    super(key, [new ResolvedFactory(factory, deps)], false);
-    this.callOnDestroy = hasLifecycleHook(LifecycleHooks.OnDestroy, key.token);
-  }
-
-  get displayName(): string { return this.key.displayName; }
-
-  get queries(): QueryMetadataWithSetter[] {
-    if (isBlank(this.metadata.queries)) return [];
-
-    var res = [];
-    StringMapWrapper.forEach(this.metadata.queries, (meta, fieldName) => {
-      var setter = reflector.setter(fieldName);
-      res.push(new QueryMetadataWithSetter(setter, meta));
-    });
-    return res;
-  }
-
-  get eventEmitters(): string[] {
-    return isPresent(this.metadata) && isPresent(this.metadata.outputs) ? this.metadata.outputs :
-                                                                          [];
-  }
-
-  static createFromProvider(provider: Provider, meta: DirectiveMetadata): DirectiveProvider {
-    if (isBlank(meta)) {
-      meta = new DirectiveMetadata();
-    }
-
-    var rb = resolveProvider(provider);
-    var rf = rb.resolvedFactories[0];
-    var deps = rf.dependencies.map(DirectiveDependency.createFrom);
-
-    var providers = isPresent(meta.providers) ? meta.providers : [];
-    var viewBindigs = meta instanceof ComponentMetadata && isPresent(meta.viewProviders) ?
-                          meta.viewProviders :
-                          [];
-    return new DirectiveProvider(rb.key, rf.factory, deps, meta, providers, viewBindigs);
-  }
-
-  static createFromType(type: Type, annotation: DirectiveMetadata): DirectiveProvider {
-    var provider = new Provider(type, {useClass: type});
-    return DirectiveProvider.createFromProvider(provider, annotation);
-  }
-}
-
-// TODO(rado): benchmark and consider rolling in as ElementInjector fields.
-export class PreBuiltObjects {
-  nestedView: AppView = null;
-  constructor(public viewManager: avmModule.AppViewManager, public view: AppView,
-              public elementRef: ElementRef, public templateRef: TemplateRef) {}
-}
-
-export class QueryMetadataWithSetter {
-  constructor(public setter: SetterFn, public metadata: QueryMetadata) {}
-}
-
-export class EventEmitterAccessor {
-  constructor(public eventName: string, public getter: Function) {}
-
-  subscribe(view: AppView, boundElementIndex: number, directive: Object): Object {
-    var eventEmitter = this.getter(directive);
-    return ObservableWrapper.subscribe<Event>(
-        eventEmitter,
-        eventObj => view.triggerEventHandlers(this.eventName, eventObj, boundElementIndex));
-  }
-}
-
-function _createEventEmitterAccessors(bwv: ProviderWithVisibility): EventEmitterAccessor[] {
-  var provider = bwv.provider;
-  if (!(provider instanceof DirectiveProvider)) return [];
-  var db = <DirectiveProvider>provider;
-  return db.eventEmitters.map(eventConfig => {
-    var parsedEvent = EventConfig.parse(eventConfig);
-    return new EventEmitterAccessor(parsedEvent.eventName, reflector.getter(parsedEvent.fieldName));
-  });
-}
-
-function _createProtoQueryRefs(providers: ProviderWithVisibility[]): ProtoQueryRef[] {
-  var res = [];
-  ListWrapper.forEachWithIndex(providers, (b, i) => {
-    if (b.provider instanceof DirectiveProvider) {
-      var directiveProvider = <DirectiveProvider>b.provider;
-      // field queries
-      var queries: QueryMetadataWithSetter[] = directiveProvider.queries;
-      queries.forEach(q => res.push(new ProtoQueryRef(i, q.setter, q.metadata)));
-
-      // queries passed into the constructor.
-      // TODO: remove this after constructor queries are no longer supported
-      var deps: DirectiveDependency[] =
-          <DirectiveDependency[]>directiveProvider.resolvedFactory.dependencies;
-      deps.forEach(d => {
-        if (isPresent(d.queryDecorator)) res.push(new ProtoQueryRef(i, null, d.queryDecorator));
-      });
-    }
-  });
-  return res;
-}
-
-export class ProtoElementInjector {
-  view: AppView;
-  attributes: Map<string, string>;
-  eventEmitterAccessors: EventEmitterAccessor[][];
-  protoQueryRefs: ProtoQueryRef[];
-  protoInjector: ProtoInjector;
-
-  static create(parent: ProtoElementInjector, index: number, providers: DirectiveProvider[],
-                firstProviderIsComponent: boolean, distanceToParent: number,
-                directiveVariableBindings: Map<string, number>): ProtoElementInjector {
-    var bd = [];
-
-    ProtoElementInjector._createDirectiveProviderWithVisibility(providers, bd,
-                                                                firstProviderIsComponent);
-    if (firstProviderIsComponent) {
-      ProtoElementInjector._createViewProvidersWithVisibility(providers, bd);
-    }
-
-    ProtoElementInjector._createProvidersWithVisibility(providers, bd);
-    return new ProtoElementInjector(parent, index, bd, distanceToParent, firstProviderIsComponent,
-                                    directiveVariableBindings);
-  }
-
-  private static _createDirectiveProviderWithVisibility(dirProviders: DirectiveProvider[],
-                                                        bd: ProviderWithVisibility[],
-                                                        firstProviderIsComponent: boolean) {
-    dirProviders.forEach(dirProvider => {
-      bd.push(ProtoElementInjector._createProviderWithVisibility(
-          firstProviderIsComponent, dirProvider, dirProviders, dirProvider));
-    });
-  }
-
-  private static _createProvidersWithVisibility(dirProviders: DirectiveProvider[],
-                                                bd: ProviderWithVisibility[]) {
-    var providersFromAllDirectives = [];
-    dirProviders.forEach(dirProvider => {
-      providersFromAllDirectives =
-          ListWrapper.concat(providersFromAllDirectives, dirProvider.providers);
-    });
-
-    var resolved = Injector.resolve(providersFromAllDirectives);
-    resolved.forEach(b => bd.push(new ProviderWithVisibility(b, Visibility.Public)));
-  }
-
-  private static _createProviderWithVisibility(firstProviderIsComponent: boolean,
-                                               dirProvider: DirectiveProvider,
-                                               dirProviders: DirectiveProvider[],
-                                               provider: ResolvedProvider) {
-    var isComponent = firstProviderIsComponent && dirProviders[0] === dirProvider;
-    return new ProviderWithVisibility(
-        provider, isComponent ? Visibility.PublicAndPrivate : Visibility.Public);
-  }
-
-  private static _createViewProvidersWithVisibility(dirProviders: DirectiveProvider[],
-                                                    bd: ProviderWithVisibility[]) {
-    var resolvedViewProviders = Injector.resolve(dirProviders[0].viewProviders);
-    resolvedViewProviders.forEach(b => bd.push(new ProviderWithVisibility(b, Visibility.Private)));
-  }
-
-  /** @internal */
-  public _firstProviderIsComponent: boolean;
-
-
-  constructor(public parent: ProtoElementInjector, public index: number,
-              bwv: ProviderWithVisibility[], public distanceToParent: number,
-              _firstProviderIsComponent: boolean,
-              public directiveVariableBindings: Map<string, number>) {
-    this._firstProviderIsComponent = _firstProviderIsComponent;
-    var length = bwv.length;
-    this.protoInjector = new ProtoInjector(bwv);
-    this.eventEmitterAccessors = ListWrapper.createFixedSize(length);
-    for (var i = 0; i < length; ++i) {
-      this.eventEmitterAccessors[i] = _createEventEmitterAccessors(bwv[i]);
-    }
-    this.protoQueryRefs = _createProtoQueryRefs(bwv);
-  }
-
-  instantiate(parent: ElementInjector): ElementInjector {
-    return new ElementInjector(this, parent);
-  }
-
-  directParent(): ProtoElementInjector { return this.distanceToParent < 2 ? this.parent : null; }
-
-  get hasBindings(): boolean { return this.eventEmitterAccessors.length > 0; }
-
-  getProviderAtIndex(index: number): any { return this.protoInjector.getProviderAtIndex(index); }
-}
-
-class _Context {
-  constructor(public element: any, public componentElement: any, public injector: any) {}
-}
-
-export class ElementInjector extends TreeNode<ElementInjector> implements DependencyProvider,
-    AfterViewChecked {
-  private _host: ElementInjector;
-  private _preBuiltObjects: PreBuiltObjects = null;
-  private _queryStrategy: _QueryStrategy;
-
-  hydrated: boolean;
-
-  private _injector: Injector;
-  private _strategy: _ElementInjectorStrategy;
-  /** @internal */
-  public _proto: ProtoElementInjector;
-
-  constructor(_proto: ProtoElementInjector, parent: ElementInjector) {
-    super(parent);
-    this._proto = _proto;
-    this._injector =
-        new Injector(this._proto.protoInjector, null, this, () => this._debugContext());
-
-    // we couple ourselves to the injector strategy to avoid polymoprhic calls
-    var injectorStrategy = <any>this._injector.internalStrategy;
-    this._strategy = injectorStrategy instanceof InjectorInlineStrategy ?
-                         new ElementInjectorInlineStrategy(injectorStrategy, this) :
-                         new ElementInjectorDynamicStrategy(injectorStrategy, this);
-
-    this.hydrated = false;
-
-    this._queryStrategy = this._buildQueryStrategy();
-  }
-
-  dehydrate(): void {
-    this.hydrated = false;
-    this._host = null;
-    this._preBuiltObjects = null;
-    this._strategy.callOnDestroy();
-    this._strategy.dehydrate();
-    this._queryStrategy.dehydrate();
-  }
-
-  hydrate(imperativelyCreatedInjector: Injector, host: ElementInjector,
-          preBuiltObjects: PreBuiltObjects): void {
-    this._host = host;
-    this._preBuiltObjects = preBuiltObjects;
-
-    this._reattachInjectors(imperativelyCreatedInjector);
-    this._queryStrategy.hydrate();
-    this._strategy.hydrate();
-
-    this.hydrated = true;
-  }
-
-  private _debugContext(): any {
-    var p = this._preBuiltObjects;
-    var index = p.elementRef.boundElementIndex - p.view.elementOffset;
-    var c = this._preBuiltObjects.view.getDebugContext(index, null);
-    return isPresent(c) ? new _Context(c.element, c.componentElement, c.injector) : null;
-  }
-
-  private _reattachInjectors(imperativelyCreatedInjector: Injector): void {
-    // Dynamically-loaded component in the template. Not a root ElementInjector.
-    if (isPresent(this._parent)) {
-      if (isPresent(imperativelyCreatedInjector)) {
-        // The imperative injector is similar to having an element between
-        // the dynamic-loaded component and its parent => no boundaries.
-        this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
-        this._reattachInjector(imperativelyCreatedInjector, this._parent._injector, false);
-      } else {
-        this._reattachInjector(this._injector, this._parent._injector, false);
-      }
-
-      // Dynamically-loaded component in the template. A root ElementInjector.
-    } else if (isPresent(this._host)) {
-      // The imperative injector is similar to having an element between
-      // the dynamic-loaded component and its parent => no boundary between
-      // the component and imperativelyCreatedInjector.
-      // But since it is a root ElementInjector, we need to create a boundary
-      // between imperativelyCreatedInjector and _host.
-      if (isPresent(imperativelyCreatedInjector)) {
-        this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
-        this._reattachInjector(imperativelyCreatedInjector, this._host._injector, true);
-      } else {
-        this._reattachInjector(this._injector, this._host._injector, true);
-      }
-
-      // Bootstrap
-    } else {
-      if (isPresent(imperativelyCreatedInjector)) {
-        this._reattachInjector(this._injector, imperativelyCreatedInjector, true);
-      }
-    }
-  }
-
-  private _reattachInjector(injector: Injector, parentInjector: Injector, isBoundary: boolean) {
-    injector.internalStrategy.attach(parentInjector, isBoundary);
-  }
-
-  hasVariableBinding(name: string): boolean {
-    var vb = this._proto.directiveVariableBindings;
-    return isPresent(vb) && vb.has(name);
-  }
-
-  getVariableBinding(name: string): any {
-    var index = this._proto.directiveVariableBindings.get(name);
-    return isPresent(index) ? this.getDirectiveAtIndex(<number>index) : this.getElementRef();
-  }
-
-  get(token: any): any { return this._injector.get(token); }
-
-  hasDirective(type: Type): boolean { return isPresent(this._injector.getOptional(type)); }
-
-  getEventEmitterAccessors(): EventEmitterAccessor[][] { return this._proto.eventEmitterAccessors; }
-
-  getDirectiveVariableBindings(): Map<string, number> {
-    return this._proto.directiveVariableBindings;
-  }
-
-  getComponent(): any { return this._strategy.getComponent(); }
-
-  getInjector(): Injector { return this._injector; }
-
-  getElementRef(): ElementRef { return this._preBuiltObjects.elementRef; }
-
-  getViewContainerRef(): ViewContainerRef {
-    return new ViewContainerRef_(this._preBuiltObjects.viewManager, this.getElementRef());
-  }
-
-  getNestedView(): AppView { return this._preBuiltObjects.nestedView; }
-
-  getView(): AppView { return this._preBuiltObjects.view; }
-
-  directParent(): ElementInjector { return this._proto.distanceToParent < 2 ? this.parent : null; }
-
-  isComponentKey(key: Key): boolean { return this._strategy.isComponentKey(key); }
-
-  getDependency(injector: Injector, provider: ResolvedProvider, dep: Dependency): any {
-    var key: Key = dep.key;
-
-    if (provider instanceof DirectiveProvider) {
-      var dirDep = <DirectiveDependency>dep;
-      var dirProvider = provider;
-      var staticKeys = StaticKeys.instance();
-
-
-      if (key.id === staticKeys.viewManagerId) return this._preBuiltObjects.viewManager;
-
-      if (isPresent(dirDep.attributeName)) return this._buildAttribute(dirDep);
-
-      if (isPresent(dirDep.queryDecorator))
-        return this._queryStrategy.findQuery(dirDep.queryDecorator).list;
-
-      if (dirDep.key.id === StaticKeys.instance().changeDetectorRefId) {
-        // We provide the component's view change detector to components and
-        // the surrounding component's change detector to directives.
-        if (dirProvider.metadata instanceof ComponentMetadata) {
-          var componentView = this._preBuiltObjects.view.getNestedView(
-              this._preBuiltObjects.elementRef.boundElementIndex);
-          return componentView.changeDetector.ref;
-        } else {
-          return this._preBuiltObjects.view.changeDetector.ref;
-        }
-      }
-
-      if (dirDep.key.id === StaticKeys.instance().elementRefId) {
-        return this.getElementRef();
-      }
-
-      if (dirDep.key.id === StaticKeys.instance().viewContainerId) {
-        return this.getViewContainerRef();
-      }
-
-      if (dirDep.key.id === StaticKeys.instance().templateRefId) {
-        if (isBlank(this._preBuiltObjects.templateRef)) {
-          if (dirDep.optional) {
-            return null;
-          }
-
-          throw new NoProviderError(null, dirDep.key);
-        }
-        return this._preBuiltObjects.templateRef;
-      }
-
-    } else if (provider instanceof PipeProvider) {
-      if (dep.key.id === StaticKeys.instance().changeDetectorRefId) {
-        var componentView = this._preBuiltObjects.view.getNestedView(
-            this._preBuiltObjects.elementRef.boundElementIndex);
-        return componentView.changeDetector.ref;
-      }
-    }
-
-    return UNDEFINED;
-  }
-
-  private _buildAttribute(dep: DirectiveDependency): string {
-    var attributes = this._proto.attributes;
-    if (isPresent(attributes) && attributes.has(dep.attributeName)) {
-      return attributes.get(dep.attributeName);
-    } else {
-      return null;
-    }
-  }
-
-  addDirectivesMatchingQuery(query: QueryMetadata, list: any[]): void {
-    var templateRef = isBlank(this._preBuiltObjects) ? null : this._preBuiltObjects.templateRef;
-    if (query.selector === TemplateRef && isPresent(templateRef)) {
-      list.push(templateRef);
-    }
-    this._strategy.addDirectivesMatchingQuery(query, list);
-  }
-
-  private _buildQueryStrategy(): _QueryStrategy {
-    if (this._proto.protoQueryRefs.length === 0) {
-      return _emptyQueryStrategy;
-    } else if (this._proto.protoQueryRefs.length <=
-               InlineQueryStrategy.NUMBER_OF_SUPPORTED_QUERIES) {
-      return new InlineQueryStrategy(this);
-    } else {
-      return new DynamicQueryStrategy(this);
-    }
-  }
-
-  link(parent: ElementInjector): void { parent.addChild(this); }
-
-  unlink(): void { this.remove(); }
-
-  getDirectiveAtIndex(index: number): any { return this._injector.getAt(index); }
-
-  hasInstances(): boolean { return this._proto.hasBindings && this.hydrated; }
-
-  getHost(): ElementInjector { return this._host; }
-
-  getBoundElementIndex(): number { return this._proto.index; }
-
-  getRootViewInjectors(): ElementInjector[] {
-    if (!this.hydrated) return [];
-    var view = this._preBuiltObjects.view;
-    var nestedView = view.getNestedView(view.elementOffset + this.getBoundElementIndex());
-    return isPresent(nestedView) ? nestedView.rootElementInjectors : [];
-  }
-
-  ngAfterViewChecked(): void { this._queryStrategy.updateViewQueries(); }
-
-  ngAfterContentChecked(): void { this._queryStrategy.updateContentQueries(); }
-
-  traverseAndSetQueriesAsDirty(): void {
-    var inj: ElementInjector = this;
-    while (isPresent(inj)) {
-      inj._setQueriesAsDirty();
-      inj = inj.parent;
-    }
-  }
-
-  private _setQueriesAsDirty(): void {
-    this._queryStrategy.setContentQueriesAsDirty();
-    if (isPresent(this._host)) this._host._queryStrategy.setViewQueriesAsDirty();
-  }
-}
-
-interface _QueryStrategy {
-  setContentQueriesAsDirty(): void;
-  setViewQueriesAsDirty(): void;
-  hydrate(): void;
-  dehydrate(): void;
-  updateContentQueries(): void;
-  updateViewQueries(): void;
-  findQuery(query: QueryMetadata): QueryRef;
-}
-
-class _EmptyQueryStrategy implements _QueryStrategy {
-  setContentQueriesAsDirty(): void {}
-  setViewQueriesAsDirty(): void {}
-  hydrate(): void {}
-  dehydrate(): void {}
-  updateContentQueries(): void {}
-  updateViewQueries(): void {}
-  findQuery(query: QueryMetadata): QueryRef {
-    throw new BaseException(`Cannot find query for directive ${query}.`);
-  }
-}
-
-var _emptyQueryStrategy = new _EmptyQueryStrategy();
-
-class InlineQueryStrategy implements _QueryStrategy {
-  static NUMBER_OF_SUPPORTED_QUERIES = 3;
-
-  query0: QueryRef;
-  query1: QueryRef;
-  query2: QueryRef;
-
-  constructor(ei: ElementInjector) {
-    var protoRefs = ei._proto.protoQueryRefs;
-    if (protoRefs.length > 0) this.query0 = new QueryRef(protoRefs[0], ei);
-    if (protoRefs.length > 1) this.query1 = new QueryRef(protoRefs[1], ei);
-    if (protoRefs.length > 2) this.query2 = new QueryRef(protoRefs[2], ei);
-  }
-
-  setContentQueriesAsDirty(): void {
-    if (isPresent(this.query0) && !this.query0.isViewQuery) this.query0.dirty = true;
-    if (isPresent(this.query1) && !this.query1.isViewQuery) this.query1.dirty = true;
-    if (isPresent(this.query2) && !this.query2.isViewQuery) this.query2.dirty = true;
-  }
-
-  setViewQueriesAsDirty(): void {
-    if (isPresent(this.query0) && this.query0.isViewQuery) this.query0.dirty = true;
-    if (isPresent(this.query1) && this.query1.isViewQuery) this.query1.dirty = true;
-    if (isPresent(this.query2) && this.query2.isViewQuery) this.query2.dirty = true;
-  }
-
-  hydrate(): void {
-    if (isPresent(this.query0)) this.query0.hydrate();
-    if (isPresent(this.query1)) this.query1.hydrate();
-    if (isPresent(this.query2)) this.query2.hydrate();
-  }
-
-  dehydrate(): void {
-    if (isPresent(this.query0)) this.query0.dehydrate();
-    if (isPresent(this.query1)) this.query1.dehydrate();
-    if (isPresent(this.query2)) this.query2.dehydrate();
-  }
-
-  updateContentQueries() {
-    if (isPresent(this.query0) && !this.query0.isViewQuery) {
-      this.query0.update();
-    }
-    if (isPresent(this.query1) && !this.query1.isViewQuery) {
-      this.query1.update();
-    }
-    if (isPresent(this.query2) && !this.query2.isViewQuery) {
-      this.query2.update();
-    }
-  }
-
-  updateViewQueries() {
-    if (isPresent(this.query0) && this.query0.isViewQuery) {
-      this.query0.update();
-    }
-    if (isPresent(this.query1) && this.query1.isViewQuery) {
-      this.query1.update();
-    }
-    if (isPresent(this.query2) && this.query2.isViewQuery) {
-      this.query2.update();
-    }
-  }
-
-  findQuery(query: QueryMetadata): QueryRef {
-    if (isPresent(this.query0) && this.query0.protoQueryRef.query === query) {
-      return this.query0;
-    }
-    if (isPresent(this.query1) && this.query1.protoQueryRef.query === query) {
-      return this.query1;
-    }
-    if (isPresent(this.query2) && this.query2.protoQueryRef.query === query) {
-      return this.query2;
-    }
-    throw new BaseException(`Cannot find query for directive ${query}.`);
-  }
-}
-
-class DynamicQueryStrategy implements _QueryStrategy {
-  queries: QueryRef[];
-
-  constructor(ei: ElementInjector) {
-    this.queries = ei._proto.protoQueryRefs.map(p => new QueryRef(p, ei));
-  }
-
-  setContentQueriesAsDirty(): void {
-    for (var i = 0; i < this.queries.length; ++i) {
-      var q = this.queries[i];
-      if (!q.isViewQuery) q.dirty = true;
-    }
-  }
-
-  setViewQueriesAsDirty(): void {
-    for (var i = 0; i < this.queries.length; ++i) {
-      var q = this.queries[i];
-      if (q.isViewQuery) q.dirty = true;
-    }
-  }
-
-  hydrate(): void {
-    for (var i = 0; i < this.queries.length; ++i) {
-      var q = this.queries[i];
-      q.hydrate();
-    }
-  }
-
-  dehydrate(): void {
-    for (var i = 0; i < this.queries.length; ++i) {
-      var q = this.queries[i];
-      q.dehydrate();
-    }
-  }
-
-  updateContentQueries() {
-    for (var i = 0; i < this.queries.length; ++i) {
-      var q = this.queries[i];
-      if (!q.isViewQuery) {
-        q.update();
-      }
-    }
-  }
-
-  updateViewQueries() {
-    for (var i = 0; i < this.queries.length; ++i) {
-      var q = this.queries[i];
-      if (q.isViewQuery) {
-        q.update();
-      }
-    }
-  }
-
-  findQuery(query: QueryMetadata): QueryRef {
-    for (var i = 0; i < this.queries.length; ++i) {
-      var q = this.queries[i];
-      if (q.protoQueryRef.query === query) {
-        return q;
-      }
-    }
-    throw new BaseException(`Cannot find query for directive ${query}.`);
-  }
-}
-
-interface _ElementInjectorStrategy {
-  callOnDestroy(): void;
-  getComponent(): any;
-  isComponentKey(key: Key): boolean;
-  addDirectivesMatchingQuery(q: QueryMetadata, res: any[]): void;
-  hydrate(): void;
-  dehydrate(): void;
-}
-
-/**
- * Strategy used by the `ElementInjector` when the number of providers is 10 or less.
- * In such a case, inlining fields is beneficial for performances.
- */
-class ElementInjectorInlineStrategy implements _ElementInjectorStrategy {
-  constructor(public injectorStrategy: InjectorInlineStrategy, public _ei: ElementInjector) {}
-
-  hydrate(): void {
-    var i = this.injectorStrategy;
-    var p = i.protoStrategy;
-    i.resetConstructionCounter();
-
-    if (p.provider0 instanceof DirectiveProvider && isPresent(p.keyId0) && i.obj0 === UNDEFINED)
-      i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);
-    if (p.provider1 instanceof DirectiveProvider && isPresent(p.keyId1) && i.obj1 === UNDEFINED)
-      i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);
-    if (p.provider2 instanceof DirectiveProvider && isPresent(p.keyId2) && i.obj2 === UNDEFINED)
-      i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);
-    if (p.provider3 instanceof DirectiveProvider && isPresent(p.keyId3) && i.obj3 === UNDEFINED)
-      i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);
-    if (p.provider4 instanceof DirectiveProvider && isPresent(p.keyId4) && i.obj4 === UNDEFINED)
-      i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);
-    if (p.provider5 instanceof DirectiveProvider && isPresent(p.keyId5) && i.obj5 === UNDEFINED)
-      i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);
-    if (p.provider6 instanceof DirectiveProvider && isPresent(p.keyId6) && i.obj6 === UNDEFINED)
-      i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);
-    if (p.provider7 instanceof DirectiveProvider && isPresent(p.keyId7) && i.obj7 === UNDEFINED)
-      i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);
-    if (p.provider8 instanceof DirectiveProvider && isPresent(p.keyId8) && i.obj8 === UNDEFINED)
-      i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);
-    if (p.provider9 instanceof DirectiveProvider && isPresent(p.keyId9) && i.obj9 === UNDEFINED)
-      i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);
-  }
-
-  dehydrate() {
-    var i = this.injectorStrategy;
-
-    i.obj0 = UNDEFINED;
-    i.obj1 = UNDEFINED;
-    i.obj2 = UNDEFINED;
-    i.obj3 = UNDEFINED;
-    i.obj4 = UNDEFINED;
-    i.obj5 = UNDEFINED;
-    i.obj6 = UNDEFINED;
-    i.obj7 = UNDEFINED;
-    i.obj8 = UNDEFINED;
-    i.obj9 = UNDEFINED;
-  }
-
-  callOnDestroy(): void {
-    var i = this.injectorStrategy;
-    var p = i.protoStrategy;
-
-    if (p.provider0 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider0).callOnDestroy) {
-      i.obj0.ngOnDestroy();
-    }
-    if (p.provider1 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider1).callOnDestroy) {
-      i.obj1.ngOnDestroy();
-    }
-    if (p.provider2 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider2).callOnDestroy) {
-      i.obj2.ngOnDestroy();
-    }
-    if (p.provider3 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider3).callOnDestroy) {
-      i.obj3.ngOnDestroy();
-    }
-    if (p.provider4 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider4).callOnDestroy) {
-      i.obj4.ngOnDestroy();
-    }
-    if (p.provider5 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider5).callOnDestroy) {
-      i.obj5.ngOnDestroy();
-    }
-    if (p.provider6 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider6).callOnDestroy) {
-      i.obj6.ngOnDestroy();
-    }
-    if (p.provider7 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider7).callOnDestroy) {
-      i.obj7.ngOnDestroy();
-    }
-    if (p.provider8 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider8).callOnDestroy) {
-      i.obj8.ngOnDestroy();
-    }
-    if (p.provider9 instanceof DirectiveProvider &&
-        (<DirectiveProvider>p.provider9).callOnDestroy) {
-      i.obj9.ngOnDestroy();
-    }
-  }
-
-  getComponent(): any { return this.injectorStrategy.obj0; }
-
-  isComponentKey(key: Key): boolean {
-    return this._ei._proto._firstProviderIsComponent && isPresent(key) &&
-           key.id === this.injectorStrategy.protoStrategy.keyId0;
-  }
-
-  addDirectivesMatchingQuery(query: QueryMetadata, list: any[]): void {
-    var i = this.injectorStrategy;
-    var p = i.protoStrategy;
-
-    if (isPresent(p.provider0) && p.provider0.key.token === query.selector) {
-      if (i.obj0 === UNDEFINED) i.obj0 = i.instantiateProvider(p.provider0, p.visibility0);
-      list.push(i.obj0);
-    }
-    if (isPresent(p.provider1) && p.provider1.key.token === query.selector) {
-      if (i.obj1 === UNDEFINED) i.obj1 = i.instantiateProvider(p.provider1, p.visibility1);
-      list.push(i.obj1);
-    }
-    if (isPresent(p.provider2) && p.provider2.key.token === query.selector) {
-      if (i.obj2 === UNDEFINED) i.obj2 = i.instantiateProvider(p.provider2, p.visibility2);
-      list.push(i.obj2);
-    }
-    if (isPresent(p.provider3) && p.provider3.key.token === query.selector) {
-      if (i.obj3 === UNDEFINED) i.obj3 = i.instantiateProvider(p.provider3, p.visibility3);
-      list.push(i.obj3);
-    }
-    if (isPresent(p.provider4) && p.provider4.key.token === query.selector) {
-      if (i.obj4 === UNDEFINED) i.obj4 = i.instantiateProvider(p.provider4, p.visibility4);
-      list.push(i.obj4);
-    }
-    if (isPresent(p.provider5) && p.provider5.key.token === query.selector) {
-      if (i.obj5 === UNDEFINED) i.obj5 = i.instantiateProvider(p.provider5, p.visibility5);
-      list.push(i.obj5);
-    }
-    if (isPresent(p.provider6) && p.provider6.key.token === query.selector) {
-      if (i.obj6 === UNDEFINED) i.obj6 = i.instantiateProvider(p.provider6, p.visibility6);
-      list.push(i.obj6);
-    }
-    if (isPresent(p.provider7) && p.provider7.key.token === query.selector) {
-      if (i.obj7 === UNDEFINED) i.obj7 = i.instantiateProvider(p.provider7, p.visibility7);
-      list.push(i.obj7);
-    }
-    if (isPresent(p.provider8) && p.provider8.key.token === query.selector) {
-      if (i.obj8 === UNDEFINED) i.obj8 = i.instantiateProvider(p.provider8, p.visibility8);
-      list.push(i.obj8);
-    }
-    if (isPresent(p.provider9) && p.provider9.key.token === query.selector) {
-      if (i.obj9 === UNDEFINED) i.obj9 = i.instantiateProvider(p.provider9, p.visibility9);
-      list.push(i.obj9);
-    }
-  }
-}
-
-/**
- * Strategy used by the `ElementInjector` when the number of bindings is 11 or more.
- * In such a case, there are too many fields to inline (see ElementInjectorInlineStrategy).
- */
-class ElementInjectorDynamicStrategy implements _ElementInjectorStrategy {
-  constructor(public injectorStrategy: InjectorDynamicStrategy, public _ei: ElementInjector) {}
-
-  hydrate(): void {
-    var inj = this.injectorStrategy;
-    var p = inj.protoStrategy;
-    inj.resetConstructionCounter();
-
-    for (var i = 0; i < p.keyIds.length; i++) {
-      if (p.providers[i] instanceof DirectiveProvider && isPresent(p.keyIds[i]) &&
-          inj.objs[i] === UNDEFINED) {
-        inj.objs[i] = inj.instantiateProvider(p.providers[i], p.visibilities[i]);
-      }
-    }
-  }
-
-  dehydrate(): void {
-    var inj = this.injectorStrategy;
-    ListWrapper.fill(inj.objs, UNDEFINED);
-  }
-
-  callOnDestroy(): void {
-    var ist = this.injectorStrategy;
-    var p = ist.protoStrategy;
-
-    for (var i = 0; i < p.providers.length; i++) {
-      if (p.providers[i] instanceof DirectiveProvider &&
-          (<DirectiveProvider>p.providers[i]).callOnDestroy) {
-        ist.objs[i].ngOnDestroy();
-      }
-    }
-  }
-
-  getComponent(): any { return this.injectorStrategy.objs[0]; }
-
-  isComponentKey(key: Key): boolean {
-    var p = this.injectorStrategy.protoStrategy;
-    return this._ei._proto._firstProviderIsComponent && isPresent(key) && key.id === p.keyIds[0];
-  }
-
-  addDirectivesMatchingQuery(query: QueryMetadata, list: any[]): void {
-    var ist = this.injectorStrategy;
-    var p = ist.protoStrategy;
-
-    for (var i = 0; i < p.providers.length; i++) {
-      if (p.providers[i].key.token === query.selector) {
-        if (ist.objs[i] === UNDEFINED) {
-          ist.objs[i] = ist.instantiateProvider(p.providers[i], p.visibilities[i]);
-        }
-        list.push(ist.objs[i]);
-      }
-    }
-  }
-}
-
-export class ProtoQueryRef {
-  constructor(public dirIndex: number, public setter: SetterFn, public query: QueryMetadata) {}
-
-  get usesPropertySyntax(): boolean { return isPresent(this.setter); }
-}
-
-export class QueryRef {
-  public list: QueryList<any>;
-  public dirty: boolean;
-
-  constructor(public protoQueryRef: ProtoQueryRef, private originator: ElementInjector) {}
-
-  get isViewQuery(): boolean { return this.protoQueryRef.query.isViewQuery; }
-
-  update(): void {
-    if (!this.dirty) return;
-    this._update();
-    this.dirty = false;
-
-    // TODO delete the check once only field queries are supported
-    if (this.protoQueryRef.usesPropertySyntax) {
-      var dir = this.originator.getDirectiveAtIndex(this.protoQueryRef.dirIndex);
-      if (this.protoQueryRef.query.first) {
-        this.protoQueryRef.setter(dir, this.list.length > 0 ? this.list.first : null);
-      } else {
-        this.protoQueryRef.setter(dir, this.list);
-      }
-    }
-
-    this.list.notifyOnChanges();
-  }
-
-  private _update(): void {
-    var aggregator = [];
-    if (this.protoQueryRef.query.isViewQuery) {
-      var view = this.originator.getView();
-      // intentionally skipping originator for view queries.
-      var nestedView =
-          view.getNestedView(view.elementOffset + this.originator.getBoundElementIndex());
-      if (isPresent(nestedView)) this._visitView(nestedView, aggregator);
-    } else {
-      this._visit(this.originator, aggregator);
-    }
-    this.list.reset(aggregator);
-  };
-
-  private _visit(inj: ElementInjector, aggregator: any[]): void {
-    var view = inj.getView();
-    var startIdx = view.elementOffset + inj._proto.index;
-    for (var i = startIdx; i < view.elementOffset + view.ownBindersCount; i++) {
-      var curInj = view.elementInjectors[i];
-      if (isBlank(curInj)) continue;
-      // The first injector after inj, that is outside the subtree rooted at
-      // inj has to have a null parent or a parent that is an ancestor of inj.
-      if (i > startIdx && (isBlank(curInj) || isBlank(curInj.parent) ||
-                           view.elementOffset + curInj.parent._proto.index < startIdx)) {
-        break;
-      }
-
-      if (!this.protoQueryRef.query.descendants &&
-          !(curInj.parent == this.originator || curInj == this.originator))
-        continue;
-
-      // We visit the view container(VC) views right after the injector that contains
-      // the VC. Theoretically, that might not be the right order if there are
-      // child injectors of said injector. Not clear whether if such case can
-      // even be constructed with the current apis.
-      this._visitInjector(curInj, aggregator);
-      var vc = view.viewContainers[i];
-      if (isPresent(vc)) this._visitViewContainer(vc, aggregator);
-    }
-  }
-
-  private _visitInjector(inj: ElementInjector, aggregator: any[]) {
-    if (this.protoQueryRef.query.isVarBindingQuery) {
-      this._aggregateVariableBinding(inj, aggregator);
-    } else {
-      this._aggregateDirective(inj, aggregator);
-    }
-  }
-
-  private _visitViewContainer(vc: AppViewContainer, aggregator: any[]) {
-    for (var j = 0; j < vc.views.length; j++) {
-      this._visitView(vc.views[j], aggregator);
-    }
-  }
-
-  private _visitView(view: AppView, aggregator: any[]) {
-    for (var i = view.elementOffset; i < view.elementOffset + view.ownBindersCount; i++) {
-      var inj = view.elementInjectors[i];
-      if (isBlank(inj)) continue;
-
-      this._visitInjector(inj, aggregator);
-
-      var vc = view.viewContainers[i];
-      if (isPresent(vc)) this._visitViewContainer(vc, aggregator);
-    }
-  }
-
-  private _aggregateVariableBinding(inj: ElementInjector, aggregator: any[]): void {
-    var vb = this.protoQueryRef.query.varBindings;
-    for (var i = 0; i < vb.length; ++i) {
-      if (inj.hasVariableBinding(vb[i])) {
-        aggregator.push(inj.getVariableBinding(vb[i]));
-      }
-    }
-  }
-
-  private _aggregateDirective(inj: ElementInjector, aggregator: any[]): void {
-    inj.addDirectivesMatchingQuery(this.protoQueryRef.query, aggregator);
-  }
-
-  dehydrate(): void { this.list = null; }
-
-  hydrate(): void {
-    this.list = new QueryList<any>();
-    this.dirty = true;
-  }
-}
diff --git a/modules/angular2/src/core/linker/element_ref.ts b/modules/angular2/src/core/linker/element_ref.ts
index 810fce8..a052fb8 100644
--- a/modules/angular2/src/core/linker/element_ref.ts
+++ b/modules/angular2/src/core/linker/element_ref.ts
@@ -1,6 +1,5 @@
-import {BaseException, unimplemented} from 'angular2/src/facade/exceptions';
-import {ViewRef, ViewRef_} from './view_ref';
-import {RenderViewRef, RenderElementRef, Renderer} from 'angular2/src/core/render/api';
+import {unimplemented} from 'angular2/src/facade/exceptions';
+import {AppElement} from './element';
 
 /**
  * Represents a location in a View that has an injection, change-detection and render context
@@ -12,23 +11,7 @@ import {RenderViewRef, RenderElementRef, Renderer} from 'angular2/src/core/rende
  * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
  * element.
  */
-export abstract class ElementRef implements RenderElementRef {
-  /**
-   * @internal
-   *
-   * Reference to the {@link ViewRef} that this `ElementRef` is part of.
-   */
-  parentView: ViewRef;
-
-  /**
-   * @internal
-   *
-   * Index of the element inside the {@link ViewRef}.
-   *
-   * This is used internally by the Angular framework to locate elements.
-   */
-  boundElementIndex: number;
-
+export abstract class ElementRef {
   /**
    * The underlying native element or `null` if direct access to native elements is not supported
    * (e.g. when the application runs in a web worker).
@@ -48,24 +31,13 @@ export abstract class ElementRef implements RenderElementRef {
    *   </p>
    * </div>
    */
-  get nativeElement(): any { return unimplemented(); };
-
-  get renderView(): RenderViewRef { return unimplemented(); }
+  get nativeElement(): any { return unimplemented(); }
 }
 
-export class ElementRef_ extends ElementRef {
-  constructor(public parentView: ViewRef,
+export class ElementRef_ implements ElementRef {
+  constructor(private _appElement: AppElement) {}
 
-              /**
-               * Index of the element inside the {@link ViewRef}.
-               *
-               * This is used internally by the Angular framework to locate elements.
-               */
-              public boundElementIndex: number, private _renderer: Renderer) {
-    super();
-  }
+  get internalElement(): AppElement { return this._appElement; }
 
-  get renderView(): RenderViewRef { return (<ViewRef_>this.parentView).render; }
-  set renderView(value) { unimplemented(); }
-  get nativeElement(): any { return this._renderer.getNativeElementSync(this); }
+  get nativeElement() { return this._appElement.nativeElement; }
 }
diff --git a/modules/angular2/src/core/linker/event_config.ts b/modules/angular2/src/core/linker/event_config.ts
deleted file mode 100644
index fdbcf2b..0000000
--- a/modules/angular2/src/core/linker/event_config.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-export const EVENT_TARGET_SEPARATOR = ':';
-
-export class EventConfig {
-  constructor(public fieldName: string, public eventName: string, public isLongForm: boolean) {}
-
-  static parse(eventConfig: string): EventConfig {
-    var fieldName = eventConfig, eventName = eventConfig, isLongForm = false;
-    var separatorIdx = eventConfig.indexOf(EVENT_TARGET_SEPARATOR);
-    if (separatorIdx > -1) {
-      // long format: 'fieldName: eventName'
-      fieldName = eventConfig.substring(0, separatorIdx).trim();
-      eventName = eventConfig.substring(separatorIdx + 1).trim();
-      isLongForm = true;
-    }
-    return new EventConfig(fieldName, eventName, isLongForm);
-  }
-
-  getFullName(): string {
-    return this.isLongForm ? `${this.fieldName}${EVENT_TARGET_SEPARATOR}${this.eventName}` :
-                             this.eventName;
-  }
-}
diff --git a/modules/angular2/src/core/linker/pipe_resolver.ts b/modules/angular2/src/core/linker/pipe_resolver.ts
index 6768397..3de7a3f 100644
--- a/modules/angular2/src/core/linker/pipe_resolver.ts
+++ b/modules/angular2/src/core/linker/pipe_resolver.ts
@@ -31,3 +31,5 @@ export class PipeResolver {
     throw new BaseException(`No Pipe decorator found on ${stringify(type)}`);
   }
 }
+
+export var CODEGEN_PIPE_RESOLVER = new PipeResolver();
diff --git a/modules/angular2/src/core/linker/proto_view_factory.ts b/modules/angular2/src/core/linker/proto_view_factory.ts
deleted file mode 100644
index 30216a4..0000000
--- a/modules/angular2/src/core/linker/proto_view_factory.ts
+++ /dev/null
@@ -1,341 +0,0 @@
-import {isPresent, isBlank, Type, isArray, isNumber} from 'angular2/src/facade/lang';
-
-import {RenderProtoViewRef, RenderComponentTemplate} from 'angular2/src/core/render/api';
-
-import {Optional, Injectable, Provider, resolveForwardRef, Inject} from 'angular2/src/core/di';
-
-import {PipeProvider} from '../pipes/pipe_provider';
-import {ProtoPipes} from '../pipes/pipes';
-
-import {AppProtoView, AppProtoViewMergeInfo, ViewType} from './view';
-import {ElementBinder} from './element_binder';
-import {ProtoElementInjector, DirectiveProvider} from './element_injector';
-import {DirectiveResolver} from './directive_resolver';
-import {ViewResolver} from './view_resolver';
-import {PipeResolver} from './pipe_resolver';
-import {ViewMetadata, ViewEncapsulation} from '../metadata/view';
-import {PLATFORM_PIPES} from 'angular2/src/core/platform_directives_and_pipes';
-
-import {
-  visitAllCommands,
-  CompiledComponentTemplate,
-  CompiledHostTemplate,
-  TemplateCmd,
-  CommandVisitor,
-  EmbeddedTemplateCmd,
-  BeginComponentCmd,
-  BeginElementCmd,
-  IBeginElementCmd,
-  TextCmd,
-  NgContentCmd
-} from './template_commands';
-
-import {Renderer} from 'angular2/src/core/render/api';
-import {APP_ID} from 'angular2/src/core/application_tokens';
-
-
-@Injectable()
-export class ProtoViewFactory {
-  private _cache: Map<string, AppProtoView> = new Map<string, AppProtoView>();
-  private _nextTemplateId: number = 0;
-
-  constructor(private _renderer: Renderer,
-              @Optional() @Inject(PLATFORM_PIPES) private _platformPipes: Array<Type | any[]>,
-              private _directiveResolver: DirectiveResolver, private _viewResolver: ViewResolver,
-              private _pipeResolver: PipeResolver, @Inject(APP_ID) private _appId: string) {}
-
-  clearCache() { this._cache.clear(); }
-
-  createHost(compiledHostTemplate: CompiledHostTemplate): AppProtoView {
-    var compiledTemplate = compiledHostTemplate.template;
-    var result = this._cache.get(compiledTemplate.id);
-    if (isBlank(result)) {
-      var emptyMap: {[key: string]: PipeProvider} = {};
-      var shortId = `${this._appId}-${this._nextTemplateId++}`;
-      this._renderer.registerComponentTemplate(new RenderComponentTemplate(
-          compiledTemplate.id, shortId, ViewEncapsulation.None, compiledTemplate.commands, []));
-      result =
-          new AppProtoView(compiledTemplate.id, compiledTemplate.commands, ViewType.HOST, true,
-                           compiledTemplate.changeDetectorFactory, null, new ProtoPipes(emptyMap));
-      this._cache.set(compiledTemplate.id, result);
-    }
-    return result;
-  }
-
-  private _createComponent(cmd: BeginComponentCmd): AppProtoView {
-    var nestedProtoView = this._cache.get(cmd.templateId);
-    if (isBlank(nestedProtoView)) {
-      var component = cmd.directives[0];
-      var view = this._viewResolver.resolve(component);
-      var compiledTemplate = cmd.templateGetter();
-      var styles = _flattenStyleArr(compiledTemplate.styles, []);
-      var shortId = `${this._appId}-${this._nextTemplateId++}`;
-      this._renderer.registerComponentTemplate(new RenderComponentTemplate(
-          compiledTemplate.id, shortId, cmd.encapsulation, compiledTemplate.commands, styles));
-      var boundPipes = this._flattenPipes(view).map(pipe => this._bindPipe(pipe));
-
-      nestedProtoView = new AppProtoView(
-          compiledTemplate.id, compiledTemplate.commands, ViewType.COMPONENT, true,
-          compiledTemplate.changeDetectorFactory, null, ProtoPipes.fromProviders(boundPipes));
-      // Note: The cache is updated before recursing
-      // to be able to resolve cycles
-      this._cache.set(compiledTemplate.id, nestedProtoView);
-      this._initializeProtoView(nestedProtoView, null);
-    }
-    return nestedProtoView;
-  }
-
-  private _createEmbeddedTemplate(cmd: EmbeddedTemplateCmd, parent: AppProtoView): AppProtoView {
-    var nestedProtoView = new AppProtoView(
-        parent.templateId, cmd.children, ViewType.EMBEDDED, cmd.isMerged, cmd.changeDetectorFactory,
-        arrayToMap(cmd.variableNameAndValues, true), new ProtoPipes(parent.pipes.config));
-    if (cmd.isMerged) {
-      this.initializeProtoViewIfNeeded(nestedProtoView);
-    }
-    return nestedProtoView;
-  }
-
-  initializeProtoViewIfNeeded(protoView: AppProtoView) {
-    if (!protoView.isInitialized()) {
-      var render = this._renderer.createProtoView(protoView.templateId, protoView.templateCmds);
-      this._initializeProtoView(protoView, render);
-    }
-  }
-
-  private _initializeProtoView(protoView: AppProtoView, render: RenderProtoViewRef) {
-    var initializer = new _ProtoViewInitializer(protoView, this._directiveResolver, this);
-    visitAllCommands(initializer, protoView.templateCmds);
-    var mergeInfo =
-        new AppProtoViewMergeInfo(initializer.mergeEmbeddedViewCount, initializer.mergeElementCount,
-                                  initializer.mergeViewCount);
-    protoView.init(render, initializer.elementBinders, initializer.boundTextCount, mergeInfo,
-                   initializer.variableLocations);
-  }
-
-  private _bindPipe(typeOrProvider): PipeProvider {
-    let meta = this._pipeResolver.resolve(typeOrProvider);
-    return PipeProvider.createFromType(typeOrProvider, meta);
-  }
-
-  private _flattenPipes(view: ViewMetadata): any[] {
-    let pipes = [];
-    if (isPresent(this._platformPipes)) {
-      _flattenArray(this._platformPipes, pipes);
-    }
-    if (isPresent(view.pipes)) {
-      _flattenArray(view.pipes, pipes);
-    }
-    return pipes;
-  }
-}
-
-
-function createComponent(protoViewFactory: ProtoViewFactory, cmd: BeginComponentCmd): AppProtoView {
-  return (<any>protoViewFactory)._createComponent(cmd);
-}
-
-function createEmbeddedTemplate(protoViewFactory: ProtoViewFactory, cmd: EmbeddedTemplateCmd,
-                                parent: AppProtoView): AppProtoView {
-  return (<any>protoViewFactory)._createEmbeddedTemplate(cmd, parent);
-}
-
-class _ProtoViewInitializer implements CommandVisitor {
-  variableLocations: Map<string, number> = new Map<string, number>();
-  boundTextCount: number = 0;
-  boundElementIndex: number = 0;
-  elementBinderStack: ElementBinder[] = [];
-  distanceToParentElementBinder: number = 0;
-  distanceToParentProtoElementInjector: number = 0;
-  elementBinders: ElementBinder[] = [];
-  mergeEmbeddedViewCount: number = 0;
-  mergeElementCount: number = 0;
-  mergeViewCount: number = 1;
-
-  constructor(private _protoView: AppProtoView, private _directiveResolver: DirectiveResolver,
-              private _protoViewFactory: ProtoViewFactory) {}
-
-  visitText(cmd: TextCmd, context: any): any {
-    if (cmd.isBound) {
-      this.boundTextCount++;
-    }
-    return null;
-  }
-  visitNgContent(cmd: NgContentCmd, context: any): any { return null; }
-  visitBeginElement(cmd: BeginElementCmd, context: any): any {
-    if (cmd.isBound) {
-      this._visitBeginBoundElement(cmd, null);
-    } else {
-      this._visitBeginElement(cmd, null, null);
-    }
-    return null;
-  }
-  visitEndElement(context: any): any { return this._visitEndElement(); }
-  visitBeginComponent(cmd: BeginComponentCmd, context: any): any {
-    var nestedProtoView = createComponent(this._protoViewFactory, cmd);
-    return this._visitBeginBoundElement(cmd, nestedProtoView);
-  }
-  visitEndComponent(context: any): any { return this._visitEndElement(); }
-  visitEmbeddedTemplate(cmd: EmbeddedTemplateCmd, context: any): any {
-    var nestedProtoView = createEmbeddedTemplate(this._protoViewFactory, cmd, this._protoView);
-    if (cmd.isMerged) {
-      this.mergeEmbeddedViewCount++;
-    }
-    this._visitBeginBoundElement(cmd, nestedProtoView);
-    return this._visitEndElement();
-  }
-
-  private _visitBeginBoundElement(cmd: IBeginElementCmd, nestedProtoView: AppProtoView): any {
-    if (isPresent(nestedProtoView) && nestedProtoView.isMergable) {
-      this.mergeElementCount += nestedProtoView.mergeInfo.elementCount;
-      this.mergeViewCount += nestedProtoView.mergeInfo.viewCount;
-      this.mergeEmbeddedViewCount += nestedProtoView.mergeInfo.embeddedViewCount;
-    }
-    var elementBinder = _createElementBinder(
-        this._directiveResolver, nestedProtoView, this.elementBinderStack, this.boundElementIndex,
-        this.distanceToParentElementBinder, this.distanceToParentProtoElementInjector, cmd);
-    this.elementBinders.push(elementBinder);
-    var protoElementInjector = elementBinder.protoElementInjector;
-    for (var i = 0; i < cmd.variableNameAndValues.length; i += 2) {
-      this.variableLocations.set(<string>cmd.variableNameAndValues[i], this.boundElementIndex);
-    }
-    this.boundElementIndex++;
-    this.mergeElementCount++;
-    return this._visitBeginElement(cmd, elementBinder, protoElementInjector);
-  }
-
-  private _visitBeginElement(cmd: IBeginElementCmd, elementBinder: ElementBinder,
-                             protoElementInjector: ProtoElementInjector): any {
-    this.distanceToParentElementBinder =
-        isPresent(elementBinder) ? 1 : this.distanceToParentElementBinder + 1;
-    this.distanceToParentProtoElementInjector =
-        isPresent(protoElementInjector) ? 1 : this.distanceToParentProtoElementInjector + 1;
-    this.elementBinderStack.push(elementBinder);
-    return null;
-  }
-
-  private _visitEndElement(): any {
-    var parentElementBinder = this.elementBinderStack.pop();
-    var parentProtoElementInjector =
-        isPresent(parentElementBinder) ? parentElementBinder.protoElementInjector : null;
-    this.distanceToParentElementBinder = isPresent(parentElementBinder) ?
-                                             parentElementBinder.distanceToParent :
-                                             this.distanceToParentElementBinder - 1;
-    this.distanceToParentProtoElementInjector = isPresent(parentProtoElementInjector) ?
-                                                    parentProtoElementInjector.distanceToParent :
-                                                    this.distanceToParentProtoElementInjector - 1;
-    return null;
-  }
-}
-
-
-function _createElementBinder(directiveResolver: DirectiveResolver, nestedProtoView: AppProtoView,
-                              elementBinderStack: ElementBinder[], boundElementIndex: number,
-                              distanceToParentBinder: number, distanceToParentPei: number,
-                              beginElementCmd: IBeginElementCmd): ElementBinder {
-  var parentElementBinder: ElementBinder = null;
-  var parentProtoElementInjector: ProtoElementInjector = null;
-  if (distanceToParentBinder > 0) {
-    parentElementBinder = elementBinderStack[elementBinderStack.length - distanceToParentBinder];
-  }
-  if (isBlank(parentElementBinder)) {
-    distanceToParentBinder = -1;
-  }
-  if (distanceToParentPei > 0) {
-    var peiBinder = elementBinderStack[elementBinderStack.length - distanceToParentPei];
-    if (isPresent(peiBinder)) {
-      parentProtoElementInjector = peiBinder.protoElementInjector;
-    }
-  }
-  if (isBlank(parentProtoElementInjector)) {
-    distanceToParentPei = -1;
-  }
-  var componentDirectiveProvider: DirectiveProvider = null;
-  var isEmbeddedTemplate = false;
-  var directiveProviders: DirectiveProvider[] =
-      beginElementCmd.directives.map(type => provideDirective(directiveResolver, type));
-  if (beginElementCmd instanceof BeginComponentCmd) {
-    componentDirectiveProvider = directiveProviders[0];
-  } else if (beginElementCmd instanceof EmbeddedTemplateCmd) {
-    isEmbeddedTemplate = true;
-  }
-
-  var protoElementInjector = null;
-  // Create a protoElementInjector for any element that either has bindings *or* has one
-  // or more var- defined *or* for <template> elements:
-  // - Elements with a var- defined need a their own element injector
-  //   so that, when hydrating, $implicit can be set to the element.
-  // - <template> elements need their own ElementInjector so that we can query their TemplateRef
-  var hasVariables = beginElementCmd.variableNameAndValues.length > 0;
-  if (directiveProviders.length > 0 || hasVariables || isEmbeddedTemplate) {
-    var directiveVariableBindings = new Map<string, number>();
-    if (!isEmbeddedTemplate) {
-      directiveVariableBindings = createDirectiveVariableBindings(
-          beginElementCmd.variableNameAndValues, directiveProviders);
-    }
-    protoElementInjector = ProtoElementInjector.create(
-        parentProtoElementInjector, boundElementIndex, directiveProviders,
-        isPresent(componentDirectiveProvider), distanceToParentPei, directiveVariableBindings);
-    protoElementInjector.attributes = arrayToMap(beginElementCmd.attrNameAndValues, false);
-  }
-
-  return new ElementBinder(boundElementIndex, parentElementBinder, distanceToParentBinder,
-                           protoElementInjector, componentDirectiveProvider, nestedProtoView);
-}
-
-function provideDirective(directiveResolver: DirectiveResolver, type: Type): DirectiveProvider {
-  let annotation = directiveResolver.resolve(type);
-  return DirectiveProvider.createFromType(type, annotation);
-}
-
-export function createDirectiveVariableBindings(
-    variableNameAndValues: Array<string | number>,
-    directiveProviders: DirectiveProvider[]): Map<string, number> {
-  var directiveVariableBindings = new Map<string, number>();
-  for (var i = 0; i < variableNameAndValues.length; i += 2) {
-    var templateName = <string>variableNameAndValues[i];
-    var dirIndex = <number>variableNameAndValues[i + 1];
-    if (isNumber(dirIndex)) {
-      directiveVariableBindings.set(templateName, dirIndex);
-    } else {
-      // a variable without a directive index -> reference the element
-      directiveVariableBindings.set(templateName, null);
-    }
-  }
-  return directiveVariableBindings;
-}
-
-
-function arrayToMap(arr: string[], inverse: boolean): Map<string, string> {
-  var result = new Map<string, string>();
-  for (var i = 0; i < arr.length; i += 2) {
-    if (inverse) {
-      result.set(arr[i + 1], arr[i]);
-    } else {
-      result.set(arr[i], arr[i + 1]);
-    }
-  }
-  return result;
-}
-
-function _flattenArray(tree: any[], out: Array<Type | Provider | any[]>): void {
-  for (var i = 0; i < tree.length; i++) {
-    var item = resolveForwardRef(tree[i]);
-    if (isArray(item)) {
-      _flattenArray(item, out);
-    } else {
-      out.push(item);
-    }
-  }
-}
-
-function _flattenStyleArr(arr: Array<string | any[]>, out: string[]): string[] {
-  for (var i = 0; i < arr.length; i++) {
-    var entry = arr[i];
-    if (isArray(entry)) {
-      _flattenStyleArr(<any[]>entry, out);
-    } else {
-      out.push(<string>entry);
-    }
-  }
-  return out;
-}
diff --git a/modules/angular2/src/core/linker/resolved_metadata_cache.ts b/modules/angular2/src/core/linker/resolved_metadata_cache.ts
new file mode 100644
index 0000000..370c200
--- /dev/null
+++ b/modules/angular2/src/core/linker/resolved_metadata_cache.ts
@@ -0,0 +1,35 @@
+import {Injectable} from '../di';
+import {Type, isBlank} from 'angular2/src/facade/lang';
+import {DirectiveProvider} from './element';
+import {DirectiveResolver, CODEGEN_DIRECTIVE_RESOLVER} from './directive_resolver';
+import {PipeProvider} from '../pipes/pipe_provider';
+import {PipeResolver, CODEGEN_PIPE_RESOLVER} from './pipe_resolver';
+
+@Injectable()
+export class ResolvedMetadataCache {
+  private _directiveCache: Map<Type, DirectiveProvider> = new Map<Type, DirectiveProvider>();
+  private _pipeCache: Map<Type, PipeProvider> = new Map<Type, PipeProvider>();
+
+  constructor(private _directiveResolver: DirectiveResolver, private _pipeResolver: PipeResolver) {}
+
+  getResolvedDirectiveMetadata(type: Type): DirectiveProvider {
+    var result = this._directiveCache.get(type);
+    if (isBlank(result)) {
+      result = DirectiveProvider.createFromType(type, this._directiveResolver.resolve(type));
+      this._directiveCache.set(type, result);
+    }
+    return result;
+  }
+
+  getResolvedPipeMetadata(type: Type): PipeProvider {
+    var result = this._pipeCache.get(type);
+    if (isBlank(result)) {
+      result = PipeProvider.createFromType(type, this._pipeResolver.resolve(type));
+      this._pipeCache.set(type, result);
+    }
+    return result;
+  }
+}
+
+export var CODEGEN_RESOLVED_METADATA_CACHE =
+    new ResolvedMetadataCache(CODEGEN_DIRECTIVE_RESOLVER, CODEGEN_PIPE_RESOLVER);
diff --git a/modules/angular2/src/core/linker/template_commands.ts b/modules/angular2/src/core/linker/template_commands.ts
deleted file mode 100644
index 20d32cb..0000000
--- a/modules/angular2/src/core/linker/template_commands.ts
+++ /dev/null
@@ -1,141 +0,0 @@
-import {Type, CONST_EXPR, CONST, isPresent, isBlank} from 'angular2/src/facade/lang';
-import {unimplemented} from 'angular2/src/facade/exceptions';
-import {
-  RenderTemplateCmd,
-  RenderCommandVisitor,
-  RenderBeginElementCmd,
-  RenderTextCmd,
-  RenderNgContentCmd,
-  RenderBeginComponentCmd,
-  RenderEmbeddedTemplateCmd
-} from 'angular2/src/core/render/api';
-import {ViewEncapsulation} from 'angular2/src/core/metadata';
-// Export ViewEncapsulation so that compiled templates only need to depend
-// on template_commands.
-export {ViewEncapsulation} from 'angular2/src/core/metadata';
-
-/**
- * A compiled host template.
- *
- * This is const as we are storing it as annotation
- * for the compiled component type.
- */
-@CONST()
-export class CompiledHostTemplate {
-  constructor(public template: CompiledComponentTemplate) {}
-}
-
-/**
- * A compiled template.
- */
-@CONST()
-export class CompiledComponentTemplate {
-  constructor(public id: string, public changeDetectorFactory: Function,
-              public commands: TemplateCmd[], public styles: string[]) {}
-}
-
-const EMPTY_ARR = CONST_EXPR([]);
-
-export interface TemplateCmd extends RenderTemplateCmd {
-  visit(visitor: RenderCommandVisitor, context: any): any;
-}
-
-@CONST()
-export class TextCmd implements TemplateCmd, RenderTextCmd {
-  constructor(public value: string, public isBound: boolean, public ngContentIndex: number) {}
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitText(this, context);
-  }
-}
-
-@CONST()
-export class NgContentCmd implements TemplateCmd, RenderNgContentCmd {
-  isBound: boolean = false;
-  constructor(public index: number, public ngContentIndex: number) {}
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitNgContent(this, context);
-  }
-}
-
-export abstract class IBeginElementCmd extends RenderBeginElementCmd implements TemplateCmd {
-  get variableNameAndValues(): Array<string | number> { return unimplemented(); }
-  get eventTargetAndNames(): string[] { return unimplemented(); }
-  get directives(): Type[] { return unimplemented(); }
-  abstract visit(visitor: RenderCommandVisitor, context: any): any;
-}
-
-@CONST()
-export class BeginElementCmd implements TemplateCmd, IBeginElementCmd, RenderBeginElementCmd {
-  constructor(public name: string, public attrNameAndValues: string[],
-              public eventTargetAndNames: string[],
-              public variableNameAndValues: Array<string | number>, public directives: Type[],
-              public isBound: boolean, public ngContentIndex: number) {}
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitBeginElement(this, context);
-  }
-}
-
-
-@CONST()
-export class EndElementCmd implements TemplateCmd {
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitEndElement(context);
-  }
-}
-
-@CONST()
-export class BeginComponentCmd implements TemplateCmd, IBeginElementCmd, RenderBeginComponentCmd {
-  isBound: boolean = true;
-  constructor(public name: string, public attrNameAndValues: string[],
-              public eventTargetAndNames: string[],
-              public variableNameAndValues: Array<string | number>, public directives: Type[],
-              public encapsulation: ViewEncapsulation, public ngContentIndex: number,
-              // Note: the template needs to be stored as a function
-              // so that we can resolve cycles
-              public templateGetter: Function /*() => CompiledComponentTemplate*/) {}
-
-  get templateId(): string { return this.templateGetter().id; }
-
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitBeginComponent(this, context);
-  }
-}
-
-@CONST()
-export class EndComponentCmd implements TemplateCmd {
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitEndComponent(context);
-  }
-}
-
-@CONST()
-export class EmbeddedTemplateCmd implements TemplateCmd, IBeginElementCmd,
-    RenderEmbeddedTemplateCmd {
-  isBound: boolean = true;
-  name: string = null;
-  eventTargetAndNames: string[] = EMPTY_ARR;
-  constructor(public attrNameAndValues: string[], public variableNameAndValues: string[],
-              public directives: Type[], public isMerged: boolean, public ngContentIndex: number,
-              public changeDetectorFactory: Function, public children: TemplateCmd[]) {}
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitEmbeddedTemplate(this, context);
-  }
-}
-
-
-export interface CommandVisitor extends RenderCommandVisitor {
-  visitText(cmd: TextCmd, context: any): any;
-  visitNgContent(cmd: NgContentCmd, context: any): any;
-  visitBeginElement(cmd: BeginElementCmd, context: any): any;
-  visitEndElement(context: any): any;
-  visitBeginComponent(cmd: BeginComponentCmd, context: any): any;
-  visitEndComponent(context: any): any;
-  visitEmbeddedTemplate(cmd: EmbeddedTemplateCmd, context: any): any;
-}
-
-export function visitAllCommands(visitor: CommandVisitor, cmds: TemplateCmd[],
-                                 context: any = null) {
-  for (var i = 0; i < cmds.length; i++) {
-    cmds[i].visit(visitor, context);
-  }
-}
diff --git a/modules/angular2/src/core/linker/template_ref.ts b/modules/angular2/src/core/linker/template_ref.ts
index 4330f2e..c26df74 100644
--- a/modules/angular2/src/core/linker/template_ref.ts
+++ b/modules/angular2/src/core/linker/template_ref.ts
@@ -1,6 +1,4 @@
-import {internalView, ProtoViewRef} from './view_ref';
 import {ElementRef, ElementRef_} from './element_ref';
-import * as viewModule from './view';
 
 /**
  * Represents an Embedded Template that can be used to instantiate Embedded Views.
@@ -28,33 +26,10 @@ export abstract class TemplateRef {
    */
   // TODO(i): rename to anchor or location
   elementRef: ElementRef;
-
-  /**
-   * Allows you to check if this Embedded Template defines Local Variable with name matching `name`.
-   */
-  abstract hasLocal(name: string): boolean;
 }
 
 export class TemplateRef_ extends TemplateRef {
-  constructor(elementRef: ElementRef) {
-    super();
-    this.elementRef = elementRef;
-  }
-
-  private _getProtoView(): viewModule.AppProtoView {
-    let elementRef = <ElementRef_>this.elementRef;
-    var parentView = internalView(elementRef.parentView);
-    return parentView.proto.elementBinders[elementRef.boundElementIndex - parentView.elementOffset]
-        .nestedProtoView;
-  }
-
-  /**
-   * Reference to the ProtoView used for creating Embedded Views that are based on the compiled
-   * Embedded Template.
-   */
-  get protoViewRef(): ProtoViewRef { return this._getProtoView().ref; }
+  constructor(private _elementRef: ElementRef_) { super(); }
 
-  hasLocal(name: string): boolean {
-    return this._getProtoView().templateVariableBindings.has(name);
-  }
+  get elementRef(): ElementRef_ { return this._elementRef; }
 }
diff --git a/modules/angular2/src/core/linker/view.ts b/modules/angular2/src/core/linker/view.ts
index 5eec1fc..f91fb09 100644
--- a/modules/angular2/src/core/linker/view.ts
+++ b/modules/angular2/src/core/linker/view.ts
@@ -10,86 +10,53 @@ import {
   DirectiveIndex,
   BindingTarget,
   Locals,
-  ProtoChangeDetector
+  ProtoChangeDetector,
+  ChangeDetectorRef
 } from 'angular2/src/core/change_detection/change_detection';
+import {ResolvedProvider, Injectable, Injector} from 'angular2/src/core/di';
 import {DebugContext} from 'angular2/src/core/change_detection/interfaces';
 
+import {AppProtoElement, AppElement, DirectiveProvider} from './element';
 import {
-  ProtoElementInjector,
-  ElementInjector,
-  PreBuiltObjects,
-  DirectiveProvider
-} from './element_injector';
-import {ElementBinder} from './element_binder';
-import {isPresent} from 'angular2/src/facade/lang';
+  isPresent,
+  isBlank,
+  Type,
+  isArray,
+  isNumber,
+  CONST,
+  CONST_EXPR
+} from 'angular2/src/facade/lang';
 import {BaseException, WrappedException} from 'angular2/src/facade/exceptions';
-import * as renderApi from 'angular2/src/core/render/api';
-import {RenderEventDispatcher} from 'angular2/src/core/render/api';
-import {ViewRef, ProtoViewRef, internalView} from './view_ref';
-import {ElementRef} from './element_ref';
+import {Renderer, RootRenderer} from 'angular2/src/core/render/api';
+import {ViewRef_, HostViewFactoryRef} from './view_ref';
 import {ProtoPipes} from 'angular2/src/core/pipes/pipes';
 import {camelCaseToDashCase} from 'angular2/src/core/render/util';
-import {TemplateCmd} from './template_commands';
-import {ViewRef_, ProtoViewRef_} from "./view_ref";
 
 export {DebugContext} from 'angular2/src/core/change_detection/interfaces';
+import {Pipes} from 'angular2/src/core/pipes/pipes';
+import {AppViewManager_, AppViewManager} from './view_manager';
+import {ResolvedMetadataCache} from './resolved_metadata_cache';
+import {ViewType} from './view_type';
 
 const REFLECT_PREFIX: string = 'ng-reflect-';
 
-export enum ViewType {
-  // A view that contains the host element with bound component directive.
-  // Contains a COMPONENT view
-  HOST,
-  // The view of the component
-  // Can contain 0 to n EMBEDDED views
-  COMPONENT,
-  // A view that is embedded into another View via a <template> element
-  // inside of a COMPONENT view
-  EMBEDDED
-}
-
-export class AppViewContainer {
-  // The order in this list matches the DOM order.
-  views: AppView[] = [];
-}
+const EMPTY_CONTEXT = CONST_EXPR(new Object());
 
 /**
  * Cost of making objects: http://jsperf.com/instantiate-size-of-object
  *
  */
-export class AppView implements ChangeDispatcher, RenderEventDispatcher {
-  // AppViews that have been merged in depth first order.
-  // This list is shared between all merged views. Use this.elementOffset to get the local
-  // entries.
-  views: AppView[] = null;
-  // root elementInjectors of this AppView
-  // This list is local to this AppView and not shared with other Views.
-  rootElementInjectors: ElementInjector[];
-  // ElementInjectors of all AppViews in views grouped by view.
-  // This list is shared between all merged views. Use this.elementOffset to get the local
-  // entries.
-  elementInjectors: ElementInjector[] = null;
-  // ViewContainers of all AppViews in views grouped by view.
-  // This list is shared between all merged views. Use this.elementOffset to get the local
-  // entries.
-  viewContainers: AppViewContainer[] = null;
-  // PreBuiltObjects of all AppViews in views grouped by view.
-  // This list is shared between all merged views. Use this.elementOffset to get the local
-  // entries.
-  preBuiltObjects: PreBuiltObjects[] = null;
-  // ElementRef of all AppViews in views grouped by view.
-  // This list is shared between all merged views. Use this.elementOffset to get the local
-  // entries.
-  elementRefs: ElementRef[];
-
-  ref: ViewRef;
-  changeDetector: ChangeDetector = null;
+export class AppView implements ChangeDispatcher {
+  ref: ViewRef_;
+  rootNodesOrAppElements: any[];
+  allNodes: any[];
+  disposables: Function[];
+  appElements: AppElement[];
 
   /**
    * The context against which data-binding expressions in this view are evaluated against.
    * This is always a component instance.
    */
-
   context: any = null;
 
   /**
@@ -99,70 +66,133 @@ export class AppView implements ChangeDispatcher, RenderEventDispatcher {
    */
   locals: Locals;
 
-  constructor(public renderer: renderApi.Renderer, public proto: AppProtoView,
-              public viewOffset: number, public elementOffset: number, public textOffset: number,
-              protoLocals: Map<string, any>, public render: renderApi.RenderViewRef,
-              public renderFragment: renderApi.RenderFragmentRef,
-              public containerElementInjector: ElementInjector) {
+  pipes: Pipes;
+
+  parentInjector: Injector;
+
+  /**
+   * Whether root injectors of this view
+   * have a hostBoundary.
+   */
+  hostInjectorBoundary: boolean;
+
+  destroyed: boolean = false;
+
+  constructor(public proto: AppProtoView, public renderer: Renderer,
+              public viewManager: AppViewManager_, public projectableNodes: Array<any | any[]>,
+              public containerAppElement: AppElement,
+              imperativelyCreatedProviders: ResolvedProvider[], rootInjector: Injector,
+              public changeDetector: ChangeDetector) {
     this.ref = new ViewRef_(this);
+    var injectorWithHostBoundary = AppElement.getViewParentInjector(
+        this.proto.type, containerAppElement, imperativelyCreatedProviders, rootInjector);
+    this.parentInjector = injectorWithHostBoundary.injector;
+    this.hostInjectorBoundary = injectorWithHostBoundary.hostInjectorBoundary;
+    var pipes;
+    var context;
+    switch (proto.type) {
+      case ViewType.COMPONENT:
+        pipes = new Pipes(proto.protoPipes, containerAppElement.getInjector());
+        context = containerAppElement.getComponent();
+        break;
+      case ViewType.EMBEDDED:
+        pipes = containerAppElement.parentView.pipes;
+        context = containerAppElement.parentView.context;
+        break;
+      case ViewType.HOST:
+        pipes = null;
+        context = EMPTY_CONTEXT;
+        break;
+    }
+    this.pipes = pipes;
+    this.context = context;
+  }
 
-    this.locals = new Locals(null, MapWrapper.clone(protoLocals));  // TODO optimize this
+  init(rootNodesOrAppElements: any[], allNodes: any[], disposables: Function[],
+       appElements: AppElement[]) {
+    this.rootNodesOrAppElements = rootNodesOrAppElements;
+    this.allNodes = allNodes;
+    this.disposables = disposables;
+    this.appElements = appElements;
+    var localsMap = new Map<string, any>();
+    StringMapWrapper.forEach(this.proto.templateVariableBindings,
+                             (templateName, _) => { localsMap.set(templateName, null); });
+    for (var i = 0; i < appElements.length; i++) {
+      var appEl = appElements[i];
+      StringMapWrapper.forEach(appEl.proto.directiveVariableBindings, (directiveIndex, name) => {
+        if (isBlank(directiveIndex)) {
+          localsMap.set(name, appEl.nativeElement);
+        } else {
+          localsMap.set(name, appEl.getDirectiveAtIndex(directiveIndex));
+        }
+      });
+    }
+    var parentLocals = null;
+    if (this.proto.type !== ViewType.COMPONENT) {
+      parentLocals =
+          isPresent(this.containerAppElement) ? this.containerAppElement.parentView.locals : null;
+    }
+    if (this.proto.type === ViewType.COMPONENT) {
+      // Note: the render nodes have been attached to their host element
+      // in the ViewFactory already.
+      this.containerAppElement.attachComponentView(this);
+      this.containerAppElement.parentView.changeDetector.addViewChild(this.changeDetector);
+    }
+    this.locals = new Locals(parentLocals, localsMap);
+    this.changeDetector.hydrate(this.context, this.locals, this, this.pipes);
+    this.viewManager.onViewCreated(this);
   }
 
-  init(changeDetector: ChangeDetector, elementInjectors: ElementInjector[],
-       rootElementInjectors: ElementInjector[], preBuiltObjects: PreBuiltObjects[],
-       views: AppView[], elementRefs: ElementRef[], viewContainers: AppViewContainer[]) {
-    this.changeDetector = changeDetector;
-    this.elementInjectors = elementInjectors;
-    this.rootElementInjectors = rootElementInjectors;
-    this.preBuiltObjects = preBuiltObjects;
-    this.views = views;
-    this.elementRefs = elementRefs;
-    this.viewContainers = viewContainers;
+  destroy() {
+    if (this.destroyed) {
+      throw new BaseException('This view has already been destroyed!');
+    }
+    this.changeDetector.destroyRecursive();
   }
 
-  setLocal(contextName: string, value: any): void {
-    if (!this.hydrated()) throw new BaseException('Cannot set locals on dehydrated view.');
-    if (!this.proto.templateVariableBindings.has(contextName)) {
-      return;
+  notifyOnDestroy() {
+    this.destroyed = true;
+    var hostElement =
+        this.proto.type === ViewType.COMPONENT ? this.containerAppElement.nativeElement : null;
+    this.renderer.destroyView(hostElement, this.allNodes);
+    for (var i = 0; i < this.disposables.length; i++) {
+      this.disposables[i]();
     }
-    var templateName = this.proto.templateVariableBindings.get(contextName);
-    this.locals.set(templateName, value);
+    this.viewManager.onViewDestroyed(this);
   }
 
-  hydrated(): boolean { return isPresent(this.context); }
+  get changeDetectorRef(): ChangeDetectorRef { return this.changeDetector.ref; }
 
-  /**
-   * Triggers the event handlers for the element and the directives.
-   *
-   * This method is intended to be called from directive EventEmitters.
-   *
-   * @param {string} eventName
-   * @param {*} eventObj
-   * @param {number} boundElementIndex
-   */
-  triggerEventHandlers(eventName: string, eventObj: Event, boundElementIndex: number): void {
-    var locals = new Map<string, any>();
-    locals.set('$event', eventObj);
-    this.dispatchEvent(boundElementIndex, eventName, locals);
+  get flatRootNodes(): any[] { return flattenNestedViewRenderNodes(this.rootNodesOrAppElements); }
+
+  hasLocal(contextName: string): boolean {
+    return StringMapWrapper.contains(this.proto.templateVariableBindings, contextName);
+  }
+
+  setLocal(contextName: string, value: any): void {
+    if (!this.hasLocal(contextName)) {
+      return;
+    }
+    var templateName = this.proto.templateVariableBindings[contextName];
+    this.locals.set(templateName, value);
   }
 
   // dispatch to element injector or text nodes based on context
   notifyOnBinding(b: BindingTarget, currentValue: any): void {
     if (b.isTextNode()) {
-      this.renderer.setText(this.render, b.elementIndex + this.textOffset, currentValue);
+      this.renderer.setText(this.allNodes[b.elementIndex], currentValue);
     } else {
-      var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
+      var nativeElement = this.appElements[b.elementIndex].nativeElement;
       if (b.isElementProperty()) {
-        this.renderer.setElementProperty(elementRef, b.name, currentValue);
+        this.renderer.setElementProperty(nativeElement, b.name, currentValue);
       } else if (b.isElementAttribute()) {
-        this.renderer.setElementAttribute(elementRef, b.name,
+        this.renderer.setElementAttribute(nativeElement, b.name,
                                           isPresent(currentValue) ? `${currentValue}` : null);
       } else if (b.isElementClass()) {
-        this.renderer.setElementClass(elementRef, b.name, currentValue);
+        this.renderer.setElementClass(nativeElement, b.name, currentValue);
       } else if (b.isElementStyle()) {
         var unit = isPresent(b.unit) ? b.unit : '';
-        this.renderer.setElementStyle(elementRef, b.name,
+        this.renderer.setElementStyle(nativeElement, b.name,
                                       isPresent(currentValue) ? `${currentValue}${unit}` : null);
       } else {
         throw new BaseException('Unsupported directive record');
@@ -172,57 +202,39 @@ export class AppView implements ChangeDispatcher, RenderEventDispatcher {
 
   logBindingUpdate(b: BindingTarget, value: any): void {
     if (b.isDirective() || b.isElementProperty()) {
-      var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
+      var nativeElement = this.appElements[b.elementIndex].nativeElement;
       this.renderer.setBindingDebugInfo(
-          elementRef, `${REFLECT_PREFIX}${camelCaseToDashCase(b.name)}`, `${value}`);
+          nativeElement, `${REFLECT_PREFIX}${camelCaseToDashCase(b.name)}`, `${value}`);
     }
   }
 
   notifyAfterContentChecked(): void {
-    var eiCount = this.proto.elementBinders.length;
-    var ei = this.elementInjectors;
-    for (var i = eiCount - 1; i >= 0; i--) {
-      if (isPresent(ei[i + this.elementOffset])) ei[i + this.elementOffset].ngAfterContentChecked();
+    var count = this.appElements.length;
+    for (var i = count - 1; i >= 0; i--) {
+      this.appElements[i].ngAfterContentChecked();
     }
   }
 
   notifyAfterViewChecked(): void {
-    var eiCount = this.proto.elementBinders.length;
-    var ei = this.elementInjectors;
-    for (var i = eiCount - 1; i >= 0; i--) {
-      if (isPresent(ei[i + this.elementOffset])) ei[i + this.elementOffset].ngAfterViewChecked();
+    var count = this.appElements.length;
+    for (var i = count - 1; i >= 0; i--) {
+      this.appElements[i].ngAfterViewChecked();
     }
   }
 
-  getDirectiveFor(directive: DirectiveIndex): any {
-    var elementInjector = this.elementInjectors[this.elementOffset + directive.elementIndex];
-    return elementInjector.getDirectiveAtIndex(directive.directiveIndex);
-  }
-
-  getNestedView(boundElementIndex: number): AppView {
-    var eli = this.elementInjectors[boundElementIndex];
-    return isPresent(eli) ? eli.getNestedView() : null;
-  }
-
-  getContainerElement(): ElementRef {
-    return isPresent(this.containerElementInjector) ?
-               this.containerElementInjector.getElementRef() :
-               null;
-  }
-
-  getDebugContext(elementIndex: number, directiveIndex: DirectiveIndex): DebugContext {
+  getDebugContext(appElement: AppElement, elementIndex: number,
+                  directiveIndex: number): DebugContext {
     try {
-      var offsettedIndex = this.elementOffset + elementIndex;
-      var hasRefForIndex = offsettedIndex < this.elementRefs.length;
-
-      var elementRef = hasRefForIndex ? this.elementRefs[this.elementOffset + elementIndex] : null;
-      var container = this.getContainerElement();
-      var ei = hasRefForIndex ? this.elementInjectors[this.elementOffset + elementIndex] : null;
+      if (isBlank(appElement) && elementIndex < this.appElements.length) {
+        appElement = this.appElements[elementIndex];
+      }
+      var container = this.containerAppElement;
 
-      var element = isPresent(elementRef) ? elementRef.nativeElement : null;
+      var element = isPresent(appElement) ? appElement.nativeElement : null;
       var componentElement = isPresent(container) ? container.nativeElement : null;
-      var directive = isPresent(directiveIndex) ? this.getDirectiveFor(directiveIndex) : null;
-      var injector = isPresent(ei) ? ei.getInjector() : null;
+      var directive =
+          isPresent(directiveIndex) ? appElement.getDirectiveAtIndex(directiveIndex) : null;
+      var injector = isPresent(appElement) ? appElement.getInjector() : null;
 
       return new DebugContext(element, componentElement, directive, this.context,
                               _localsToStringMap(this.locals), injector);
@@ -234,43 +246,28 @@ export class AppView implements ChangeDispatcher, RenderEventDispatcher {
     }
   }
 
-  getDetectorFor(directive: DirectiveIndex): any {
-    var childView = this.getNestedView(this.elementOffset + directive.elementIndex);
-    return isPresent(childView) ? childView.changeDetector : null;
-  }
-
-  invokeElementMethod(elementIndex: number, methodName: string, args: any[]) {
-    this.renderer.invokeElementMethod(this.elementRefs[elementIndex], methodName, args);
+  getDirectiveFor(directive: DirectiveIndex): any {
+    return this.appElements[directive.elementIndex].getDirectiveAtIndex(directive.directiveIndex);
   }
 
-  // implementation of RenderEventDispatcher#dispatchRenderEvent
-  dispatchRenderEvent(boundElementIndex: number, eventName: string,
-                      locals: Map<string, any>): boolean {
-    var elementRef = this.elementRefs[boundElementIndex];
-    var view = internalView(elementRef.parentView);
-    return view.dispatchEvent(elementRef.boundElementIndex, eventName, locals);
+  getDetectorFor(directive: DirectiveIndex): any {
+    var componentView = this.appElements[directive.elementIndex].componentView;
+    return isPresent(componentView) ? componentView.changeDetector : null;
   }
 
-
-  // returns false if preventDefault must be applied to the DOM event
-  dispatchEvent(boundElementIndex: number, eventName: string, locals: Map<string, any>): boolean {
-    try {
-      if (this.hydrated()) {
-        return !this.changeDetector.handleEvent(eventName, boundElementIndex - this.elementOffset,
-                                                new Locals(this.locals, locals));
-      } else {
-        return true;
-      }
-    } catch (e) {
-      var c = this.getDebugContext(boundElementIndex - this.elementOffset, null);
-      var context = isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals,
-                                                c.injector) :
-                                   null;
-      throw new EventEvaluationError(eventName, e, e.stack, context);
-    }
+  /**
+   * Triggers the event handlers for the element and the directives.
+   *
+   * This method is intended to be called from directive EventEmitters.
+   *
+   * @param {string} eventName
+   * @param {*} eventObj
+   * @param {number} boundElementIndex
+   * @return false if preventDefault must be applied to the DOM event
+   */
+  triggerEventHandlers(eventName: string, eventObj: Event, boundElementIndex: number): boolean {
+    return this.changeDetector.handleEvent(eventName, boundElementIndex, eventObj);
   }
-
-  get ownBindersCount(): number { return this.proto.elementBinders.length; }
 }
 
 function _localsToStringMap(locals: Locals): {[key: string]: any} {
@@ -284,68 +281,60 @@ function _localsToStringMap(locals: Locals): {[key: string]: any} {
 }
 
 /**
- * Error context included when an event handler throws an exception.
- */
-class _Context {
-  constructor(public element: any, public componentElement: any, public context: any,
-              public locals: any, public injector: any) {}
-}
-
-/**
- * Wraps an exception thrown by an event handler.
+ *
  */
-class EventEvaluationError extends WrappedException {
-  constructor(eventName: string, originalException: any, originalStack: any, context: any) {
-    super(`Error during evaluation of "${eventName}"`, originalException, originalStack, context);
+export class AppProtoView {
+  static create(metadataCache: ResolvedMetadataCache, type: ViewType, pipes: Type[],
+                templateVariableBindings: {[key: string]: string}): AppProtoView {
+    var protoPipes = null;
+    if (isPresent(pipes) && pipes.length > 0) {
+      var boundPipes = ListWrapper.createFixedSize(pipes.length);
+      for (var i = 0; i < pipes.length; i++) {
+        boundPipes[i] = metadataCache.getResolvedPipeMetadata(pipes[i]);
+      }
+      protoPipes = ProtoPipes.fromProviders(boundPipes);
+    }
+    return new AppProtoView(type, protoPipes, templateVariableBindings);
   }
+
+  constructor(public type: ViewType, public protoPipes: ProtoPipes,
+              public templateVariableBindings: {[key: string]: string}) {}
 }
 
-export class AppProtoViewMergeInfo {
-  constructor(public embeddedViewCount: number, public elementCount: number,
-              public viewCount: number) {}
+
+@CONST()
+export class HostViewFactory {
+  constructor(public selector: string, public viewFactory: Function) {}
 }
 
-/**
- *
- */
-export class AppProtoView {
-  ref: ProtoViewRef;
-  protoLocals: Map<string, any>;
-
-  elementBinders: ElementBinder[] = null;
-  mergeInfo: AppProtoViewMergeInfo = null;
-  variableLocations: Map<string, number> = null;
-  textBindingCount = null;
-  render: renderApi.RenderProtoViewRef = null;
-
-  constructor(public templateId: string, public templateCmds: TemplateCmd[], public type: ViewType,
-              public isMergable: boolean, public changeDetectorFactory: Function,
-              public templateVariableBindings: Map<string, string>, public pipes: ProtoPipes) {
-    this.ref = new ProtoViewRef_(this);
-  }
+export function flattenNestedViewRenderNodes(nodes: any[]): any[] {
+  return _flattenNestedViewRenderNodes(nodes, []);
+}
 
-  init(render: renderApi.RenderProtoViewRef, elementBinders: ElementBinder[],
-       textBindingCount: number, mergeInfo: AppProtoViewMergeInfo,
-       variableLocations: Map<string, number>) {
-    this.render = render;
-    this.elementBinders = elementBinders;
-    this.textBindingCount = textBindingCount;
-    this.mergeInfo = mergeInfo;
-    this.variableLocations = variableLocations;
-    this.protoLocals = new Map<string, any>();
-    if (isPresent(this.templateVariableBindings)) {
-      this.templateVariableBindings.forEach(
-          (templateName, _) => { this.protoLocals.set(templateName, null); });
-    }
-    if (isPresent(variableLocations)) {
-      // The view's locals needs to have a full set of variable names at construction time
-      // in order to prevent new variables from being set later in the lifecycle. Since we don't
-      // want
-      // to actually create variable bindings for the $implicit bindings, add to the
-      // protoLocals manually.
-      variableLocations.forEach((_, templateName) => { this.protoLocals.set(templateName, null); });
+function _flattenNestedViewRenderNodes(nodes: any[], renderNodes: any[]): any[] {
+  for (var i = 0; i < nodes.length; i++) {
+    var node = nodes[i];
+    if (node instanceof AppElement) {
+      var appEl = <AppElement>node;
+      renderNodes.push(appEl.nativeElement);
+      if (isPresent(appEl.nestedViews)) {
+        for (var k = 0; k < appEl.nestedViews.length; k++) {
+          _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
+        }
+      }
+    } else {
+      renderNodes.push(node);
     }
   }
+  return renderNodes;
+}
 
-  isInitialized(): boolean { return isPresent(this.elementBinders); }
+export function checkSlotCount(componentName: string, expectedSlotCount: number,
+                               projectableNodes: any[][]): void {
+  var givenSlotCount = isPresent(projectableNodes) ? projectableNodes.length : 0;
+  if (givenSlotCount < expectedSlotCount) {
+    throw new BaseException(
+        `The component ${componentName} has ${expectedSlotCount} <ng-content> elements,` +
+        ` but only ${givenSlotCount} slots were provided.`);
+  }
 }
diff --git a/modules/angular2/src/core/linker/view_container_ref.ts b/modules/angular2/src/core/linker/view_container_ref.ts
index 45f2fd0..b8561ed 100644
--- a/modules/angular2/src/core/linker/view_container_ref.ts
+++ b/modules/angular2/src/core/linker/view_container_ref.ts
@@ -3,12 +3,18 @@ import {unimplemented} from 'angular2/src/facade/exceptions';
 import {ResolvedProvider} from 'angular2/src/core/di';
 import {isPresent, isBlank} from 'angular2/src/facade/lang';
 
-import * as avmModule from './view_manager';
-import * as viewModule from './view';
+import {AppElement} from './element';
 
 import {ElementRef, ElementRef_} from './element_ref';
-import {TemplateRef} from './template_ref';
-import {ViewRef, HostViewRef, ProtoViewRef, internalView} from './view_ref';
+import {TemplateRef, TemplateRef_} from './template_ref';
+import {
+  EmbeddedViewRef,
+  HostViewRef,
+  HostViewFactoryRef,
+  HostViewFactoryRef_,
+  ViewRef,
+  ViewRef_
+} from './view_ref';
 
 /**
  * Represents a container where one or more Views can be attached.
@@ -35,7 +41,7 @@ export abstract class ViewContainerRef {
    * Anchor element that specifies the location of this container in the containing View.
    * <!-- TODO: rename to anchorElement -->
    */
-  public element: ElementRef;
+  get element(): ElementRef { return unimplemented(); }
 
   /**
    * Destroys all Views in this container.
@@ -64,7 +70,7 @@ export abstract class ViewContainerRef {
    *
    * Returns the {@link ViewRef} for the newly created View.
    */
-  abstract createEmbeddedView(templateRef: TemplateRef, index?: number): ViewRef;
+  abstract createEmbeddedView(templateRef: TemplateRef, index?: number): EmbeddedViewRef;
 
   /**
    * Instantiates a single {@link Component} and inserts its Host View into this container at the
@@ -80,8 +86,9 @@ export abstract class ViewContainerRef {
    *
    * Returns the {@link HostViewRef} of the Host View created for the newly instantiated Component.
    */
-  abstract createHostView(protoViewRef?: ProtoViewRef, index?: number,
-                          dynamicallyCreatedProviders?: ResolvedProvider[]): HostViewRef;
+  abstract createHostView(hostViewFactoryRef: HostViewFactoryRef, index?: number,
+                          dynamicallyCreatedProviders?: ResolvedProvider[],
+                          projectableNodes?: any[][]): HostViewRef;
 
   /**
    * Inserts a View identified by a {@link ViewRef} into the container at the specified `index`.
@@ -90,7 +97,7 @@ export abstract class ViewContainerRef {
    *
    * Returns the inserted {@link ViewRef}.
    */
-  abstract insert(viewRef: ViewRef, index?: number): ViewRef;
+  abstract insert(viewRef: EmbeddedViewRef, index?: number): EmbeddedViewRef;
 
   /**
    * Returns the index of the View, specified via {@link ViewRef}, within the current container or
@@ -110,58 +117,60 @@ export abstract class ViewContainerRef {
    *
    * If the `index` param is omitted, the last {@link ViewRef} is detached.
    */
-  abstract detach(index?: number): ViewRef;
+  abstract detach(index?: number): EmbeddedViewRef;
 }
 
 export class ViewContainerRef_ extends ViewContainerRef {
-  constructor(public viewManager: avmModule.AppViewManager, element: ElementRef) {
-    super();
-    this.element = element;
-  }
+  constructor(private _element: AppElement) { super(); }
 
-  private _getViews(): Array<viewModule.AppView> {
-    let element = <ElementRef_>this.element;
-    var vc = internalView(element.parentView).viewContainers[element.boundElementIndex];
-    return isPresent(vc) ? vc.views : [];
+  get(index: number): EmbeddedViewRef { return this._element.nestedViews[index].ref; }
+  get length(): number {
+    var views = this._element.nestedViews;
+    return isPresent(views) ? views.length : 0;
   }
 
-  get(index: number): ViewRef { return this._getViews()[index].ref; }
-  get length(): number { return this._getViews().length; }
+  get element(): ElementRef_ { return this._element.ref; }
 
   // TODO(rado): profile and decide whether bounds checks should be added
   // to the methods below.
-  createEmbeddedView(templateRef: TemplateRef, index: number = -1): ViewRef {
+  createEmbeddedView(templateRef: TemplateRef_, index: number = -1): EmbeddedViewRef {
     if (index == -1) index = this.length;
-    return this.viewManager.createEmbeddedViewInContainer(this.element, index, templateRef);
+    var vm = this._element.parentView.viewManager;
+    return vm.createEmbeddedViewInContainer(this._element.ref, index, templateRef);
   }
 
-  createHostView(protoViewRef: ProtoViewRef = null, index: number = -1,
-                 dynamicallyCreatedProviders: ResolvedProvider[] = null): HostViewRef {
+  createHostView(hostViewFactoryRef: HostViewFactoryRef_, index: number = -1,
+                 dynamicallyCreatedProviders: ResolvedProvider[] = null,
+                 projectableNodes: any[][] = null): HostViewRef {
     if (index == -1) index = this.length;
-    return this.viewManager.createHostViewInContainer(this.element, index, protoViewRef,
-                                                      dynamicallyCreatedProviders);
+    var vm = this._element.parentView.viewManager;
+    return vm.createHostViewInContainer(this._element.ref, index, hostViewFactoryRef,
+                                        dynamicallyCreatedProviders, projectableNodes);
   }
 
   // TODO(i): refactor insert+remove into move
-  insert(viewRef: ViewRef, index: number = -1): ViewRef {
+  insert(viewRef: ViewRef_, index: number = -1): EmbeddedViewRef {
     if (index == -1) index = this.length;
-    return this.viewManager.attachViewInContainer(this.element, index, viewRef);
+    var vm = this._element.parentView.viewManager;
+    return vm.attachViewInContainer(this._element.ref, index, viewRef);
   }
 
-  indexOf(viewRef: ViewRef): number {
-    return ListWrapper.indexOf(this._getViews(), internalView(viewRef));
+  indexOf(viewRef: ViewRef_): number {
+    return ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);
   }
 
   // TODO(i): rename to destroy
   remove(index: number = -1): void {
     if (index == -1) index = this.length - 1;
-    this.viewManager.destroyViewInContainer(this.element, index);
+    var vm = this._element.parentView.viewManager;
+    return vm.destroyViewInContainer(this._element.ref, index);
     // view is intentionally not returned to the client.
   }
 
   // TODO(i): refactor insert+remove into move
-  detach(index: number = -1): ViewRef {
+  detach(index: number = -1): EmbeddedViewRef {
     if (index == -1) index = this.length - 1;
-    return this.viewManager.detachViewInContainer(this.element, index);
+    var vm = this._element.parentView.viewManager;
+    return vm.detachViewInContainer(this._element.ref, index);
   }
 }
diff --git a/modules/angular2/src/core/linker/view_manager.ts b/modules/angular2/src/core/linker/view_manager.ts
index 300608f..57a0a82 100644
--- a/modules/angular2/src/core/linker/view_manager.ts
+++ b/modules/angular2/src/core/linker/view_manager.ts
@@ -6,24 +6,27 @@ import {
   ResolvedProvider,
   forwardRef
 } from 'angular2/src/core/di';
-import {isPresent, isBlank} from 'angular2/src/facade/lang';
+import {isPresent, isBlank, isArray} from 'angular2/src/facade/lang';
+import {ListWrapper, StringMapWrapper} from 'angular2/src/facade/collection';
 import {BaseException} from 'angular2/src/facade/exceptions';
-import * as viewModule from './view';
+import {AppView, HostViewFactory, flattenNestedViewRenderNodes} from './view';
+import {AppElement} from './element';
 import {ElementRef, ElementRef_} from './element_ref';
-import {ProtoViewRef, ViewRef, HostViewRef, internalView, internalProtoView} from './view_ref';
+import {
+  HostViewFactoryRef,
+  HostViewFactoryRef_,
+  EmbeddedViewRef,
+  HostViewRef,
+  ViewRef_
+} from './view_ref';
 import {ViewContainerRef} from './view_container_ref';
 import {TemplateRef, TemplateRef_} from './template_ref';
-import {
-  Renderer,
-  RenderViewRef,
-  RenderFragmentRef,
-  RenderViewWithFragments
-} from 'angular2/src/core/render/api';
-import {AppViewManagerUtils} from './view_manager_utils';
-import {AppViewPool} from './view_pool';
 import {AppViewListener} from './view_listener';
+import {RootRenderer, RenderComponentType} from 'angular2/src/core/render/api';
 import {wtfCreateScope, wtfLeave, WtfScopeFn} from '../profile/profile';
-import {ProtoViewFactory} from './proto_view_factory';
+import {APP_ID} from 'angular2/src/core/application_tokens';
+import {ViewEncapsulation} from 'angular2/src/core/metadata/view';
+import {ViewType} from './view_type';
 
 /**
  * Service exposing low level API for creating, moving and destroying Views.
@@ -40,13 +43,7 @@ export abstract class AppViewManager {
   /**
    * Returns the {@link ElementRef} that makes up the specified Host View.
    */
-  getHostElement(hostViewRef: HostViewRef): ElementRef {
-    var hostView = internalView(<ViewRef>hostViewRef);
-    if (hostView.proto.type !== viewModule.ViewType.HOST) {
-      throw new BaseException('This operation is only allowed on host views');
-    }
-    return hostView.elementRefs[hostView.elementOffset];
-  }
+  abstract getHostElement(hostViewRef: HostViewRef): ElementRef;
 
   /**
    * Searches the Component View of the Component specified via `hostLocation` and returns the
@@ -70,7 +67,8 @@ export abstract class AppViewManager {
    * This as a low-level way to bootstrap an application and upgrade an existing Element to a
    * Host Element. Most applications should use {@link DynamicComponentLoader#loadAsRoot} instead.
    *
-   * The Component and its View are created based on the `hostProtoViewRef` which can be obtained
+   * The Component and its View are created based on the `hostProtoComponentRef` which can be
+   * obtained
    * by compiling the component with {@link Compiler#compileInHost}.
    *
    * Use {@link AppViewManager#destroyRootHostView} to destroy the created Component and it's Host
@@ -101,7 +99,7 @@ export abstract class AppViewManager {
    *   viewRef: ng.ViewRef;
    *
    *   constructor(public appViewManager: ng.AppViewManager, compiler: ng.Compiler) {
-   *     compiler.compileInHost(ChildComponent).then((protoView: ng.ProtoViewRef) => {
+   *     compiler.compileInHost(ChildComponent).then((protoView: ng.ProtoComponentRef) => {
    *       this.viewRef = appViewManager.createRootHostView(protoView, 'some-component', null);
    *     })
    *   }
@@ -115,8 +113,8 @@ export abstract class AppViewManager {
    * ng.bootstrap(MyApp);
    * ```
    */
-  abstract createRootHostView(hostProtoViewRef: ProtoViewRef, overrideSelector: string,
-                              injector: Injector): HostViewRef;
+  abstract createRootHostView(hostViewFactoryRef: HostViewFactoryRef, overrideSelector: string,
+                              injector: Injector, projectableNodes?: any[][]): HostViewRef;
 
   /**
    * Destroys the Host View created via {@link AppViewManager#createRootHostView}.
@@ -140,7 +138,7 @@ export abstract class AppViewManager {
   // TODO(i): this low-level version of ViewContainerRef#createEmbeddedView doesn't add anything new
   //    we should make it private, otherwise we have two apis to do the same thing.
   abstract createEmbeddedViewInContainer(viewContainerLocation: ElementRef, index: number,
-                                         templateRef: TemplateRef): ViewRef;
+                                         templateRef: TemplateRef): EmbeddedViewRef;
 
   /**
    * Instantiates a single {@link Component} and inserts its Host View into the View Container
@@ -150,16 +148,16 @@ export abstract class AppViewManager {
    * The component is instantiated using its {@link ProtoViewRef `protoViewRef`} which can be
    * obtained via {@link Compiler#compileInHost}.
    *
-   * You can optionally specify `imperativelyCreatedInjector`, which configure the {@link Injector}
+   * You can optionally specify `dynamicallyCreatedProviders`, which configure the {@link Injector}
    * that will be created for the Host View.
    *
    * Returns the {@link HostViewRef} of the Host View created for the newly instantiated Component.
    *
    * Use {@link AppViewManager#destroyViewInContainer} to destroy the created Host View.
    */
-  abstract createHostViewInContainer(viewContainerLocation: ElementRef, index: number,
-                                     protoViewRef: ProtoViewRef,
-                                     imperativelyCreatedInjector: ResolvedProvider[]): HostViewRef;
+  abstract createHostViewInContainer(
+      viewContainerLocation: ElementRef, index: number, hostViewFactoryRef: HostViewFactoryRef,
+      dynamicallyCreatedProviders: ResolvedProvider[], projectableNodes: any[][]): HostViewRef;
 
   /**
    * Destroys an Embedded or Host View attached to a View Container at the specified `index`.
@@ -174,85 +172,75 @@ export abstract class AppViewManager {
    */
   // TODO(i): refactor detachViewInContainer+attachViewInContainer to moveViewInContainer
   abstract attachViewInContainer(viewContainerLocation: ElementRef, index: number,
-                                 viewRef: ViewRef): ViewRef;
+                                 viewRef: EmbeddedViewRef): EmbeddedViewRef;
 
   /**
    * See {@link AppViewManager#attachViewInContainer}.
    */
-  abstract detachViewInContainer(viewContainerLocation: ElementRef, index: number): ViewRef;
+  abstract detachViewInContainer(viewContainerLocation: ElementRef, index: number): EmbeddedViewRef;
 }
 
 @Injectable()
 export class AppViewManager_ extends AppViewManager {
-  private _protoViewFactory: ProtoViewFactory;
+  private _nextCompTypeId: number = 0;
 
-  constructor(private _viewPool: AppViewPool, private _viewListener: AppViewListener,
-              private _utils: AppViewManagerUtils, private _renderer: Renderer,
-              @Inject(forwardRef(() => ProtoViewFactory)) _protoViewFactory) {
+  constructor(private _renderer: RootRenderer, private _viewListener: AppViewListener,
+              @Inject(APP_ID) private _appId: string) {
     super();
-    this._protoViewFactory = _protoViewFactory;
   }
 
-  getViewContainer(location: ElementRef): ViewContainerRef {
-    var hostView = internalView((<ElementRef_>location).parentView);
-    return hostView.elementInjectors[(<ElementRef_>location).boundElementIndex]
-        .getViewContainerRef();
+  getViewContainer(location: ElementRef_): ViewContainerRef {
+    return location.internalElement.getViewContainerRef();
+  }
+
+  getHostElement(hostViewRef: ViewRef_): ElementRef {
+    var hostView = hostViewRef.internalView;
+    if (hostView.proto.type !== ViewType.HOST) {
+      throw new BaseException('This operation is only allowed on host views');
+    }
+    return hostView.appElements[0].ref;
   }
 
-  getNamedElementInComponentView(hostLocation: ElementRef, variableName: string): ElementRef {
-    var hostView = internalView((<ElementRef_>hostLocation).parentView);
-    var boundElementIndex = (<ElementRef_>hostLocation).boundElementIndex;
-    var componentView = hostView.getNestedView(boundElementIndex);
+  getNamedElementInComponentView(hostLocation: ElementRef_, variableName: string): ElementRef {
+    var appEl = hostLocation.internalElement;
+    var componentView = appEl.componentView;
     if (isBlank(componentView)) {
-      throw new BaseException(`There is no component directive at element ${boundElementIndex}`);
+      throw new BaseException(`There is no component directive at element ${hostLocation}`);
     }
-    var binderIdx = componentView.proto.variableLocations.get(variableName);
-    if (isBlank(binderIdx)) {
-      throw new BaseException(`Could not find variable ${variableName}`);
+    for (var i = 0; i < componentView.appElements.length; i++) {
+      var compAppEl = componentView.appElements[i];
+      if (StringMapWrapper.contains(compAppEl.proto.directiveVariableBindings, variableName)) {
+        return compAppEl.ref;
+      }
     }
-    return componentView.elementRefs[componentView.elementOffset + binderIdx];
+    throw new BaseException(`Could not find variable ${variableName}`);
   }
 
-  getComponent(hostLocation: ElementRef): any {
-    var hostView = internalView((<ElementRef_>hostLocation).parentView);
-    var boundElementIndex = (<ElementRef_>hostLocation).boundElementIndex;
-    return this._utils.getComponentInstance(hostView, boundElementIndex);
+  getComponent(hostLocation: ElementRef_): any {
+    return hostLocation.internalElement.getComponent();
   }
 
   /** @internal */
   _createRootHostViewScope: WtfScopeFn = wtfCreateScope('AppViewManager#createRootHostView()');
 
-  createRootHostView(hostProtoViewRef: ProtoViewRef, overrideSelector: string,
-                     injector: Injector): HostViewRef {
+  createRootHostView(hostViewFactoryRef: HostViewFactoryRef_, overrideSelector: string,
+                     injector: Injector, projectableNodes: any[][] = null): HostViewRef {
     var s = this._createRootHostViewScope();
-    var hostProtoView: viewModule.AppProtoView = internalProtoView(hostProtoViewRef);
-    this._protoViewFactory.initializeProtoViewIfNeeded(hostProtoView);
-    var hostElementSelector = overrideSelector;
-    if (isBlank(hostElementSelector)) {
-      hostElementSelector = hostProtoView.elementBinders[0].componentDirective.metadata.selector;
-    }
-    var renderViewWithFragments = this._renderer.createRootHostView(
-        hostProtoView.render, hostProtoView.mergeInfo.embeddedViewCount + 1, hostElementSelector);
-    var hostView = this._createMainView(hostProtoView, renderViewWithFragments);
-
-    this._renderer.hydrateView(hostView.render);
-    this._utils.hydrateRootHostView(hostView, injector);
-    return wtfLeave(s, hostView.ref);
+    var hostViewFactory = hostViewFactoryRef.internalHostViewFactory;
+    var selector = isPresent(overrideSelector) ? overrideSelector : hostViewFactory.selector;
+    var view = hostViewFactory.viewFactory(this._renderer, this, null, projectableNodes, selector,
+                                           null, injector);
+    return wtfLeave(s, view.ref);
   }
 
   /** @internal */
   _destroyRootHostViewScope: WtfScopeFn = wtfCreateScope('AppViewManager#destroyRootHostView()');
 
-  destroyRootHostView(hostViewRef: HostViewRef) {
-    // Note: Don't put the hostView into the view pool
-    // as it is depending on the element for which it was created.
+  destroyRootHostView(hostViewRef: ViewRef_) {
     var s = this._destroyRootHostViewScope();
-    var hostView = internalView(<ViewRef>hostViewRef);
-    this._renderer.detachFragment(hostView.renderFragment);
-    this._renderer.dehydrateView(hostView.render);
-    this._viewDehydrateRecurse(hostView);
-    this._viewListener.onViewDestroyed(hostView);
-    this._renderer.destroyView(hostView.render);
+    var hostView = hostViewRef.internalView;
+    hostView.renderer.detachView(flattenNestedViewRenderNodes(hostView.rootNodesOrAppElements));
+    hostView.destroy();
     wtfLeave(s);
   }
 
@@ -260,97 +248,43 @@ export class AppViewManager_ extends AppViewManager {
   _createEmbeddedViewInContainerScope: WtfScopeFn =
       wtfCreateScope('AppViewManager#createEmbeddedViewInContainer()');
 
-  createEmbeddedViewInContainer(viewContainerLocation: ElementRef, index: number,
-                                templateRef: TemplateRef): ViewRef {
+  createEmbeddedViewInContainer(viewContainerLocation: ElementRef_, index: number,
+                                templateRef: TemplateRef_): EmbeddedViewRef {
     var s = this._createEmbeddedViewInContainerScope();
-    var protoView = internalProtoView((<TemplateRef_>templateRef).protoViewRef);
-    if (protoView.type !== viewModule.ViewType.EMBEDDED) {
-      throw new BaseException('This method can only be called with embedded ProtoViews!');
-    }
-    this._protoViewFactory.initializeProtoViewIfNeeded(protoView);
-    return wtfLeave(s, this._createViewInContainer(viewContainerLocation, index, protoView,
-                                                   templateRef.elementRef, null));
+    var contextEl = templateRef.elementRef.internalElement;
+    var view: AppView =
+        contextEl.embeddedViewFactory(contextEl.parentView.renderer, this, contextEl,
+                                      contextEl.parentView.projectableNodes, null, null, null);
+    this._attachViewToContainer(view, viewContainerLocation.internalElement, index);
+    return wtfLeave(s, view.ref);
   }
 
   /** @internal */
   _createHostViewInContainerScope: WtfScopeFn =
       wtfCreateScope('AppViewManager#createHostViewInContainer()');
 
-  createHostViewInContainer(viewContainerLocation: ElementRef, index: number,
-                            protoViewRef: ProtoViewRef,
-                            imperativelyCreatedInjector: ResolvedProvider[]): HostViewRef {
+  createHostViewInContainer(viewContainerLocation: ElementRef_, index: number,
+                            hostViewFactoryRef: HostViewFactoryRef_,
+                            dynamicallyCreatedProviders: ResolvedProvider[],
+                            projectableNodes: any[][]): HostViewRef {
     var s = this._createHostViewInContainerScope();
-    var protoView = internalProtoView(protoViewRef);
-    if (protoView.type !== viewModule.ViewType.HOST) {
-      throw new BaseException('This method can only be called with host ProtoViews!');
-    }
-    this._protoViewFactory.initializeProtoViewIfNeeded(protoView);
-    return wtfLeave(
-        s, this._createViewInContainer(viewContainerLocation, index, protoView,
-                                       viewContainerLocation, imperativelyCreatedInjector));
-  }
-
-  /**
-   *
-   * See {@link AppViewManager#destroyViewInContainer}.
-   * @internal
-   */
-  _createViewInContainer(viewContainerLocation: ElementRef, index: number,
-                         protoView: viewModule.AppProtoView, context: ElementRef,
-                         imperativelyCreatedInjector: ResolvedProvider[]): ViewRef {
-    var parentView = internalView((<ElementRef_>viewContainerLocation).parentView);
-    var boundElementIndex = (<ElementRef_>viewContainerLocation).boundElementIndex;
-    var contextView = internalView((<ElementRef_>context).parentView);
-    var contextBoundElementIndex = (<ElementRef_>context).boundElementIndex;
-    var embeddedFragmentView = contextView.getNestedView(contextBoundElementIndex);
-    var view;
-    if (protoView.type === viewModule.ViewType.EMBEDDED && isPresent(embeddedFragmentView) &&
-        !embeddedFragmentView.hydrated()) {
-      // Case 1: instantiate the first view of a template that has been merged into a parent
-      view = embeddedFragmentView;
-      this._attachRenderView(parentView, boundElementIndex, index, view);
-    } else {
-      // Case 2: instantiate another copy of the template or a host ProtoView.
-      // This is a separate case
-      // as we only inline one copy of the template into the parent view.
-      view = this._createPooledView(protoView);
-      this._attachRenderView(parentView, boundElementIndex, index, view);
-      this._renderer.hydrateView(view.render);
-    }
-    this._utils.attachViewInContainer(parentView, boundElementIndex, contextView,
-                                      contextBoundElementIndex, index, view);
-
-    try {
-      this._utils.hydrateViewInContainer(parentView, boundElementIndex, contextView,
-                                         contextBoundElementIndex, index,
-                                         imperativelyCreatedInjector);
-    } catch (e) {
-      this._utils.detachViewInContainer(parentView, boundElementIndex, index);
-      throw e;
-    }
-    return view.ref;
-  }
-
-  /** @internal */
-  _attachRenderView(parentView: viewModule.AppView, boundElementIndex: number, index: number,
-                    view: viewModule.AppView) {
-    var elementRef = parentView.elementRefs[boundElementIndex];
-    if (index === 0) {
-      this._renderer.attachFragmentAfterElement(elementRef, view.renderFragment);
-    } else {
-      var prevView = parentView.viewContainers[boundElementIndex].views[index - 1];
-      this._renderer.attachFragmentAfterFragment(prevView.renderFragment, view.renderFragment);
-    }
+    // TODO(tbosch): This should be specifiable via an additional argument!
+    var contextEl = viewContainerLocation.internalElement;
+    var hostViewFactory = hostViewFactoryRef.internalHostViewFactory;
+    var view = hostViewFactory.viewFactory(
+        contextEl.parentView.renderer, contextEl.parentView.viewManager, contextEl,
+        projectableNodes, null, dynamicallyCreatedProviders, null);
+    this._attachViewToContainer(view, viewContainerLocation.internalElement, index);
+    return wtfLeave(s, view.ref);
   }
 
   /** @internal */
   _destroyViewInContainerScope = wtfCreateScope('AppViewMananger#destroyViewInContainer()');
 
-  destroyViewInContainer(viewContainerLocation: ElementRef, index: number) {
+  destroyViewInContainer(viewContainerLocation: ElementRef_, index: number) {
     var s = this._destroyViewInContainerScope();
-    var parentView = internalView((<ElementRef_>viewContainerLocation).parentView);
-    var boundElementIndex = (<ElementRef_>viewContainerLocation).boundElementIndex;
-    this._destroyViewInContainer(parentView, boundElementIndex, index);
+    var view = this._detachViewInContainer(viewContainerLocation.internalElement, index);
+    view.destroy();
     wtfLeave(s);
   }
 
@@ -358,20 +292,10 @@ export class AppViewManager_ extends AppViewManager {
   _attachViewInContainerScope = wtfCreateScope('AppViewMananger#attachViewInContainer()');
 
   // TODO(i): refactor detachViewInContainer+attachViewInContainer to moveViewInContainer
-  attachViewInContainer(viewContainerLocation: ElementRef, index: number,
-                        viewRef: ViewRef): ViewRef {
+  attachViewInContainer(viewContainerLocation: ElementRef_, index: number,
+                        viewRef: ViewRef_): EmbeddedViewRef {
     var s = this._attachViewInContainerScope();
-    var view = internalView(viewRef);
-    var parentView = internalView((<ElementRef_>viewContainerLocation).parentView);
-    var boundElementIndex = (<ElementRef_>viewContainerLocation).boundElementIndex;
-    // TODO(tbosch): the public methods attachViewInContainer/detachViewInContainer
-    // are used for moving elements without the same container.
-    // We will change this into an atomic `move` operation, which should preserve the
-    // previous parent injector (see https://github.com/angular/angular/issues/1377).
-    // Right now we are destroying any special
-    // context view that might have been used.
-    this._utils.attachViewInContainer(parentView, boundElementIndex, null, null, index, view);
-    this._attachRenderView(parentView, boundElementIndex, index, view);
+    this._attachViewToContainer(viewRef.internalView, viewContainerLocation.internalElement, index);
     return wtfLeave(s, viewRef);
   }
 
@@ -379,88 +303,72 @@ export class AppViewManager_ extends AppViewManager {
   _detachViewInContainerScope = wtfCreateScope('AppViewMananger#detachViewInContainer()');
 
   // TODO(i): refactor detachViewInContainer+attachViewInContainer to moveViewInContainer
-  detachViewInContainer(viewContainerLocation: ElementRef, index: number): ViewRef {
+  detachViewInContainer(viewContainerLocation: ElementRef_, index: number): EmbeddedViewRef {
     var s = this._detachViewInContainerScope();
-    var parentView = internalView((<ElementRef_>viewContainerLocation).parentView);
-    var boundElementIndex = (<ElementRef_>viewContainerLocation).boundElementIndex;
-    var viewContainer = parentView.viewContainers[boundElementIndex];
-    var view = viewContainer.views[index];
-    this._utils.detachViewInContainer(parentView, boundElementIndex, index);
-    this._renderer.detachFragment(view.renderFragment);
+    var view = this._detachViewInContainer(viewContainerLocation.internalElement, index);
     return wtfLeave(s, view.ref);
   }
 
   /** @internal */
-  _createMainView(protoView: viewModule.AppProtoView,
-                  renderViewWithFragments: RenderViewWithFragments): viewModule.AppView {
-    var mergedParentView =
-        this._utils.createView(protoView, renderViewWithFragments, this, this._renderer);
-    this._renderer.setEventDispatcher(mergedParentView.render, mergedParentView);
-    this._viewListener.onViewCreated(mergedParentView);
-    return mergedParentView;
-  }
+  onViewCreated(view: AppView) { this._viewListener.onViewCreated(view); }
 
   /** @internal */
-  _createPooledView(protoView: viewModule.AppProtoView): viewModule.AppView {
-    var view = this._viewPool.getView(protoView);
-    if (isBlank(view)) {
-      view = this._createMainView(
-          protoView,
-          this._renderer.createView(protoView.render, protoView.mergeInfo.embeddedViewCount + 1));
-    }
-    return view;
-  }
+  onViewDestroyed(view: AppView) { this._viewListener.onViewDestroyed(view); }
 
   /** @internal */
-  _destroyPooledView(view: viewModule.AppView) {
-    var wasReturned = this._viewPool.returnView(view);
-    if (!wasReturned) {
-      this._viewListener.onViewDestroyed(view);
-      this._renderer.destroyView(view.render);
-    }
+  createRenderComponentType(encapsulation: ViewEncapsulation,
+                            styles: Array<string | any[]>): RenderComponentType {
+    return new RenderComponentType(`${this._appId}-${this._nextCompTypeId++}`, encapsulation,
+                                   styles);
   }
 
-  /** @internal */
-  _destroyViewInContainer(parentView: viewModule.AppView, boundElementIndex: number,
-                          index: number) {
-    var viewContainer = parentView.viewContainers[boundElementIndex];
-    var view = viewContainer.views[index];
-
-    this._viewDehydrateRecurse(view);
-    this._utils.detachViewInContainer(parentView, boundElementIndex, index);
-    if (view.viewOffset > 0) {
-      // Case 1: a view that is part of another view.
-      // Just detach the fragment
-      this._renderer.detachFragment(view.renderFragment);
+  private _attachViewToContainer(view: AppView, vcAppElement: AppElement, viewIndex: number) {
+    if (view.proto.type === ViewType.COMPONENT) {
+      throw new BaseException(`Component views can't be moved!`);
+    }
+    var nestedViews = vcAppElement.nestedViews;
+    if (nestedViews == null) {
+      nestedViews = [];
+      vcAppElement.nestedViews = nestedViews;
+    }
+    ListWrapper.insert(nestedViews, viewIndex, view);
+    var refNode;
+    if (viewIndex > 0) {
+      var prevView = nestedViews[viewIndex - 1];
+      refNode = prevView.rootNodesOrAppElements.length > 0 ?
+                    prevView.rootNodesOrAppElements[prevView.rootNodesOrAppElements.length - 1] :
+                    null;
     } else {
-      // Case 2: a view that is not part of another view.
-      // dehydrate and destroy it.
-      this._renderer.dehydrateView(view.render);
-      this._renderer.detachFragment(view.renderFragment);
-      this._destroyPooledView(view);
+      refNode = vcAppElement.nativeElement;
     }
+    if (isPresent(refNode)) {
+      var refRenderNode;
+      if (refNode instanceof AppElement) {
+        refRenderNode = (<AppElement>refNode).nativeElement;
+      } else {
+        refRenderNode = refNode;
+      }
+      view.renderer.attachViewAfter(refRenderNode,
+                                    flattenNestedViewRenderNodes(view.rootNodesOrAppElements));
+    }
+    // TODO: This is only needed when a view is destroyed,
+    // not when it is detached for reordering with ng-for...
+    vcAppElement.parentView.changeDetector.addContentChild(view.changeDetector);
+    vcAppElement.traverseAndSetQueriesAsDirty();
   }
 
-  /** @internal */
-  _viewDehydrateRecurse(view: viewModule.AppView) {
-    if (view.hydrated()) {
-      this._utils.dehydrateView(view);
-    }
-    var viewContainers = view.viewContainers;
-    var startViewOffset = view.viewOffset;
-    var endViewOffset = view.viewOffset + view.proto.mergeInfo.viewCount - 1;
-    var elementOffset = view.elementOffset;
-    for (var viewIdx = startViewOffset; viewIdx <= endViewOffset; viewIdx++) {
-      var currView = view.views[viewIdx];
-      for (var binderIdx = 0; binderIdx < currView.proto.elementBinders.length;
-           binderIdx++, elementOffset++) {
-        var vc = viewContainers[elementOffset];
-        if (isPresent(vc)) {
-          for (var j = vc.views.length - 1; j >= 0; j--) {
-            this._destroyViewInContainer(currView, elementOffset, j);
-          }
-        }
-      }
+  private _detachViewInContainer(vcAppElement: AppElement, viewIndex: number): AppView {
+    var view = ListWrapper.removeAt(vcAppElement.nestedViews, viewIndex);
+    if (view.proto.type === ViewType.COMPONENT) {
+      throw new BaseException(`Component views can't be moved!`);
     }
+    vcAppElement.traverseAndSetQueriesAsDirty();
+
+    view.renderer.detachView(flattenNestedViewRenderNodes(view.rootNodesOrAppElements));
+
+    // TODO: This is only needed when a view is destroyed,
+    // not when it is detached for reordering with ng-for...
+    view.changeDetector.remove();
+    return view;
   }
 }
diff --git a/modules/angular2/src/core/linker/view_manager_utils.ts b/modules/angular2/src/core/linker/view_manager_utils.ts
deleted file mode 100644
index 821f1b3..0000000
--- a/modules/angular2/src/core/linker/view_manager_utils.ts
+++ /dev/null
@@ -1,266 +0,0 @@
-import {Injector, Provider, Injectable, ResolvedProvider} from 'angular2/src/core/di';
-import {ListWrapper, MapWrapper, Map, StringMapWrapper} from 'angular2/src/facade/collection';
-import * as eli from './element_injector';
-import {isPresent, isBlank} from 'angular2/src/facade/lang';
-import * as viewModule from './view';
-import * as avmModule from './view_manager';
-import {ElementRef, ElementRef_} from './element_ref';
-import {TemplateRef, TemplateRef_} from './template_ref';
-import {Renderer, RenderViewWithFragments} from 'angular2/src/core/render/api';
-import {Locals} from 'angular2/src/core/change_detection/change_detection';
-import {Pipes} from 'angular2/src/core/pipes/pipes';
-
-@Injectable()
-export class AppViewManagerUtils {
-  constructor() {}
-
-  getComponentInstance(parentView: viewModule.AppView, boundElementIndex: number): any {
-    var eli = parentView.elementInjectors[boundElementIndex];
-    return eli.getComponent();
-  }
-
-  createView(mergedParentViewProto: viewModule.AppProtoView,
-             renderViewWithFragments: RenderViewWithFragments,
-             viewManager: avmModule.AppViewManager, renderer: Renderer): viewModule.AppView {
-    var renderFragments = renderViewWithFragments.fragmentRefs;
-    var renderView = renderViewWithFragments.viewRef;
-
-    var elementCount = mergedParentViewProto.mergeInfo.elementCount;
-    var viewCount = mergedParentViewProto.mergeInfo.viewCount;
-    var elementRefs: ElementRef[] = ListWrapper.createFixedSize(elementCount);
-    var viewContainers = ListWrapper.createFixedSize(elementCount);
-    var preBuiltObjects: eli.PreBuiltObjects[] = ListWrapper.createFixedSize(elementCount);
-    var elementInjectors: eli.ElementInjector[] = ListWrapper.createFixedSize(elementCount);
-    var views = ListWrapper.createFixedSize(viewCount);
-
-    var elementOffset = 0;
-    var textOffset = 0;
-    var fragmentIdx = 0;
-    var containerElementIndicesByViewIndex: number[] = ListWrapper.createFixedSize(viewCount);
-    for (var viewOffset = 0; viewOffset < viewCount; viewOffset++) {
-      var containerElementIndex = containerElementIndicesByViewIndex[viewOffset];
-      var containerElementInjector =
-          isPresent(containerElementIndex) ? elementInjectors[containerElementIndex] : null;
-      var parentView =
-          isPresent(containerElementInjector) ? preBuiltObjects[containerElementIndex].view : null;
-      var protoView =
-          isPresent(containerElementIndex) ?
-              parentView.proto.elementBinders[containerElementIndex - parentView.elementOffset]
-                  .nestedProtoView :
-              mergedParentViewProto;
-      var renderFragment = null;
-      if (viewOffset === 0 || protoView.type === viewModule.ViewType.EMBEDDED) {
-        renderFragment = renderFragments[fragmentIdx++];
-      }
-      var currentView = new viewModule.AppView(renderer, protoView, viewOffset, elementOffset,
-                                               textOffset, protoView.protoLocals, renderView,
-                                               renderFragment, containerElementInjector);
-      views[viewOffset] = currentView;
-      if (isPresent(containerElementIndex)) {
-        preBuiltObjects[containerElementIndex].nestedView = currentView;
-      }
-      var rootElementInjectors = [];
-      var nestedViewOffset = viewOffset + 1;
-      for (var binderIdx = 0; binderIdx < protoView.elementBinders.length; binderIdx++) {
-        var binder = protoView.elementBinders[binderIdx];
-        var boundElementIndex = elementOffset + binderIdx;
-        var elementInjector = null;
-
-        if (isPresent(binder.nestedProtoView) && binder.nestedProtoView.isMergable) {
-          containerElementIndicesByViewIndex[nestedViewOffset] = boundElementIndex;
-          nestedViewOffset += binder.nestedProtoView.mergeInfo.viewCount;
-        }
-
-        // elementInjectors and rootElementInjectors
-        var protoElementInjector = binder.protoElementInjector;
-        if (isPresent(protoElementInjector)) {
-          if (isPresent(protoElementInjector.parent)) {
-            var parentElementInjector =
-                elementInjectors[elementOffset + protoElementInjector.parent.index];
-            elementInjector = protoElementInjector.instantiate(parentElementInjector);
-          } else {
-            elementInjector = protoElementInjector.instantiate(null);
-            rootElementInjectors.push(elementInjector);
-          }
-        }
-        elementInjectors[boundElementIndex] = elementInjector;
-
-        // elementRefs
-        var el = new ElementRef_(currentView.ref, boundElementIndex, renderer);
-        elementRefs[el.boundElementIndex] = el;
-
-        // preBuiltObjects
-        if (isPresent(elementInjector)) {
-          var templateRef = isPresent(binder.nestedProtoView) &&
-                                    binder.nestedProtoView.type === viewModule.ViewType.EMBEDDED ?
-                                new TemplateRef_(el) :
-                                null;
-          preBuiltObjects[boundElementIndex] =
-              new eli.PreBuiltObjects(viewManager, currentView, el, templateRef);
-        }
-      }
-      currentView.init(protoView.changeDetectorFactory(currentView), elementInjectors,
-                       rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers);
-      if (isPresent(parentView) && protoView.type === viewModule.ViewType.COMPONENT) {
-        parentView.changeDetector.addViewChild(currentView.changeDetector);
-      }
-      elementOffset += protoView.elementBinders.length;
-      textOffset += protoView.textBindingCount;
-    }
-    return views[0];
-  }
-
-  hydrateRootHostView(hostView: viewModule.AppView, injector: Injector) {
-    this._hydrateView(hostView, injector, null, new Object(), null);
-  }
-
-  // Misnomer: this method is attaching next to the view container.
-  attachViewInContainer(parentView: viewModule.AppView, boundElementIndex: number,
-                        contextView: viewModule.AppView, contextBoundElementIndex: number,
-                        index: number, view: viewModule.AppView) {
-    if (isBlank(contextView)) {
-      contextView = parentView;
-      contextBoundElementIndex = boundElementIndex;
-    }
-    parentView.changeDetector.addContentChild(view.changeDetector);
-    var viewContainer = parentView.viewContainers[boundElementIndex];
-    if (isBlank(viewContainer)) {
-      viewContainer = new viewModule.AppViewContainer();
-      parentView.viewContainers[boundElementIndex] = viewContainer;
-    }
-    ListWrapper.insert(viewContainer.views, index, view);
-    var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
-
-    for (var i = view.rootElementInjectors.length - 1; i >= 0; i--) {
-      if (isPresent(elementInjector.parent)) {
-        view.rootElementInjectors[i].link(elementInjector.parent);
-      }
-    }
-    elementInjector.traverseAndSetQueriesAsDirty();
-  }
-
-  detachViewInContainer(parentView: viewModule.AppView, boundElementIndex: number, index: number) {
-    var viewContainer = parentView.viewContainers[boundElementIndex];
-    var view = viewContainer.views[index];
-
-    parentView.elementInjectors[boundElementIndex].traverseAndSetQueriesAsDirty();
-
-    view.changeDetector.remove();
-    ListWrapper.removeAt(viewContainer.views, index);
-    for (var i = 0; i < view.rootElementInjectors.length; ++i) {
-      var inj = view.rootElementInjectors[i];
-      inj.unlink();
-    }
-  }
-
-
-  hydrateViewInContainer(parentView: viewModule.AppView, boundElementIndex: number,
-                         contextView: viewModule.AppView, contextBoundElementIndex: number,
-                         index: number, imperativelyCreatedProviders: ResolvedProvider[]) {
-    if (isBlank(contextView)) {
-      contextView = parentView;
-      contextBoundElementIndex = boundElementIndex;
-    }
-    var viewContainer = parentView.viewContainers[boundElementIndex];
-    var view = viewContainer.views[index];
-    var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
-
-    var injector = isPresent(imperativelyCreatedProviders) ?
-                       Injector.fromResolvedProviders(imperativelyCreatedProviders) :
-                       null;
-    this._hydrateView(view, injector, elementInjector.getHost(), contextView.context,
-                      contextView.locals);
-  }
-
-  /** @internal */
-  _hydrateView(initView: viewModule.AppView, imperativelyCreatedInjector: Injector,
-               hostElementInjector: eli.ElementInjector, context: Object, parentLocals: Locals) {
-    var viewIdx = initView.viewOffset;
-    var endViewOffset = viewIdx + initView.proto.mergeInfo.viewCount - 1;
-    while (viewIdx <= endViewOffset) {
-      var currView = initView.views[viewIdx];
-      var currProtoView = currView.proto;
-      if (currView !== initView && currView.proto.type === viewModule.ViewType.EMBEDDED) {
-        // Don't hydrate components of embedded fragment views.
-        viewIdx += currView.proto.mergeInfo.viewCount;
-      } else {
-        if (currView !== initView) {
-          // hydrate a nested component view
-          imperativelyCreatedInjector = null;
-          parentLocals = null;
-          hostElementInjector = currView.containerElementInjector;
-          context = hostElementInjector.getComponent();
-        }
-        currView.context = context;
-        currView.locals.parent = parentLocals;
-        var binders = currProtoView.elementBinders;
-        for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
-          var boundElementIndex = binderIdx + currView.elementOffset;
-          var elementInjector = initView.elementInjectors[boundElementIndex];
-
-          if (isPresent(elementInjector)) {
-            elementInjector.hydrate(imperativelyCreatedInjector, hostElementInjector,
-                                    currView.preBuiltObjects[boundElementIndex]);
-            this._populateViewLocals(currView, elementInjector, boundElementIndex);
-            this._setUpEventEmitters(currView, elementInjector, boundElementIndex);
-          }
-        }
-        var pipes = isPresent(hostElementInjector) ?
-                        new Pipes(currView.proto.pipes, hostElementInjector.getInjector()) :
-                        null;
-        currView.changeDetector.hydrate(currView.context, currView.locals, currView, pipes);
-        viewIdx++;
-      }
-    }
-  }
-
-  /** @internal */
-  _populateViewLocals(view: viewModule.AppView, elementInjector: eli.ElementInjector,
-                      boundElementIdx: number): void {
-    if (isPresent(elementInjector.getDirectiveVariableBindings())) {
-      elementInjector.getDirectiveVariableBindings().forEach((directiveIndex, name) => {
-        if (isBlank(directiveIndex)) {
-          view.locals.set(name, view.elementRefs[boundElementIdx].nativeElement);
-        } else {
-          view.locals.set(name, elementInjector.getDirectiveAtIndex(directiveIndex));
-        }
-      });
-    }
-  }
-
-  /** @internal */
-  _setUpEventEmitters(view: viewModule.AppView, elementInjector: eli.ElementInjector,
-                      boundElementIndex: number) {
-    var emitters = elementInjector.getEventEmitterAccessors();
-    for (var directiveIndex = 0; directiveIndex < emitters.length; ++directiveIndex) {
-      var directiveEmitters = emitters[directiveIndex];
-      var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
-
-      for (var eventIndex = 0; eventIndex < directiveEmitters.length; ++eventIndex) {
-        var eventEmitterAccessor = directiveEmitters[eventIndex];
-        eventEmitterAccessor.subscribe(view, boundElementIndex, directive);
-      }
-    }
-  }
-
-  dehydrateView(initView: viewModule.AppView) {
-    var endViewOffset = initView.viewOffset + initView.proto.mergeInfo.viewCount - 1;
-    for (var viewIdx = initView.viewOffset; viewIdx <= endViewOffset; viewIdx++) {
-      var currView = initView.views[viewIdx];
-      if (currView.hydrated()) {
-        if (isPresent(currView.locals)) {
-          currView.locals.clearValues();
-        }
-        currView.context = null;
-        currView.changeDetector.dehydrate();
-        var binders = currView.proto.elementBinders;
-        for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
-          var eli = initView.elementInjectors[currView.elementOffset + binderIdx];
-          if (isPresent(eli)) {
-            eli.dehydrate();
-          }
-        }
-      }
-    }
-  }
-}
diff --git a/modules/angular2/src/core/linker/view_pool.ts b/modules/angular2/src/core/linker/view_pool.ts
deleted file mode 100644
index 17598fd..0000000
--- a/modules/angular2/src/core/linker/view_pool.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import {Inject, Injectable, OpaqueToken} from 'angular2/src/core/di';
-
-import {isPresent, isBlank, CONST_EXPR} from 'angular2/src/facade/lang';
-import {MapWrapper, Map} from 'angular2/src/facade/collection';
-
-import * as viewModule from './view';
-
-export const APP_VIEW_POOL_CAPACITY = CONST_EXPR(new OpaqueToken('AppViewPool.viewPoolCapacity'));
-
-@Injectable()
-export class AppViewPool {
-  /** @internal */
-  _poolCapacityPerProtoView: number;
-  /** @internal */
-  _pooledViewsPerProtoView = new Map<viewModule.AppProtoView, Array<viewModule.AppView>>();
-
-  constructor(@Inject(APP_VIEW_POOL_CAPACITY) poolCapacityPerProtoView) {
-    this._poolCapacityPerProtoView = poolCapacityPerProtoView;
-  }
-
-  getView(protoView: viewModule.AppProtoView): viewModule.AppView {
-    var pooledViews = this._pooledViewsPerProtoView.get(protoView);
-    if (isPresent(pooledViews) && pooledViews.length > 0) {
-      return pooledViews.pop();
-    }
-    return null;
-  }
-
-  returnView(view: viewModule.AppView): boolean {
-    var protoView = view.proto;
-    var pooledViews = this._pooledViewsPerProtoView.get(protoView);
-    if (isBlank(pooledViews)) {
-      pooledViews = [];
-      this._pooledViewsPerProtoView.set(protoView, pooledViews);
-    }
-    var haveRemainingCapacity = pooledViews.length < this._poolCapacityPerProtoView;
-    if (haveRemainingCapacity) {
-      pooledViews.push(view);
-    }
-    return haveRemainingCapacity;
-  }
-}
diff --git a/modules/angular2/src/core/linker/view_ref.ts b/modules/angular2/src/core/linker/view_ref.ts
index 7cf3af0..8e823ce 100644
--- a/modules/angular2/src/core/linker/view_ref.ts
+++ b/modules/angular2/src/core/linker/view_ref.ts
@@ -1,20 +1,16 @@
-import {isPresent} from 'angular2/src/facade/lang';
 import {unimplemented} from 'angular2/src/facade/exceptions';
-import * as viewModule from './view';
 import {ChangeDetectorRef} from '../change_detection/change_detector_ref';
-import {RenderViewRef, RenderFragmentRef} from 'angular2/src/core/render/api';
+import {AppView, HostViewFactory} from './view';
 
-// This is a workaround for privacy in Dart as we don't have library parts
-export function internalView(viewRef: ViewRef): viewModule.AppView {
-  return (<ViewRef_>viewRef)._view;
-}
+export abstract class ViewRef {
+  /**
+   * @internal
+   */
+  get changeDetectorRef(): ChangeDetectorRef { return unimplemented(); };
 
-// This is a workaround for privacy in Dart as we don't have library parts
-export function internalProtoView(protoViewRef: ProtoViewRef): viewModule.AppProtoView {
-  return isPresent(protoViewRef) ? (<ProtoViewRef_>protoViewRef)._protoView : null;
+  get destroyed(): boolean { return unimplemented(); }
 }
 
-
 /**
  * Represents a View containing a single Element that is the Host Element of a {@link Component}
  * instance.
@@ -24,11 +20,8 @@ export function internalProtoView(protoViewRef: ProtoViewRef): viewModule.AppPro
  * of the higher-level APIs: {@link AppViewManager#createRootHostView},
  * {@link AppViewManager#createHostViewInContainer}, {@link ViewContainerRef#createHostView}.
  */
-export interface HostViewRef {
-  /**
-   * @internal
-   */
-  changeDetectorRef: ChangeDetectorRef;
+export abstract class HostViewRef extends ViewRef {
+  get rootNodes(): any[] { return unimplemented(); };
 }
 
 /**
@@ -84,96 +77,43 @@ export interface HostViewRef {
  * <!-- /ViewRef: outer-0 -->
  * ```
  */
-export abstract class ViewRef implements HostViewRef {
+export abstract class EmbeddedViewRef extends ViewRef {
   /**
    * Sets `value` of local variable called `variableName` in this View.
    */
   abstract setLocal(variableName: string, value: any): void;
 
-  get changeDetectorRef(): ChangeDetectorRef { return unimplemented(); }
-  set changeDetectorRef(value: ChangeDetectorRef) {
-    unimplemented();  // TODO: https://github.com/Microsoft/TypeScript/issues/12
-  }
-}
-
-export class ViewRef_ extends ViewRef {
-  private _changeDetectorRef: ChangeDetectorRef = null;
-  /** @internal */
-  public _view: viewModule.AppView;
-  constructor(_view: viewModule.AppView) {
-    super();
-    this._view = _view;
-  }
-
   /**
-   * Return `RenderViewRef`
+   * Checks whether this view has a local variable called `variableName`.
    */
-  get render(): RenderViewRef { return this._view.render; }
+  abstract hasLocal(variableName: string): boolean;
 
-  /**
-   * Return `RenderFragmentRef`
-   */
-  get renderFragment(): RenderFragmentRef { return this._view.renderFragment; }
+  get rootNodes(): any[] { return unimplemented(); };
+}
+
+export class ViewRef_ implements EmbeddedViewRef, HostViewRef {
+  constructor(private _view: AppView) { this._view = _view; }
+
+  get internalView(): AppView { return this._view; }
 
   /**
    * Return `ChangeDetectorRef`
    */
-  get changeDetectorRef(): ChangeDetectorRef {
-    if (this._changeDetectorRef === null) {
-      this._changeDetectorRef = this._view.changeDetector.ref;
-    }
-    return this._changeDetectorRef;
-  }
+  get changeDetectorRef(): ChangeDetectorRef { return this._view.changeDetector.ref; }
+
+  get rootNodes(): any[] { return this._view.flatRootNodes; }
 
   setLocal(variableName: string, value: any): void { this._view.setLocal(variableName, value); }
-}
 
-/**
- * Represents an Angular ProtoView.
- *
- * A ProtoView is a prototypical {@link ViewRef View} that is the result of Template compilation and
- * is used by Angular to efficiently create an instance of this View based on the compiled Template.
- *
- * Most ProtoViews are created and used internally by Angular and you don't need to know about them,
- * except in advanced use-cases where you compile components yourself via the low-level
- * {@link Compiler#compileInHost} API.
- *
- *
- * ### Example
- *
- * Given this template:
- *
- * ```
- * Count: {{items.length}}
- * <ul>
- *   <li *ngFor="var item of items">{{item}}</li>
- * </ul>
- * ```
- *
- * Angular desugars and compiles the template into two ProtoViews:
- *
- * Outer ProtoView:
- * ```
- * Count: {{items.length}}
- * <ul>
- *   <template ngFor var-item [ngForOf]="items"></template>
- * </ul>
- * ```
- *
- * Inner ProtoView:
- * ```
- *   <li>{{item}}</li>
- * ```
- *
- * Notice that the original template is broken down into two separate ProtoViews.
- */
-export abstract class ProtoViewRef {}
-
-export class ProtoViewRef_ extends ProtoViewRef {
-  /** @internal */
-  public _protoView: viewModule.AppProtoView;
-  constructor(_protoView: viewModule.AppProtoView) {
-    super();
-    this._protoView = _protoView;
-  }
+  hasLocal(variableName: string): boolean { return this._view.hasLocal(variableName); }
+
+  get destroyed(): boolean { return this._view.destroyed; }
 }
+
+export abstract class HostViewFactoryRef {}
+
+export class HostViewFactoryRef_ implements HostViewFactoryRef {
+  constructor(private _hostViewFactory: HostViewFactory) {}
+
+  get internalHostViewFactory(): HostViewFactory { return this._hostViewFactory; }
+}
\ No newline at end of file
diff --git a/modules/angular2/src/core/linker/view_type.ts b/modules/angular2/src/core/linker/view_type.ts
new file mode 100644
index 0000000..ef4ceef
--- /dev/null
+++ b/modules/angular2/src/core/linker/view_type.ts
@@ -0,0 +1,11 @@
+export enum ViewType {
+  // A view that contains the host element with bound component directive.
+  // Contains a COMPONENT view
+  HOST,
+  // The view of the component
+  // Can contain 0 to n EMBEDDED views
+  COMPONENT,
+  // A view that is embedded into another View via a <template> element
+  // inside of a COMPONENT view
+  EMBEDDED
+}
diff --git a/modules/angular2/src/core/pipes/pipes.ts b/modules/angular2/src/core/pipes/pipes.ts
index 52f2482..08bbbb9 100644
--- a/modules/angular2/src/core/pipes/pipes.ts
+++ b/modules/angular2/src/core/pipes/pipes.ts
@@ -45,7 +45,6 @@ export class Pipes implements cd.Pipes {
   get(name: string): cd.SelectedPipe {
     var cached = StringMapWrapper.get(this._config, name);
     if (isPresent(cached)) return cached;
-
     var p = this.proto.get(name);
     var transform = this.injector.instantiateResolved(p);
     var res = new cd.SelectedPipe(transform, p.pure);
diff --git a/modules/angular2/src/core/render.ts b/modules/angular2/src/core/render.ts
index 7976f27..e7bbe61 100644
--- a/modules/angular2/src/core/render.ts
+++ b/modules/angular2/src/core/render.ts
@@ -1,19 +1,2 @@
 // Public API for render
-export {
-  RenderEventDispatcher,
-  Renderer,
-  RenderElementRef,
-  RenderViewRef,
-  RenderProtoViewRef,
-  RenderFragmentRef,
-  RenderViewWithFragments,
-  RenderTemplateCmd,
-  RenderCommandVisitor,
-  RenderTextCmd,
-  RenderNgContentCmd,
-  RenderBeginElementCmd,
-  RenderBeginComponentCmd,
-  RenderEmbeddedTemplateCmd,
-  RenderBeginCmd,
-  RenderComponentTemplate
-} from './render/api';
\ No newline at end of file
+export {RootRenderer, Renderer, RenderComponentType} from './render/api';
diff --git a/modules/angular2/src/core/render/api.ts b/modules/angular2/src/core/render/api.ts
index c5bcc1c..834ef9e 100644
--- a/modules/angular2/src/core/render/api.ts
+++ b/modules/angular2/src/core/render/api.ts
@@ -1,196 +1,54 @@
-import {unimplemented} from 'angular2/src/facade/exceptions';
-import {Map} from 'angular2/src/facade/collection';
-import {ViewEncapsulation} from 'angular2/src/core/metadata';
+import {ViewEncapsulation} from 'angular2/src/core/metadata/view';
 
-/**
- * Represents an Angular ProtoView in the Rendering Context.
- *
- * When you implement a custom {@link Renderer}, `RenderProtoViewRef` specifies what Render View
- * your renderer should create.
- *
- * `RenderProtoViewRef` is a counterpart to {@link ProtoViewRef} available in the Application
- * Context. But unlike `ProtoViewRef`, `RenderProtoViewRef` contains all static nested Proto Views
- * that are recursively merged into a single Render Proto View.
+export class RenderComponentType {
+  constructor(public id: string, public encapsulation: ViewEncapsulation,
+              public styles: Array<string | any[]>) {}
+}
 
- *
- * <!-- TODO: this is created by Renderer#createProtoView in the new compiler -->
- */
-export class RenderProtoViewRef {}
+export interface ParentRenderer { renderComponent(componentType: RenderComponentType): Renderer; }
 
-/**
- * Represents a list of sibling Nodes that can be moved by the {@link Renderer} independently of
- * other Render Fragments.
- *
- * Any {@link RenderViewRef} has one Render Fragment.
- *
- * Additionally any View with an Embedded View that contains a {@link NgContentAst View Projection}
- * results in additional Render Fragment.
- */
-/*
-  <div>foo</div>
-  {{bar}}
+export abstract class Renderer implements ParentRenderer {
+  abstract renderComponent(componentType: RenderComponentType): Renderer;
 
+  abstract selectRootElement(selector: string): any;
 
-  <div>foo</div> -> view 1 / fragment 1
-  <ul>
-    <template ngFor>
-      <li>{{fg}}</li> -> view 2 / fragment 1
-    </template>
-  </ul>
-  {{bar}}
+  abstract createElement(parentElement: any, name: string): any;
 
+  abstract createViewRoot(hostElement: any): any;
 
-  <div>foo</div> -> view 1 / fragment 1
-  <ul>
-    <template ngIf>
-      <li><ng-content></></li> -> view 1 / fragment 2
-    </template>
-    <template ngFor>
-      <li><ng-content></></li> ->
-      <li></li>                -> view 1 / fragment 2 + view 2 / fragment 1..n-1
-    </template>
-  </ul>
-  {{bar}}
- */
-// TODO(i): refactor into an interface
-export class RenderFragmentRef {}
+  abstract createTemplateAnchor(parentElement: any): any;
 
+  abstract createText(parentElement: any, value: string): any;
 
-/**
- * Represents an Angular View in the Rendering Context.
- *
- * `RenderViewRef` specifies to the {@link Renderer} what View to update or destroy.
- *
- * Unlike a {@link ViewRef} available in the Application Context, Render View contains all the
- * static Component Views that have been recursively merged into a single Render View.
- *
- * Each `RenderViewRef` contains one or more {@link RenderFragmentRef Render Fragments}, these
- * Fragments are created, hydrated, dehydrated and destroyed as a single unit together with the
- * View.
- */
-// TODO(i): refactor into an interface
-export class RenderViewRef {}
+  abstract projectNodes(parentElement: any, nodes: any[]);
 
-/**
- * Abstract base class for commands to the Angular renderer, using the visitor pattern.
- */
-export abstract class RenderTemplateCmd {
-  abstract visit(visitor: RenderCommandVisitor, context: any): any;
-}
+  abstract attachViewAfter(node: any, viewRootNodes: any[]);
 
-/**
- * Command to begin rendering.
- */
-export abstract class RenderBeginCmd extends RenderTemplateCmd {
-  get ngContentIndex(): number { return unimplemented(); };
-  get isBound(): boolean { return unimplemented(); };
-}
+  abstract detachView(viewRootNodes: any[]);
 
-/**
- * Command to render text.
- */
-export abstract class RenderTextCmd extends RenderBeginCmd {
-  get value(): string { return unimplemented(); };
-}
+  abstract destroyView(hostElement: any, viewAllNodes: any[]);
 
-/**
- * Command to render projected content.
- */
-export abstract class RenderNgContentCmd extends RenderTemplateCmd {
-  // The index of this NgContent element
-  get index(): number { return unimplemented(); };
-  // The index of the NgContent element into which this
-  // NgContent element should be projected (if any)
-  get ngContentIndex(): number { return unimplemented(); };
-}
+  abstract listen(renderElement: any, name: string, callback: Function);
 
-/**
- * Command to begin rendering an element.
- */
-export abstract class RenderBeginElementCmd extends RenderBeginCmd {
-  get name(): string { return unimplemented(); };
-  get attrNameAndValues(): string[] { return unimplemented(); };
-  get eventTargetAndNames(): string[] { return unimplemented(); };
-}
+  abstract listenGlobal(target: string, name: string, callback: Function): Function;
 
-/**
- * Command to begin rendering a component.
- */
-export abstract class RenderBeginComponentCmd extends RenderBeginElementCmd {
-  get templateId(): string { return unimplemented(); };
-}
+  abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any);
 
-/**
- * Command to render a component's template.
- */
-export abstract class RenderEmbeddedTemplateCmd extends RenderBeginElementCmd {
-  get isMerged(): boolean { return unimplemented(); };
-  get children(): RenderTemplateCmd[] { return unimplemented(); };
-}
+  abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue: string);
 
-/**
- * Visitor for a {@link RenderTemplateCmd}.
- */
-export interface RenderCommandVisitor {
-  visitText(cmd: RenderTextCmd, context: any): any;
-  visitNgContent(cmd: RenderNgContentCmd, context: any): any;
-  visitBeginElement(cmd: RenderBeginElementCmd, context: any): any;
-  visitEndElement(context: any): any;
-  visitBeginComponent(cmd: RenderBeginComponentCmd, context: any): any;
-  visitEndComponent(context: any): any;
-  visitEmbeddedTemplate(cmd: RenderEmbeddedTemplateCmd, context: any): any;
-}
-
-
-/**
- * Container class produced by a {@link Renderer} when creating a Render View.
- *
- * An instance of `RenderViewWithFragments` contains a {@link RenderViewRef} and an array of
- * {@link RenderFragmentRef}s belonging to this Render View.
- */
-// TODO(i): refactor this by RenderViewWithFragments and adding fragments directly to RenderViewRef
-export class RenderViewWithFragments {
-  constructor(
-      /**
-       * Reference to the {@link RenderViewRef}.
-       */
-      public viewRef: RenderViewRef,
-      /**
-       * Array of {@link RenderFragmentRef}s ordered in the depth-first order.
-       */
-      public fragmentRefs: RenderFragmentRef[]) {}
-}
-
-/**
- * Represents an Element that is part of a {@link RenderViewRef Render View}.
- *
- * `RenderElementRef` is a counterpart to {@link ElementRef} available in the Application Context.
- *
- * When using `Renderer` from the Application Context, `ElementRef` can be used instead of
- * `RenderElementRef`.
- */
-export interface RenderElementRef {
   /**
-   * Reference to the Render View that contains this Element.
+   * Used only in debug mode to serialize property changes to comment nodes,
+   * such as <template> placeholders.
    */
-  renderView: RenderViewRef;
+  abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string);
 
-  /**
-   * @internal
-   *
-   * Index of the Element (in the depth-first order) inside the Render View.
-   *
-   * This index is used internally by Angular to locate elements.
-   */
-  boundElementIndex: number;
-}
+  abstract setElementClass(renderElement: any, className: string, isAdd: boolean);
 
-/**
- * Template for rendering a component, including commands and styles.
- */
-export class RenderComponentTemplate {
-  constructor(public id: string, public shortId: string, public encapsulation: ViewEncapsulation,
-              public commands: RenderTemplateCmd[], public styles: string[]) {}
+  abstract setElementStyle(renderElement: any, styleName: string, styleValue: string);
+
+  abstract invokeElementMethod(renderElement: any, methodName: string, args: any[]);
+
+  abstract setText(renderNode: any, text: string);
 }
 
 /**
@@ -205,184 +63,7 @@ export class RenderComponentTemplate {
  *
  * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
  */
-export abstract class Renderer {
-  /**
-   * Registers a component template represented as arrays of {@link RenderTemplateCmd}s and styles
-   * with the Renderer.
-   *
-   * Once a template is registered it can be referenced via {@link RenderBeginComponentCmd} when
-   * {@link #createProtoView creating Render ProtoView}.
-   */
-  abstract registerComponentTemplate(template: RenderComponentTemplate);
-
-  /**
-   * Creates a {@link RenderProtoViewRef} from an array of {@link RenderTemplateCmd}`s.
-   */
-  abstract createProtoView(componentTemplateId: string,
-                           cmds: RenderTemplateCmd[]): RenderProtoViewRef;
-
-  /**
-   * Creates a Root Host View based on the provided `hostProtoViewRef`.
-   *
-   * `fragmentCount` is the number of nested {@link RenderFragmentRef}s in this View. This parameter
-   * is non-optional so that the renderer can create a result synchronously even when application
-   * runs in a different context (e.g. in a Web Worker).
-   *
-   * `hostElementSelector` is a (CSS) selector for querying the main document to find the Host
-   * Element. The newly created Root Host View should be attached to this element.
-   *
-   * Returns an instance of {@link RenderViewWithFragments}, representing the Render View.
-   */
-  abstract createRootHostView(hostProtoViewRef: RenderProtoViewRef, fragmentCount: number,
-                              hostElementSelector: string): RenderViewWithFragments;
-
-  /**
-   * Creates a Render View based on the provided `protoViewRef`.
-   *
-   * `fragmentCount` is the number of nested {@link RenderFragmentRef}s in this View. This parameter
-   * is non-optional so that the renderer can create a result synchronously even when application
-   * runs in a different context (e.g. in a Web Worker).
-   *
-   * Returns an instance of {@link RenderViewWithFragments}, representing the Render View.
-   */
-  abstract createView(protoViewRef: RenderProtoViewRef,
-                      fragmentCount: number): RenderViewWithFragments;
-
-  /**
-   * Destroys a Render View specified via `viewRef`.
-   *
-   * This operation should be performed only on a View that has already been dehydrated and
-   * all of its Render Fragments have been detached.
-   *
-   * Destroying a View indicates to the Renderer that this View is not going to be referenced in any
-   * future operations. If the Renderer created any renderer-specific objects for this View, these
-   * objects should now be destroyed to prevent memory leaks.
-   */
-  abstract destroyView(viewRef: RenderViewRef);
-
-  /**
-   * Attaches the Nodes of a Render Fragment after the last Node of `previousFragmentRef`.
-   */
-  abstract attachFragmentAfterFragment(previousFragmentRef: RenderFragmentRef,
-                                       fragmentRef: RenderFragmentRef);
-
-  /**
-   * Attaches the Nodes of the Render Fragment after an Element.
-   */
-  abstract attachFragmentAfterElement(elementRef: RenderElementRef, fragmentRef: RenderFragmentRef);
 
-  /**
-   * Detaches the Nodes of a Render Fragment from their parent.
-   *
-   * This operations should be called only on a View that has been already
-   * {@link #dehydrateView dehydrated}.
-   */
-  abstract detachFragment(fragmentRef: RenderFragmentRef);
-
-  /**
-   * Notifies a custom Renderer to initialize a Render View.
-   *
-   * This method is called by Angular after a Render View has been created, or when a previously
-   * dehydrated Render View is about to be reused.
-   */
-  abstract hydrateView(viewRef: RenderViewRef);
-
-  /**
-   * Notifies a custom Renderer that a Render View is no longer active.
-   *
-   * This method is called by Angular before a Render View will be destroyed, or when a hydrated
-   * Render View is about to be put into a pool for future reuse.
-   */
-  abstract dehydrateView(viewRef: RenderViewRef);
-
-  /**
-   * Returns the underlying native element at the specified `location`, or `null` if direct access
-   * to native elements is not supported (e.g. when the application runs in a web worker).
-   *
-   * <div class="callout is-critical">
-   *   <header>Use with caution</header>
-   *   <p>
-   *    Use this api as the last resort when direct access to DOM is needed. Use templating and
-   *    data-binding, or other {@link Renderer} methods instead.
-   *   </p>
-   *   <p>
-   *    Relying on direct DOM access creates tight coupling between your application and rendering
-   *    layers which will make it impossible to separate the two and deploy your application into a
-   *    web worker.
-   *   </p>
-   * </div>
-   */
-  abstract getNativeElementSync(location: RenderElementRef): any;
-
-  /**
-   * Sets a property on the Element specified via `location`.
-   */
-  abstract setElementProperty(location: RenderElementRef, propertyName: string, propertyValue: any);
-
-  /**
-   * Sets an attribute on the Element specified via `location`.
-   *
-   * If `attributeValue` is `null`, the attribute is removed.
-   */
-  abstract setElementAttribute(location: RenderElementRef, attributeName: string,
-                               attributeValue: string);
-
-  abstract setBindingDebugInfo(location: RenderElementRef, propertyName: string,
-                               propertyValue: string);
-
-  /**
-   * Sets a (CSS) class on the Element specified via `location`.
-   *
-   * `isAdd` specifies if the class should be added or removed.
-   */
-  abstract setElementClass(location: RenderElementRef, className: string, isAdd: boolean);
-
-  /**
-   * Sets a (CSS) inline style on the Element specified via `location`.
-   *
-   * If `styleValue` is `null`, the style is removed.
-   */
-  abstract setElementStyle(location: RenderElementRef, styleName: string, styleValue: string);
-
-  /**
-   * Calls a method on the Element specified via `location`.
-   */
-  abstract invokeElementMethod(location: RenderElementRef, methodName: string, args: any[]);
-
-  /**
-   * Sets the value of an interpolated TextNode at the specified index to the `text` value.
-   *
-   * `textNodeIndex` is the depth-first index of the Node among interpolated Nodes in the Render
-   * View.
-   */
-  abstract setText(viewRef: RenderViewRef, textNodeIndex: number, text: string);
-
-  /**
-   * Sets a dispatcher to relay all events triggered in the given Render View.
-   *
-   * Each Render View can have only one Event Dispatcher, if this method is called multiple times,
-   * the last provided dispatcher will be used.
-   */
-  abstract setEventDispatcher(viewRef: RenderViewRef, dispatcher: RenderEventDispatcher);
-}
-
-/**
- * A dispatcher that relays all events that occur in a Render View.
- *
- * Use {@link Renderer#setEventDispatcher} to register a dispatcher for a particular Render View.
- */
-export interface RenderEventDispatcher {
-  /**
-   * Called when Event called `eventName` was triggered on an Element with an Event Binding for this
-   * Event.
-   *
-   * `elementIndex` specifies the depth-first index of the Element in the Render View.
-   *
-   * `locals` is a map for local variable to value mapping that should be used when evaluating the
-   * Event Binding expression.
-   *
-   * Returns `false` if `preventDefault` should be called to stop the default behavior of the Event
-   * in the Rendering Context.
-   */
-  dispatchRenderEvent(elementIndex: number, eventName: string, locals: Map<string, any>): boolean;
+export abstract class RootRenderer implements ParentRenderer {
+  abstract renderComponent(componentType: RenderComponentType): Renderer;
 }
diff --git a/modules/angular2/src/core/render/view.ts b/modules/angular2/src/core/render/view.ts
deleted file mode 100644
index 0e47b7f..0000000
--- a/modules/angular2/src/core/render/view.ts
+++ /dev/null
@@ -1,65 +0,0 @@
-import {BaseException} from 'angular2/src/facade/exceptions';
-import {ListWrapper, MapWrapper, Map, StringMapWrapper} from 'angular2/src/facade/collection';
-import {isPresent, isBlank, stringify} from 'angular2/src/facade/lang';
-
-import {
-  RenderComponentTemplate,
-  RenderViewRef,
-  RenderEventDispatcher,
-  RenderTemplateCmd,
-  RenderProtoViewRef,
-  RenderFragmentRef
-} from './api';
-
-export class DefaultProtoViewRef extends RenderProtoViewRef {
-  constructor(public template: RenderComponentTemplate, public cmds: RenderTemplateCmd[]) {
-    super();
-  }
-}
-
-export class DefaultRenderFragmentRef<N> extends RenderFragmentRef {
-  constructor(public nodes: N[]) { super(); }
-}
-
-export class DefaultRenderView<N> extends RenderViewRef {
-  hydrated: boolean = false;
-  eventDispatcher: RenderEventDispatcher = null;
-  globalEventRemovers: Function[] = null;
-
-  constructor(public fragments: DefaultRenderFragmentRef<N>[], public boundTextNodes: N[],
-              public boundElements: N[], public nativeShadowRoots: N[],
-              public globalEventAdders: Function[], public rootContentInsertionPoints: N[]) {
-    super();
-  }
-
-  hydrate() {
-    if (this.hydrated) throw new BaseException('The view is already hydrated.');
-    this.hydrated = true;
-    this.globalEventRemovers = ListWrapper.createFixedSize(this.globalEventAdders.length);
-    for (var i = 0; i < this.globalEventAdders.length; i++) {
-      this.globalEventRemovers[i] = this.globalEventAdders[i]();
-    }
-  }
-
-  dehydrate() {
-    if (!this.hydrated) throw new BaseException('The view is already dehydrated.');
-    for (var i = 0; i < this.globalEventRemovers.length; i++) {
-      this.globalEventRemovers[i]();
-    }
-    this.globalEventRemovers = null;
-    this.hydrated = false;
-  }
-
-  setEventDispatcher(dispatcher: RenderEventDispatcher) { this.eventDispatcher = dispatcher; }
-
-  dispatchRenderEvent(boundElementIndex: number, eventName: string, event: any): boolean {
-    var allowDefaultBehavior = true;
-    if (isPresent(this.eventDispatcher)) {
-      var locals = new Map<string, any>();
-      locals.set('$event', event);
-      allowDefaultBehavior =
-          this.eventDispatcher.dispatchRenderEvent(boundElementIndex, eventName, locals);
-    }
-    return allowDefaultBehavior;
-  }
-}
diff --git a/modules/angular2/src/core/render/view_factory.ts b/modules/angular2/src/core/render/view_factory.ts
deleted file mode 100644
index d401c26..0000000
--- a/modules/angular2/src/core/render/view_factory.ts
+++ /dev/null
@@ -1,321 +0,0 @@
-import {isBlank, isPresent, StringWrapper} from 'angular2/src/facade/lang';
-import {
-  RenderEventDispatcher,
-  RenderTemplateCmd,
-  RenderCommandVisitor,
-  RenderBeginElementCmd,
-  RenderBeginComponentCmd,
-  RenderNgContentCmd,
-  RenderTextCmd,
-  RenderEmbeddedTemplateCmd,
-  RenderComponentTemplate
-} from './api';
-import {DefaultRenderView, DefaultRenderFragmentRef} from './view';
-import {ViewEncapsulation} from 'angular2/src/core/metadata';
-import {ListWrapper} from 'angular2/src/facade/collection';
-
-
-export function encapsulateStyles(componentTemplate: RenderComponentTemplate): string[] {
-  var processedStyles = componentTemplate.styles;
-  if (componentTemplate.encapsulation === ViewEncapsulation.Emulated) {
-    processedStyles = ListWrapper.createFixedSize(componentTemplate.styles.length);
-    for (var i = 0; i < componentTemplate.styles.length; i++) {
-      processedStyles[i] = StringWrapper.replaceAll(componentTemplate.styles[i], COMPONENT_REGEX,
-                                                    componentTemplate.shortId);
-    }
-  }
-  return processedStyles;
-}
-
-export function createRenderView(componentTemplate: RenderComponentTemplate,
-                                 cmds: RenderTemplateCmd[], inplaceElement: any,
-                                 nodeFactory: NodeFactory<any>): DefaultRenderView<any> {
-  var view: DefaultRenderView<any>;
-  var eventDispatcher = (boundElementIndex: number, eventName: string, event: any) =>
-      view.dispatchRenderEvent(boundElementIndex, eventName, event);
-  var context = new BuildContext(eventDispatcher, nodeFactory, inplaceElement);
-  context.build(componentTemplate, cmds);
-  var fragments: DefaultRenderFragmentRef<any>[] = [];
-  for (var i = 0; i < context.fragments.length; i++) {
-    fragments.push(new DefaultRenderFragmentRef(context.fragments[i]));
-  }
-  view = new DefaultRenderView<any>(fragments, context.boundTextNodes, context.boundElements,
-                                    context.nativeShadowRoots, context.globalEventAdders,
-                                    context.rootContentInsertionPoints);
-  return view;
-}
-
-export interface NodeFactory<N> {
-  resolveComponentTemplate(templateId: string): RenderComponentTemplate;
-  createTemplateAnchor(attrNameAndValues: string[]): N;
-  createElement(name: string, attrNameAndValues: string[]): N;
-  createRootContentInsertionPoint(): N;
-  mergeElement(existing: N, attrNameAndValues: string[]);
-  createShadowRoot(host: N, templateId: string): N;
-  createText(value: string): N;
-  appendChild(parent: N, child: N);
-  on(element: N, eventName: string, callback: Function);
-  globalOn(target: string, eventName: string, callback: Function): Function;
-}
-
-class BuildContext<N> {
-  constructor(private _eventDispatcher: Function, public factory: NodeFactory<N>,
-              private _inplaceElement: N) {
-    this.isHost = isPresent((_inplaceElement));
-  }
-  private _builders: RenderViewBuilder<N>[] = [];
-
-  globalEventAdders: Function[] = [];
-  boundElements: N[] = [];
-  boundTextNodes: N[] = [];
-  nativeShadowRoots: N[] = [];
-  fragments: N[][] = [];
-  rootContentInsertionPoints: N[] = [];
-  componentCount: number = 0;
-  isHost: boolean;
-
-  build(template: RenderComponentTemplate, cmds: RenderTemplateCmd[]) {
-    this.enqueueRootBuilder(template, cmds);
-    this._build(this._builders[0]);
-  }
-
-  private _build(builder: RenderViewBuilder<N>) {
-    this._builders = [];
-    builder.build(this);
-    var enqueuedBuilders = this._builders;
-    for (var i = 0; i < enqueuedBuilders.length; i++) {
-      this._build(enqueuedBuilders[i]);
-    }
-  }
-
-  enqueueComponentBuilder(component: Component<N>) {
-    this.componentCount++;
-    this._builders.push(
-        new RenderViewBuilder<N>(component, null, component.template, component.template.commands));
-  }
-
-  enqueueFragmentBuilder(parentComponent: Component<N>, parentTemplate: RenderComponentTemplate,
-                         commands: RenderTemplateCmd[]) {
-    var rootNodes = [];
-    this.fragments.push(rootNodes);
-    this._builders.push(
-        new RenderViewBuilder<N>(parentComponent, rootNodes, parentTemplate, commands));
-  }
-
-  enqueueRootBuilder(template: RenderComponentTemplate, cmds: RenderTemplateCmd[]) {
-    var rootNodes = [];
-    this.fragments.push(rootNodes);
-    this._builders.push(new RenderViewBuilder<N>(null, rootNodes, template, cmds));
-  }
-
-  consumeInplaceElement(): N {
-    var result = this._inplaceElement;
-    this._inplaceElement = null;
-    return result;
-  }
-
-  addEventListener(boundElementIndex: number, target: string, eventName: string) {
-    if (isPresent(target)) {
-      var handler =
-          createEventHandler(boundElementIndex, `${target}:${eventName}`, this._eventDispatcher);
-      this.globalEventAdders.push(createGlobalEventAdder(target, eventName, handler, this.factory));
-    } else {
-      var handler = createEventHandler(boundElementIndex, eventName, this._eventDispatcher);
-      this.factory.on(this.boundElements[boundElementIndex], eventName, handler);
-    }
-  }
-}
-
-
-function createEventHandler(boundElementIndex: number, eventName: string,
-                            eventDispatcher: Function): Function {
-  return ($event) => eventDispatcher(boundElementIndex, eventName, $event);
-}
-
-function createGlobalEventAdder(target: string, eventName: string, eventHandler: Function,
-                                nodeFactory: NodeFactory<any>): Function {
-  return () => nodeFactory.globalOn(target, eventName, eventHandler);
-}
-
-class RenderViewBuilder<N> implements RenderCommandVisitor {
-  parentStack: Array<N | Component<N>>;
-
-  constructor(public parentComponent: Component<N>, public fragmentRootNodes: N[],
-              public template: RenderComponentTemplate, public cmds: RenderTemplateCmd[]) {
-    var rootNodesParent = isPresent(fragmentRootNodes) ? null : parentComponent.shadowRoot;
-    this.parentStack = [rootNodesParent];
-  }
-
-  build(context: BuildContext<N>) {
-    var cmds = this.cmds;
-    for (var i = 0; i < cmds.length; i++) {
-      cmds[i].visit(this, context);
-    }
-  }
-
-  get parent(): N | Component<N> { return this.parentStack[this.parentStack.length - 1]; }
-
-  visitText(cmd: RenderTextCmd, context: BuildContext<N>): any {
-    var text = context.factory.createText(cmd.value);
-    this._addChild(text, cmd.ngContentIndex, context);
-    if (cmd.isBound) {
-      context.boundTextNodes.push(text);
-    }
-    return null;
-  }
-  visitNgContent(cmd: RenderNgContentCmd, context: BuildContext<N>): any {
-    if (isPresent(this.parentComponent)) {
-      if (this.parentComponent.isRoot) {
-        var insertionPoint = context.factory.createRootContentInsertionPoint();
-        if (this.parent instanceof Component) {
-          context.factory.appendChild((<Component<N>>this.parent).shadowRoot, insertionPoint);
-        } else {
-          context.factory.appendChild(<N>this.parent, insertionPoint);
-        }
-        context.rootContentInsertionPoints.push(insertionPoint);
-      } else {
-        var projectedNodes = this.parentComponent.project(cmd.index);
-        for (var i = 0; i < projectedNodes.length; i++) {
-          var node = projectedNodes[i];
-          this._addChild(node, cmd.ngContentIndex, context);
-        }
-      }
-    }
-    return null;
-  }
-  visitBeginElement(cmd: RenderBeginElementCmd, context: BuildContext<N>): any {
-    this.parentStack.push(this._beginElement(cmd, context, null));
-    return null;
-  }
-  visitEndElement(context: BuildContext<N>): any {
-    this._endElement();
-    return null;
-  }
-  visitBeginComponent(cmd: RenderBeginComponentCmd, context: BuildContext<N>): any {
-    var templateId = cmd.templateId;
-    var tpl = context.factory.resolveComponentTemplate(templateId);
-    var el = this._beginElement(cmd, context, tpl);
-    var root = el;
-
-    if (tpl.encapsulation === ViewEncapsulation.Native) {
-      root = context.factory.createShadowRoot(el, templateId);
-      context.nativeShadowRoots.push(root);
-    }
-    var isRoot = context.componentCount === 0 && context.isHost;
-    var component = new Component(el, root, isRoot, tpl);
-    context.enqueueComponentBuilder(component);
-    this.parentStack.push(component);
-    return null;
-  }
-  visitEndComponent(context: BuildContext<N>): any {
-    this._endElement();
-    return null;
-  }
-  visitEmbeddedTemplate(cmd: RenderEmbeddedTemplateCmd, context: BuildContext<N>): any {
-    var el = context.factory.createTemplateAnchor(cmd.attrNameAndValues);
-    this._addChild(el, cmd.ngContentIndex, context);
-    context.boundElements.push(el);
-    if (cmd.isMerged) {
-      context.enqueueFragmentBuilder(this.parentComponent, this.template, cmd.children);
-    }
-    return null;
-  }
-
-  private _beginElement(cmd: RenderBeginElementCmd, context: BuildContext<N>,
-                        componentTemplate: RenderComponentTemplate): N {
-    var el: N = context.consumeInplaceElement();
-    var attrNameAndValues = cmd.attrNameAndValues;
-    var templateEmulatedEncapsulation = this.template.encapsulation === ViewEncapsulation.Emulated;
-    var componentEmulatedEncapsulation =
-        isPresent(componentTemplate) &&
-        componentTemplate.encapsulation === ViewEncapsulation.Emulated;
-    var newAttrLength = attrNameAndValues.length + (templateEmulatedEncapsulation ? 2 : 0) +
-                        (componentEmulatedEncapsulation ? 2 : 0);
-    if (newAttrLength > attrNameAndValues.length) {
-      // Note: Need to clone attrNameAndValues to make it writable!
-      var newAttrNameAndValues = ListWrapper.createFixedSize(newAttrLength);
-      var attrIndex;
-      for (attrIndex = 0; attrIndex < attrNameAndValues.length; attrIndex++) {
-        newAttrNameAndValues[attrIndex] = attrNameAndValues[attrIndex];
-      }
-      if (templateEmulatedEncapsulation) {
-        newAttrNameAndValues[attrIndex++] = _shimContentAttribute(this.template.shortId);
-        newAttrNameAndValues[attrIndex++] = '';
-      }
-      if (componentEmulatedEncapsulation) {
-        newAttrNameAndValues[attrIndex++] = _shimHostAttribute(componentTemplate.shortId);
-        newAttrNameAndValues[attrIndex++] = '';
-      }
-      attrNameAndValues = newAttrNameAndValues;
-    }
-    if (isPresent(el)) {
-      context.factory.mergeElement(el, attrNameAndValues);
-      this.fragmentRootNodes.push(el);
-    } else {
-      el = context.factory.createElement(cmd.name, attrNameAndValues);
-      this._addChild(el, cmd.ngContentIndex, context);
-    }
-    if (cmd.isBound) {
-      var boundElementIndex = context.boundElements.length;
-      context.boundElements.push(el);
-      for (var i = 0; i < cmd.eventTargetAndNames.length; i += 2) {
-        var target = cmd.eventTargetAndNames[i];
-        var eventName = cmd.eventTargetAndNames[i + 1];
-        context.addEventListener(boundElementIndex, target, eventName);
-      }
-    }
-    return el;
-  }
-
-  private _endElement() { this.parentStack.pop(); }
-
-  private _addChild(node: N, ngContentIndex: number, context: BuildContext<N>) {
-    var parent = this.parent;
-    if (isPresent(parent)) {
-      if (parent instanceof Component) {
-        parent.addContentNode(ngContentIndex, node, context);
-      } else {
-        context.factory.appendChild(<N>parent, node);
-      }
-    } else {
-      this.fragmentRootNodes.push(node);
-    }
-  }
-}
-
-class Component<N> {
-  private contentNodesByNgContentIndex: N[][] = [];
-
-  constructor(public hostElement: N, public shadowRoot: N, public isRoot: boolean,
-              public template: RenderComponentTemplate) {}
-  addContentNode(ngContentIndex: number, node: N, context: BuildContext<N>) {
-    if (isBlank(ngContentIndex)) {
-      if (this.template.encapsulation === ViewEncapsulation.Native) {
-        context.factory.appendChild(this.hostElement, node);
-      }
-    } else {
-      while (this.contentNodesByNgContentIndex.length <= ngContentIndex) {
-        this.contentNodesByNgContentIndex.push([]);
-      }
-      this.contentNodesByNgContentIndex[ngContentIndex].push(node);
-    }
-  }
-  project(ngContentIndex: number): N[] {
-    return ngContentIndex < this.contentNodesByNgContentIndex.length ?
-               this.contentNodesByNgContentIndex[ngContentIndex] :
-               [];
-  }
-}
-
-var COMPONENT_REGEX = /%COMP%/g;
-export const COMPONENT_VARIABLE = '%COMP%';
-export const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
-export const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
-
-function _shimContentAttribute(componentShortId: string): string {
-  return StringWrapper.replaceAll(CONTENT_ATTR, COMPONENT_REGEX, componentShortId);
-}
-
-function _shimHostAttribute(componentShortId: string): string {
-  return StringWrapper.replaceAll(HOST_ATTR, COMPONENT_REGEX, componentShortId);
-}
diff --git a/modules/angular2/src/core/util/decorators.ts b/modules/angular2/src/core/util/decorators.ts
index 5944745..54f50fa 100644
--- a/modules/angular2/src/core/util/decorators.ts
+++ b/modules/angular2/src/core/util/decorators.ts
@@ -1,5 +1,7 @@
 import {ConcreteType, global, Type, isFunction, stringify} from 'angular2/src/facade/lang';
 
+var _nextClassId = 0;
+
 /**
  * Declares the interface to be used with {@link Class}.
  */
@@ -228,6 +230,10 @@ export function Class(clsDef: ClassDefinition): ConcreteType {
     Reflect.defineMetadata('annotations', this.annotations, constructor);
   }
 
+  if (!constructor['name']) {
+    constructor['overriddenName'] = `class${_nextClassId++}`;
+  }
+
   return <ConcreteType>constructor;
 }
 
diff --git a/modules/angular2/src/facade/async.dart b/modules/angular2/src/facade/async.dart
index bc4f56d..5f8a196 100644
--- a/modules/angular2/src/facade/async.dart
+++ b/modules/angular2/src/facade/async.dart
@@ -50,7 +50,7 @@ class ObservableWrapper {
   static void callNext(EventEmitter emitter, value) {
     emitter.add(value);
   }
-  
+
   static void callEmit(EventEmitter emitter, value) {
     emitter.add(value);
   }
@@ -90,7 +90,7 @@ class EventEmitter<T> extends Stream<T> {
   void add(value) {
     _controller.add(value);
   }
-  
+
   void emit(value) {
     _controller.add(value);
   }
diff --git a/modules/angular2/src/facade/lang.dart b/modules/angular2/src/facade/lang.dart
index c806748..55f3f7c 100644
--- a/modules/angular2/src/facade/lang.dart
+++ b/modules/angular2/src/facade/lang.dart
@@ -331,3 +331,7 @@ class DateWrapper {
 
 // needed to match the exports from lang.js
 var global = null;
+
+dynamic evalExpression(String sourceUrl, String expr, String declarations, Map<String, String> vars) {
+  throw "Dart does not support evaluating expression during runtime!";
+}
\ No newline at end of file
diff --git a/modules/angular2/src/facade/lang.ts b/modules/angular2/src/facade/lang.ts
index 3d741d1..7c83209 100644
--- a/modules/angular2/src/facade/lang.ts
+++ b/modules/angular2/src/facade/lang.ts
@@ -141,6 +141,9 @@ export function stringify(token): string {
   if (token.name) {
     return token.name;
   }
+  if (token.overriddenName) {
+    return token.overriddenName;
+  }
 
   var res = token.toString();
   var newLineIndex = res.indexOf("\n");
@@ -412,3 +415,15 @@ export function getSymbolIterator(): string | symbol {
   }
   return _symbolIterator;
 }
+
+export function evalExpression(sourceUrl: string, expr: string, declarations: string,
+                               vars: {[key: string]: any}): any {
+  var fnBody = `${declarations}\nreturn ${expr}\n//# sourceURL=${sourceUrl}`;
+  var fnArgNames = [];
+  var fnArgValues = [];
+  for (var argName in vars) {
+    fnArgNames.push(argName);
+    fnArgValues.push(vars[argName]);
+  }
+  return new Function(...fnArgNames.concat(fnBody))(...fnArgValues);
+}
diff --git a/modules/angular2/src/platform/browser_common.ts b/modules/angular2/src/platform/browser_common.ts
index d99a2d7..8dd0b3d 100644
--- a/modules/angular2/src/platform/browser_common.ts
+++ b/modules/angular2/src/platform/browser_common.ts
@@ -9,7 +9,7 @@ import {
   platform,
   ExceptionHandler,
   Reflector,
-  Renderer,
+  RootRenderer,
   reflector,
   APPLICATION_COMMON_PROVIDERS,
   PLATFORM_COMMON_PROVIDERS
@@ -21,7 +21,7 @@ import {DomEventsPlugin} from 'angular2/src/platform/dom/events/dom_events';
 import {KeyEventsPlugin} from 'angular2/src/platform/dom/events/key_events';
 import {HammerGesturesPlugin} from 'angular2/src/platform/dom/events/hammer_gestures';
 import {DOCUMENT} from 'angular2/src/platform/dom/dom_tokens';
-import {DomRenderer, DomRenderer_} from 'angular2/src/platform/dom/dom_renderer';
+import {DomRootRenderer, DomRootRenderer_} from 'angular2/src/platform/dom/dom_renderer';
 import {DomSharedStylesHost} from 'angular2/src/platform/dom/shared_styles_host';
 import {SharedStylesHost} from "angular2/src/platform/dom/shared_styles_host";
 import {BrowserDetails} from "angular2/src/animate/browser_details";
@@ -77,8 +77,8 @@ export const BROWSER_APP_COMMON_PROVIDERS: Array<any /*Type | Provider | any[]*/
   new Provider(EVENT_MANAGER_PLUGINS, {useClass: DomEventsPlugin, multi: true}),
   new Provider(EVENT_MANAGER_PLUGINS, {useClass: KeyEventsPlugin, multi: true}),
   new Provider(EVENT_MANAGER_PLUGINS, {useClass: HammerGesturesPlugin, multi: true}),
-  new Provider(DomRenderer, {useClass: DomRenderer_}),
-  new Provider(Renderer, {useExisting: DomRenderer}),
+  new Provider(DomRootRenderer, {useClass: DomRootRenderer_}),
+  new Provider(RootRenderer, {useExisting: DomRootRenderer}),
   new Provider(SharedStylesHost, {useExisting: DomSharedStylesHost}),
   DomSharedStylesHost,
   Testability,
diff --git a/modules/angular2/src/platform/dom/debug/debug_element_view_listener.ts b/modules/angular2/src/platform/dom/debug/debug_element_view_listener.ts
index 561e817..ff2cc02 100644
--- a/modules/angular2/src/platform/dom/debug/debug_element_view_listener.ts
+++ b/modules/angular2/src/platform/dom/debug/debug_element_view_listener.ts
@@ -4,7 +4,6 @@ import {Injectable, provide, Provider} from 'angular2/src/core/di';
 import {AppViewListener} from 'angular2/src/core/linker/view_listener';
 import {AppView} from 'angular2/src/core/linker/view';
 import {DOM} from 'angular2/src/platform/dom/dom_adapter';
-import {Renderer} from 'angular2/src/core/render/api';
 import {DebugElement, DebugElement_} from 'angular2/src/core/debug/debug_element';
 
 const NG_ID_PROPERTY = 'ngid';
@@ -43,7 +42,7 @@ export function inspectNativeElement(element): DebugElement {
   if (isPresent(elId)) {
     var view = _allViewsById.get(elId[0]);
     if (isPresent(view)) {
-      return new DebugElement_(view, elId[1]);
+      return new DebugElement_(view.appElements[elId[1]]);
     }
   }
   return null;
@@ -51,17 +50,15 @@ export function inspectNativeElement(element): DebugElement {
 
 @Injectable()
 export class DebugElementViewListener implements AppViewListener {
-  constructor(private _renderer: Renderer) {
-    DOM.setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
-  }
+  constructor() { DOM.setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement); }
 
   onViewCreated(view: AppView) {
     var viewId = _nextId++;
     _allViewsById.set(viewId, view);
     _allIdsByView.set(view, viewId);
-    for (var i = 0; i < view.elementRefs.length; i++) {
-      var el = view.elementRefs[i];
-      _setElementId(this._renderer.getNativeElementSync(el), [viewId, i]);
+    for (var i = 0; i < view.appElements.length; i++) {
+      var el = view.appElements[i];
+      _setElementId(el.nativeElement, [viewId, i]);
     }
   }
 
diff --git a/modules/angular2/src/platform/dom/dom_renderer.ts b/modules/angular2/src/platform/dom/dom_renderer.ts
index 17f3040..93d8f27 100644
--- a/modules/angular2/src/platform/dom/dom_renderer.ts
+++ b/modules/angular2/src/platform/dom/dom_renderer.ts
@@ -7,38 +7,18 @@ import {
   RegExpWrapper,
   CONST_EXPR,
   stringify,
-  StringWrapper
+  StringWrapper,
+  isArray
 } from 'angular2/src/facade/lang';
 
 import {BaseException, WrappedException} from 'angular2/src/facade/exceptions';
 import {DomSharedStylesHost} from './shared_styles_host';
-import {WtfScopeFn, wtfLeave, wtfCreateScope} from 'angular2/src/core/profile/profile';
 
-import {
-  Renderer,
-  RenderProtoViewRef,
-  RenderViewRef,
-  RenderElementRef,
-  RenderFragmentRef,
-  RenderViewWithFragments,
-  RenderTemplateCmd,
-  RenderEventDispatcher,
-  RenderComponentTemplate
-} from 'angular2/core';
+import {Renderer, RootRenderer, RenderComponentType} from 'angular2/core';
 
 import {EventManager} from './events/event_manager';
 
 import {DOCUMENT} from './dom_tokens';
-import {
-  createRenderView,
-  NodeFactory,
-  encapsulateStyles
-} from 'angular2/src/core/render/view_factory';
-import {
-  DefaultRenderView,
-  DefaultRenderFragmentRef,
-  DefaultProtoViewRef
-} from 'angular2/src/core/render/view';
 import {ViewEncapsulation} from 'angular2/src/core/metadata';
 import {DOM} from 'angular2/src/platform/dom/dom_adapter';
 import {camelCaseToDashCase} from './util';
@@ -48,243 +28,225 @@ const NAMESPACE_URIS =
 const TEMPLATE_COMMENT_TEXT = 'template bindings={}';
 var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/g;
 
-export abstract class DomRenderer extends Renderer implements NodeFactory<Node> {
-  abstract registerComponentTemplate(template: RenderComponentTemplate);
-
-  abstract resolveComponentTemplate(templateId: string): RenderComponentTemplate;
-
-  abstract createProtoView(componentTemplateId: string,
-                           cmds: RenderTemplateCmd[]): RenderProtoViewRef;
+export abstract class DomRootRenderer implements RootRenderer {
+  private _registeredComponents: Map<string, DomRenderer> = new Map<string, DomRenderer>();
 
-  abstract createRootHostView(hostProtoViewRef: RenderProtoViewRef, fragmentCount: number,
-                              hostElementSelector: string): RenderViewWithFragments;
+  constructor(public document: any, public eventManager: EventManager,
+              public sharedStylesHost: DomSharedStylesHost, public animate: AnimationBuilder) {}
 
-  abstract createView(protoViewRef: RenderProtoViewRef,
-                      fragmentCount: number): RenderViewWithFragments;
-
-  abstract destroyView(viewRef: RenderViewRef);
-
-  abstract createRootContentInsertionPoint();
-
-  getNativeElementSync(location: RenderElementRef): any {
-    return resolveInternalDomView(location.renderView).boundElements[location.boundElementIndex];
-  }
-
-  getRootNodes(fragment: RenderFragmentRef): Node[] { return resolveInternalDomFragment(fragment); }
-
-  attachFragmentAfterFragment(previousFragmentRef: RenderFragmentRef,
-                              fragmentRef: RenderFragmentRef) {
-    var previousFragmentNodes = resolveInternalDomFragment(previousFragmentRef);
-    if (previousFragmentNodes.length > 0) {
-      var sibling = previousFragmentNodes[previousFragmentNodes.length - 1];
-      let nodes = resolveInternalDomFragment(fragmentRef);
-      moveNodesAfterSibling(sibling, nodes);
-      this.animateNodesEnter(nodes);
+  renderComponent(componentProto: RenderComponentType): Renderer {
+    var renderer = this._registeredComponents.get(componentProto.id);
+    if (isBlank(renderer)) {
+      renderer = new DomRenderer(this, componentProto);
+      this._registeredComponents.set(componentProto.id, renderer);
     }
+    return renderer;
   }
+}
 
-  /**
-   * Iterates through all nodes being added to the DOM and animates them if necessary
-   * @param nodes
-   */
-  animateNodesEnter(nodes: Node[]) {
-    for (let i = 0; i < nodes.length; i++) this.animateNodeEnter(nodes[i]);
+@Injectable()
+export class DomRootRenderer_ extends DomRootRenderer {
+  constructor(@Inject(DOCUMENT) _document: any, _eventManager: EventManager,
+              sharedStylesHost: DomSharedStylesHost, animate: AnimationBuilder) {
+    super(_document, _eventManager, sharedStylesHost, animate);
   }
+}
 
-  /**
-   * Performs animations if necessary
-   * @param node
-   */
-  abstract animateNodeEnter(node: Node);
+export class DomRenderer implements Renderer {
+  private _contentAttr: string;
+  private _hostAttr: string;
+  private _styles: string[];
 
-  /**
-   * If animations are necessary, performs animations then removes the element; otherwise, it just
-   * removes the element.
-   * @param node
-   */
-  abstract animateNodeLeave(node: Node);
-
-  attachFragmentAfterElement(elementRef: RenderElementRef, fragmentRef: RenderFragmentRef) {
-    var parentView = resolveInternalDomView(elementRef.renderView);
-    var element = parentView.boundElements[elementRef.boundElementIndex];
-    var nodes = resolveInternalDomFragment(fragmentRef);
-    moveNodesAfterSibling(element, nodes);
-    this.animateNodesEnter(nodes);
+  constructor(private _rootRenderer: DomRootRenderer, private componentProto: RenderComponentType) {
+    this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);
+    if (componentProto.encapsulation !== ViewEncapsulation.Native) {
+      this._rootRenderer.sharedStylesHost.addStyles(this._styles);
+    }
+    if (this.componentProto.encapsulation === ViewEncapsulation.Emulated) {
+      this._contentAttr = _shimContentAttribute(componentProto.id);
+      this._hostAttr = _shimHostAttribute(componentProto.id);
+    } else {
+      this._contentAttr = null;
+      this._hostAttr = null;
+    }
   }
 
-  abstract detachFragment(fragmentRef: RenderFragmentRef);
-
-  hydrateView(viewRef: RenderViewRef) { resolveInternalDomView(viewRef).hydrate(); }
-
-  dehydrateView(viewRef: RenderViewRef) { resolveInternalDomView(viewRef).dehydrate(); }
-
-  createTemplateAnchor(attrNameAndValues: string[]): Node {
-    return DOM.createComment(TEMPLATE_COMMENT_TEXT);
-  }
-  abstract createElement(name: string, attrNameAndValues: string[]): Node;
-  abstract mergeElement(existing: Node, attrNameAndValues: string[]);
-  abstract createShadowRoot(host: Node, templateId: string): Node;
-  createText(value: string): Node { return DOM.createTextNode(isPresent(value) ? value : ''); }
-  appendChild(parent: Node, child: Node) { DOM.appendChild(parent, child); }
-  abstract on(element: Node, eventName: string, callback: Function);
-  abstract globalOn(target: string, eventName: string, callback: Function): Function;
-
-  setElementProperty(location: RenderElementRef, propertyName: string, propertyValue: any): void {
-    var view = resolveInternalDomView(location.renderView);
-    DOM.setProperty(<Element>view.boundElements[location.boundElementIndex], propertyName,
-                    propertyValue);
+  renderComponent(componentProto: RenderComponentType): Renderer {
+    return this._rootRenderer.renderComponent(componentProto);
   }
 
-  setElementAttribute(location: RenderElementRef, attributeName: string,
-                      attributeValue: string): void {
-    var view = resolveInternalDomView(location.renderView);
-    var element = view.boundElements[location.boundElementIndex];
-    if (isPresent(attributeValue)) {
-      DOM.setAttribute(element, attributeName, stringify(attributeValue));
-    } else {
-      DOM.removeAttribute(element, attributeName);
+  selectRootElement(selector: string): Element {
+    var el = DOM.querySelector(this._rootRenderer.document, selector);
+    if (isBlank(el)) {
+      throw new BaseException(`The selector "${selector}" did not match any elements`);
     }
+    DOM.clearNodes(el);
+    return el;
   }
 
-  /**
-   * Used only in debug mode to serialize property changes to comment nodes,
-   * such as <template> placeholders.
-   */
-  setBindingDebugInfo(location: RenderElementRef, propertyName: string,
-                      propertyValue: string): void {
-    var view: DefaultRenderView<Node> = resolveInternalDomView(location.renderView);
-    var element = view.boundElements[location.boundElementIndex];
-    var dashCasedPropertyName = camelCaseToDashCase(propertyName);
-    if (DOM.isCommentNode(element)) {
-      var existingBindings = RegExpWrapper.firstMatch(
-          TEMPLATE_BINDINGS_EXP, StringWrapper.replaceAll(DOM.getText(element), /\n/g, ''));
-      var parsedBindings = Json.parse(existingBindings[1]);
-      parsedBindings[dashCasedPropertyName] = propertyValue;
-      DOM.setText(element, StringWrapper.replace(TEMPLATE_COMMENT_TEXT, '{}',
-                                                 Json.stringify(parsedBindings)));
-    } else {
-      this.setElementAttribute(location, propertyName, propertyValue);
+  createElement(parent: Element, name: string): Node {
+    var nsAndName = splitNamespace(name);
+    var el = isPresent(nsAndName[0]) ?
+                 DOM.createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :
+                 DOM.createElement(nsAndName[1]);
+    if (isPresent(this._contentAttr)) {
+      DOM.setAttribute(el, this._contentAttr, '');
+    }
+    if (isPresent(parent)) {
+      DOM.appendChild(parent, el);
     }
+    return el;
   }
 
-  setElementClass(location: RenderElementRef, className: string, isAdd: boolean): void {
-    var view = resolveInternalDomView(location.renderView);
-    var element = view.boundElements[location.boundElementIndex];
-    if (isAdd) {
-      DOM.addClass(element, className);
+  createViewRoot(hostElement: any): any {
+    var nodesParent;
+    if (this.componentProto.encapsulation === ViewEncapsulation.Native) {
+      nodesParent = DOM.createShadowRoot(hostElement);
+      this._rootRenderer.sharedStylesHost.addHost(nodesParent);
+      for (var i = 0; i < this._styles.length; i++) {
+        DOM.appendChild(nodesParent, DOM.createStyleElement(this._styles[i]));
+      }
     } else {
-      DOM.removeClass(element, className);
+      if (isPresent(this._hostAttr)) {
+        DOM.setAttribute(hostElement, this._hostAttr, '');
+      }
+      nodesParent = hostElement;
     }
+    return nodesParent;
   }
 
-  setElementStyle(location: RenderElementRef, styleName: string, styleValue: string): void {
-    var view = resolveInternalDomView(location.renderView);
-    var element = view.boundElements[location.boundElementIndex];
-    if (isPresent(styleValue)) {
-      DOM.setStyle(element, styleName, stringify(styleValue));
-    } else {
-      DOM.removeStyle(element, styleName);
+  createTemplateAnchor(parentElement: any): any {
+    var comment = DOM.createComment(TEMPLATE_COMMENT_TEXT);
+    if (isPresent(parentElement)) {
+      DOM.appendChild(parentElement, comment);
     }
+    return comment;
   }
 
-  invokeElementMethod(location: RenderElementRef, methodName: string, args: any[]): void {
-    var view = resolveInternalDomView(location.renderView);
-    var element = <Element>view.boundElements[location.boundElementIndex];
-    DOM.invoke(element, methodName, args);
+  createText(parentElement: any, value: string): any {
+    var node = DOM.createTextNode(value);
+    if (isPresent(parentElement)) {
+      DOM.appendChild(parentElement, node);
+    }
+    return node;
   }
 
-  setText(viewRef: RenderViewRef, textNodeIndex: number, text: string): void {
-    var view = resolveInternalDomView(viewRef);
-    DOM.setText(view.boundTextNodes[textNodeIndex], text);
+  projectNodes(parentElement: any, nodes: any[]) {
+    if (isBlank(parentElement)) return;
+    appendNodes(parentElement, nodes);
   }
 
-  setEventDispatcher(viewRef: RenderViewRef, dispatcher: RenderEventDispatcher): void {
-    resolveInternalDomView(viewRef).setEventDispatcher(dispatcher);
+  attachViewAfter(node: any, viewRootNodes: any[]) {
+    moveNodesAfterSibling(node, viewRootNodes);
+    for (let i = 0; i < viewRootNodes.length; i++) this.animateNodeEnter(viewRootNodes[i]);
   }
-}
 
-@Injectable()
-export class DomRenderer_ extends DomRenderer {
-  private _componentTpls: Map<string, RenderComponentTemplate> =
-      new Map<string, RenderComponentTemplate>();
-  private _document;
-
-  constructor(private _eventManager: EventManager,
-              private _domSharedStylesHost: DomSharedStylesHost, private _animate: AnimationBuilder,
-              @Inject(DOCUMENT) document) {
-    super();
-    this._document = document;
+  detachView(viewRootNodes: any[]) {
+    for (var i = 0; i < viewRootNodes.length; i++) {
+      var node = viewRootNodes[i];
+      DOM.remove(node);
+      this.animateNodeLeave(node);
+    }
   }
 
-  registerComponentTemplate(template: RenderComponentTemplate) {
-    this._componentTpls.set(template.id, template);
-    if (template.encapsulation !== ViewEncapsulation.Native) {
-      var encapsulatedStyles = encapsulateStyles(template);
-      this._domSharedStylesHost.addStyles(encapsulatedStyles);
+  destroyView(hostElement: any, viewAllNodes: any[]) {
+    if (this.componentProto.encapsulation === ViewEncapsulation.Native && isPresent(hostElement)) {
+      this._rootRenderer.sharedStylesHost.removeHost(DOM.getShadowRoot(hostElement));
     }
   }
 
-  createProtoView(componentTemplateId: string, cmds: RenderTemplateCmd[]): RenderProtoViewRef {
-    return new DefaultProtoViewRef(this._componentTpls.get(componentTemplateId), cmds);
+  listen(renderElement: any, name: string, callback: Function) {
+    this._rootRenderer.eventManager.addEventListener(renderElement, name,
+                                                     decoratePreventDefault(callback));
+  }
+
+  listenGlobal(target: string, name: string, callback: Function): Function {
+    return this._rootRenderer.eventManager.addGlobalEventListener(target, name,
+                                                                  decoratePreventDefault(callback));
   }
 
-  resolveComponentTemplate(templateId: string): RenderComponentTemplate {
-    return this._componentTpls.get(templateId);
+  setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void {
+    DOM.setProperty(renderElement, propertyName, propertyValue);
   }
 
-  /** @internal */
-  _createRootHostViewScope: WtfScopeFn = wtfCreateScope('DomRenderer#createRootHostView()');
-  createRootHostView(hostProtoViewRef: RenderProtoViewRef, fragmentCount: number,
-                     hostElementSelector: string): RenderViewWithFragments {
-    var s = this._createRootHostViewScope();
-    var element = DOM.querySelector(this._document, hostElementSelector);
-    if (isBlank(element)) {
-      wtfLeave(s);
-      throw new BaseException(`The selector "${hostElementSelector}" did not match any elements`);
+  setElementAttribute(renderElement: any, attributeName: string, attributeValue: string): void {
+    var attrNs;
+    var nsAndName = splitNamespace(attributeName);
+    if (isPresent(nsAndName[0])) {
+      attributeName = nsAndName[0] + ':' + nsAndName[1];
+      attrNs = NAMESPACE_URIS[nsAndName[0]];
+    }
+    if (isPresent(attributeValue)) {
+      if (isPresent(attrNs)) {
+        DOM.setAttributeNS(renderElement, attrNs, attributeName, attributeValue);
+      } else {
+        DOM.setAttribute(renderElement, nsAndName[1], attributeValue);
+      }
+    } else {
+      DOM.removeAttribute(renderElement, attributeName);
     }
-    return wtfLeave(s, this._createView(hostProtoViewRef, element));
   }
 
-  /** @internal */
-  _createViewScope = wtfCreateScope('DomRenderer#createView()');
-  createView(protoViewRef: RenderProtoViewRef, fragmentCount: number): RenderViewWithFragments {
-    var s = this._createViewScope();
-    return wtfLeave(s, this._createView(protoViewRef, null));
+  setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string): void {
+    var dashCasedPropertyName = camelCaseToDashCase(propertyName);
+    if (DOM.isCommentNode(renderElement)) {
+      var existingBindings = RegExpWrapper.firstMatch(
+          TEMPLATE_BINDINGS_EXP, StringWrapper.replaceAll(DOM.getText(renderElement), /\n/g, ''));
+      var parsedBindings = Json.parse(existingBindings[1]);
+      parsedBindings[dashCasedPropertyName] = propertyValue;
+      DOM.setText(renderElement, StringWrapper.replace(TEMPLATE_COMMENT_TEXT, '{}',
+                                                       Json.stringify(parsedBindings)));
+    } else {
+      this.setElementAttribute(renderElement, propertyName, propertyValue);
+    }
   }
 
-  private _createView(protoViewRef: RenderProtoViewRef,
-                      inplaceElement: HTMLElement): RenderViewWithFragments {
-    var dpvr = <DefaultProtoViewRef>protoViewRef;
-    var view = createRenderView(dpvr.template, dpvr.cmds, inplaceElement, this);
-    var sdRoots = view.nativeShadowRoots;
-    for (var i = 0; i < sdRoots.length; i++) {
-      this._domSharedStylesHost.addHost(sdRoots[i]);
+  setElementClass(renderElement: any, className: string, isAdd: boolean): void {
+    if (isAdd) {
+      DOM.addClass(renderElement, className);
+    } else {
+      DOM.removeClass(renderElement, className);
     }
-    return new RenderViewWithFragments(view, view.fragments);
   }
 
-  destroyView(viewRef: RenderViewRef) {
-    var view = <DefaultRenderView<Node>>viewRef;
-    var sdRoots = view.nativeShadowRoots;
-    for (var i = 0; i < sdRoots.length; i++) {
-      this._domSharedStylesHost.removeHost(sdRoots[i]);
+  setElementStyle(renderElement: any, styleName: string, styleValue: string): void {
+    if (isPresent(styleValue)) {
+      DOM.setStyle(renderElement, styleName, stringify(styleValue));
+    } else {
+      DOM.removeStyle(renderElement, styleName);
     }
   }
 
+  invokeElementMethod(renderElement: any, methodName: string, args: any[]): void {
+    DOM.invoke(renderElement, methodName, args);
+  }
+
+  setText(renderNode: any, text: string): void { DOM.setText(renderNode, text); }
+
+  /**
+   * Performs animations if necessary
+   * @param node
+   */
   animateNodeEnter(node: Node) {
     if (DOM.isElementNode(node) && DOM.hasClass(node, 'ng-animate')) {
       DOM.addClass(node, 'ng-enter');
-      this._animate.css()
+      this._rootRenderer.animate.css()
           .addAnimationClass('ng-enter-active')
           .start(<HTMLElement>node)
           .onComplete(() => { DOM.removeClass(node, 'ng-enter'); });
     }
   }
 
+
+  /**
+   * If animations are necessary, performs animations then removes the element; otherwise, it just
+   * removes the element.
+   * @param node
+   */
   animateNodeLeave(node: Node) {
     if (DOM.isElementNode(node) && DOM.hasClass(node, 'ng-animate')) {
       DOM.addClass(node, 'ng-leave');
-      this._animate.css()
+      this._rootRenderer.animate.css()
           .addAnimationClass('ng-leave-active')
           .start(<HTMLElement>node)
           .onComplete(() => {
@@ -295,73 +257,6 @@ export class DomRenderer_ extends DomRenderer {
       DOM.remove(node);
     }
   }
-
-  /** @internal */
-  _detachFragmentScope = wtfCreateScope('DomRenderer#detachFragment()');
-  detachFragment(fragmentRef: RenderFragmentRef) {
-    var s = this._detachFragmentScope();
-    var fragmentNodes = resolveInternalDomFragment(fragmentRef);
-    for (var i = 0; i < fragmentNodes.length; i++) {
-      this.animateNodeLeave(fragmentNodes[i]);
-    }
-    wtfLeave(s);
-  }
-  createElement(name: string, attrNameAndValues: string[]): Node {
-    var nsAndName = splitNamespace(name);
-    var el = isPresent(nsAndName[0]) ?
-                 DOM.createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :
-                 DOM.createElement(nsAndName[1]);
-    this._setAttributes(el, attrNameAndValues);
-    return el;
-  }
-  mergeElement(existing: Node, attrNameAndValues: string[]) {
-    DOM.clearNodes(existing);
-    this._setAttributes(existing, attrNameAndValues);
-  }
-  private _setAttributes(node: Node, attrNameAndValues: string[]) {
-    for (var attrIdx = 0; attrIdx < attrNameAndValues.length; attrIdx += 2) {
-      var attrNs;
-      var attrName = attrNameAndValues[attrIdx];
-      var nsAndName = splitNamespace(attrName);
-      if (isPresent(nsAndName[0])) {
-        attrName = nsAndName[0] + ':' + nsAndName[1];
-        attrNs = NAMESPACE_URIS[nsAndName[0]];
-      }
-      var attrValue = attrNameAndValues[attrIdx + 1];
-      if (isPresent(attrNs)) {
-        DOM.setAttributeNS(node, attrNs, attrName, attrValue);
-      } else {
-        DOM.setAttribute(node, nsAndName[1], attrValue);
-      }
-    }
-  }
-  createRootContentInsertionPoint(): Node {
-    return DOM.createComment('root-content-insertion-point');
-  }
-  createShadowRoot(host: Node, templateId: string): Node {
-    var sr = DOM.createShadowRoot(host);
-    var tpl = this._componentTpls.get(templateId);
-    for (var i = 0; i < tpl.styles.length; i++) {
-      DOM.appendChild(sr, DOM.createStyleElement(tpl.styles[i]));
-    }
-    return sr;
-  }
-  on(element: Node, eventName: string, callback: Function) {
-    this._eventManager.addEventListener(<HTMLElement>element, eventName,
-                                        decoratePreventDefault(callback));
-  }
-  globalOn(target: string, eventName: string, callback: Function): Function {
-    return this._eventManager.addGlobalEventListener(target, eventName,
-                                                     decoratePreventDefault(callback));
-  }
-}
-
-function resolveInternalDomView(viewRef: RenderViewRef): DefaultRenderView<Node> {
-  return <DefaultRenderView<Node>>viewRef;
-}
-
-function resolveInternalDomFragment(fragmentRef: RenderFragmentRef): Node[] {
-  return (<DefaultRenderFragmentRef<Node>>fragmentRef).nodes;
 }
 
 function moveNodesAfterSibling(sibling, nodes) {
@@ -380,16 +275,48 @@ function moveNodesAfterSibling(sibling, nodes) {
   }
 }
 
+function appendNodes(parent, nodes) {
+  for (var i = 0; i < nodes.length; i++) {
+    DOM.appendChild(parent, nodes[i]);
+  }
+}
+
 function decoratePreventDefault(eventHandler: Function): Function {
   return (event) => {
     var allowDefaultBehavior = eventHandler(event);
-    if (!allowDefaultBehavior) {
+    if (allowDefaultBehavior === false) {
       // TODO(tbosch): move preventDefault into event plugins...
       DOM.preventDefault(event);
     }
   };
 }
 
+var COMPONENT_REGEX = /%COMP%/g;
+export const COMPONENT_VARIABLE = '%COMP%';
+export const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
+export const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
+
+function _shimContentAttribute(componentShortId: string): string {
+  return StringWrapper.replaceAll(CONTENT_ATTR, COMPONENT_REGEX, componentShortId);
+}
+
+function _shimHostAttribute(componentShortId: string): string {
+  return StringWrapper.replaceAll(HOST_ATTR, COMPONENT_REGEX, componentShortId);
+}
+
+function _flattenStyles(compId: string, styles: Array<any | any[]>, target: string[]): string[] {
+  for (var i = 0; i < styles.length; i++) {
+    var style = styles[i];
+    if (isArray(style)) {
+      _flattenStyles(compId, style, target);
+    } else {
+      style = StringWrapper.replaceAll(style, COMPONENT_REGEX, compId);
+      target.push(style);
+    }
+  }
+  return target;
+}
+
 var NS_PREFIX_RE = /^@([^:]+):(.+)/g;
 
 function splitNamespace(name: string): string[] {
@@ -398,4 +325,4 @@ function splitNamespace(name: string): string[] {
   }
   let match = RegExpWrapper.firstMatch(NS_PREFIX_RE, name);
   return [match[1], match[2]];
-}
+}
\ No newline at end of file
diff --git a/modules/angular2/src/platform/worker_app_common.ts b/modules/angular2/src/platform/worker_app_common.ts
index 209b48a..9bcdd28 100644
--- a/modules/angular2/src/platform/worker_app_common.ts
+++ b/modules/angular2/src/platform/worker_app_common.ts
@@ -1,8 +1,8 @@
 import {XHR} from 'angular2/src/compiler/xhr';
 import {WebWorkerXHRImpl} from 'angular2/src/web_workers/worker/xhr_impl';
-import {WebWorkerRenderer} from 'angular2/src/web_workers/worker/renderer';
+import {WebWorkerRootRenderer} from 'angular2/src/web_workers/worker/renderer';
 import {print, Type, CONST_EXPR, isPresent} from 'angular2/src/facade/lang';
-import {Renderer} from 'angular2/src/core/render/api';
+import {RootRenderer} from 'angular2/src/core/render/api';
 import {
   PLATFORM_DIRECTIVES,
   PLATFORM_PIPES,
@@ -23,11 +23,7 @@ import {COMPILER_PROVIDERS} from 'angular2/src/compiler/compiler';
 import {Serializer} from "angular2/src/web_workers/shared/serializer";
 import {ON_WEB_WORKER} from "angular2/src/web_workers/shared/api";
 import {Provider} from 'angular2/src/core/di';
-import {RenderProtoViewRefStore} from 'angular2/src/web_workers/shared/render_proto_view_ref_store';
-import {
-  RenderViewWithFragmentsStore
-} from 'angular2/src/web_workers/shared/render_view_with_fragments_store';
-import {WebWorkerEventDispatcher} from 'angular2/src/web_workers/worker/event_dispatcher';
+import {RenderStore} from 'angular2/src/web_workers/shared/render_store';
 
 class PrintLogger {
   log = print;
@@ -48,15 +44,13 @@ export const WORKER_APP_APPLICATION_COMMON: Array<any /*Type | Provider | any[]*
   new Provider(PLATFORM_DIRECTIVES, {useValue: COMMON_DIRECTIVES, multi: true}),
   new Provider(ClientMessageBrokerFactory, {useClass: ClientMessageBrokerFactory_}),
   new Provider(ServiceMessageBrokerFactory, {useClass: ServiceMessageBrokerFactory_}),
-  WebWorkerRenderer,
-  new Provider(Renderer, {useExisting: WebWorkerRenderer}),
+  WebWorkerRootRenderer,
+  new Provider(RootRenderer, {useExisting: WebWorkerRootRenderer}),
   new Provider(ON_WEB_WORKER, {useValue: true}),
-  RenderViewWithFragmentsStore,
-  RenderProtoViewRefStore,
+  RenderStore,
   new Provider(ExceptionHandler, {useFactory: _exceptionHandler, deps: []}),
   WebWorkerXHRImpl,
-  new Provider(XHR, {useExisting: WebWorkerXHRImpl}),
-  WebWorkerEventDispatcher
+  new Provider(XHR, {useExisting: WebWorkerXHRImpl})
 ]);
 
 function _exceptionHandler(): ExceptionHandler {
diff --git a/modules/angular2/src/platform/worker_render_common.ts b/modules/angular2/src/platform/worker_render_common.ts
index cf5c965..7772148 100644
--- a/modules/angular2/src/platform/worker_render_common.ts
+++ b/modules/angular2/src/platform/worker_render_common.ts
@@ -11,7 +11,7 @@ import {
   reflector,
   APPLICATION_COMMON_PROVIDERS,
   PLATFORM_COMMON_PROVIDERS,
-  Renderer,
+  RootRenderer,
   PLATFORM_INITIALIZER,
   APP_INITIALIZER
 } from 'angular2/core';
@@ -23,7 +23,7 @@ import {DomEventsPlugin} from 'angular2/src/platform/dom/events/dom_events';
 import {KeyEventsPlugin} from 'angular2/src/platform/dom/events/key_events';
 import {HammerGesturesPlugin} from 'angular2/src/platform/dom/events/hammer_gestures';
 import {DOCUMENT} from 'angular2/src/platform/dom/dom_tokens';
-import {DomRenderer, DomRenderer_} from 'angular2/src/platform/dom/dom_renderer';
+import {DomRootRenderer, DomRootRenderer_} from 'angular2/src/platform/dom/dom_renderer';
 import {DomSharedStylesHost} from 'angular2/src/platform/dom/shared_styles_host';
 import {SharedStylesHost} from "angular2/src/platform/dom/shared_styles_host";
 import {BrowserDetails} from 'angular2/src/animate/browser_details';
@@ -46,10 +46,7 @@ import {
 } from 'angular2/src/web_workers/shared/client_message_broker';
 import {Serializer} from 'angular2/src/web_workers/shared/serializer';
 import {ON_WEB_WORKER} from 'angular2/src/web_workers/shared/api';
-import {RenderProtoViewRefStore} from 'angular2/src/web_workers/shared/render_proto_view_ref_store';
-import {
-  RenderViewWithFragmentsStore
-} from 'angular2/src/web_workers/shared/render_view_with_fragments_store';
+import {RenderStore} from 'angular2/src/web_workers/shared/render_store';
 
 export const WORKER_SCRIPT: OpaqueToken = CONST_EXPR(new OpaqueToken("WebWorkerScript"));
 
@@ -72,8 +69,8 @@ export const WORKER_RENDER_APP_COMMON: Array<any /*Type | Provider | any[]*/> =
   new Provider(EVENT_MANAGER_PLUGINS, {useClass: DomEventsPlugin, multi: true}),
   new Provider(EVENT_MANAGER_PLUGINS, {useClass: KeyEventsPlugin, multi: true}),
   new Provider(EVENT_MANAGER_PLUGINS, {useClass: HammerGesturesPlugin, multi: true}),
-  new Provider(DomRenderer, {useClass: DomRenderer_}),
-  new Provider(Renderer, {useExisting: DomRenderer}),
+  new Provider(DomRootRenderer, {useClass: DomRootRenderer_}),
+  new Provider(RootRenderer, {useExisting: DomRootRenderer}),
   new Provider(SharedStylesHost, {useExisting: DomSharedStylesHost}),
   new Provider(XHR, {useClass: XHRImpl}),
   MessageBasedXHRImpl,
@@ -81,8 +78,7 @@ export const WORKER_RENDER_APP_COMMON: Array<any /*Type | Provider | any[]*/> =
   new Provider(ClientMessageBrokerFactory, {useClass: ClientMessageBrokerFactory_}),
   Serializer,
   new Provider(ON_WEB_WORKER, {useValue: false}),
-  RenderViewWithFragmentsStore,
-  RenderProtoViewRefStore,
+  RenderStore,
   DomSharedStylesHost,
   Testability,
   BrowserDetails,
diff --git a/modules/angular2/src/testing/test_component_builder.ts b/modules/angular2/src/testing/test_component_builder.ts
index 3a40e2d..a09645c 100644
--- a/modules/angular2/src/testing/test_component_builder.ts
+++ b/modules/angular2/src/testing/test_component_builder.ts
@@ -6,7 +6,7 @@ import {
   Injector,
   Injectable,
   ViewMetadata,
-  ViewRef,
+  EmbeddedViewRef,
   ViewResolver,
   provide
 } from 'angular2/core';
@@ -15,8 +15,8 @@ import {Type, isPresent, isBlank} from 'angular2/src/facade/lang';
 import {Promise} from 'angular2/src/facade/async';
 import {ListWrapper, MapWrapper} from 'angular2/src/facade/collection';
 
+import {ViewRef_} from 'angular2/src/core/linker/view_ref';
 import {AppView} from 'angular2/src/core/linker/view';
-import {internalView} from 'angular2/src/core/linker/view_ref';
 
 import {el} from './utils';
 
@@ -65,10 +65,10 @@ export class ComponentFixture_ extends ComponentFixture {
 
   constructor(componentRef: ComponentRef) {
     super();
-    this.debugElement = new DebugElement_(internalView(<ViewRef>componentRef.hostView), 0);
+    this._componentParentView = (<ViewRef_>componentRef.hostView).internalView;
+    this.debugElement = new DebugElement_(this._componentParentView.appElements[0]);
     this.componentInstance = this.debugElement.componentInstance;
     this.nativeElement = this.debugElement.nativeElement;
-    this._componentParentView = internalView(<ViewRef>componentRef.hostView);
     this._componentRef = componentRef;
   }
 
diff --git a/modules/angular2/src/testing/test_injector.ts b/modules/angular2/src/testing/test_injector.ts
index 05fddf4..6176cab 100644
--- a/modules/angular2/src/testing/test_injector.ts
+++ b/modules/angular2/src/testing/test_injector.ts
@@ -14,7 +14,7 @@ import {
 import {AnimationBuilder} from 'angular2/src/animate/animation_builder';
 import {MockAnimationBuilder} from 'angular2/src/mock/animation_builder_mock';
 
-import {ProtoViewFactory} from 'angular2/src/core/linker/proto_view_factory';
+import {ResolvedMetadataCache} from 'angular2/src/core/linker/resolved_metadata_cache';
 import {Reflector, reflector} from 'angular2/src/core/reflection/reflection';
 import {
   IterableDiffers,
@@ -46,11 +46,10 @@ import {
 import {ListWrapper} from 'angular2/src/facade/collection';
 import {FunctionWrapper, Type} from 'angular2/src/facade/lang';
 
-import {AppViewPool, APP_VIEW_POOL_CAPACITY} from 'angular2/src/core/linker/view_pool';
-import {AppViewManagerUtils} from 'angular2/src/core/linker/view_manager_utils';
+import {RootRenderer} from 'angular2/src/core/render/api';
 
 import {DOCUMENT} from 'angular2/src/platform/dom/dom_tokens';
-import {DomRenderer} from 'angular2/src/platform/dom/dom_renderer';
+import {DomRootRenderer, DomRootRenderer_} from 'angular2/src/platform/dom/dom_renderer';
 import {DomSharedStylesHost} from 'angular2/src/platform/dom/shared_styles_host';
 import {SharedStylesHost} from 'angular2/src/platform/dom/shared_styles_host';
 import {DomEventsPlugin} from 'angular2/src/platform/dom/events/dom_events';
@@ -58,7 +57,6 @@ import {DomEventsPlugin} from 'angular2/src/platform/dom/events/dom_events';
 import {Serializer} from "angular2/src/web_workers/shared/serializer";
 import {Log} from './utils';
 import {COMPILER_PROVIDERS} from 'angular2/src/compiler/compiler';
-import {DomRenderer_} from "angular2/src/platform/dom/dom_renderer";
 import {DynamicComponentLoader_} from "angular2/src/core/linker/dynamic_component_loader";
 import {AppViewManager_} from "angular2/src/core/linker/view_manager";
 
@@ -92,20 +90,17 @@ function _getAppBindings() {
 
   return [
     APPLICATION_COMMON_PROVIDERS,
-    provide(ChangeDetectorGenConfig, {useValue: new ChangeDetectorGenConfig(true, false, true)}),
+    provide(ChangeDetectorGenConfig, {useValue: new ChangeDetectorGenConfig(true, false, false)}),
     provide(DOCUMENT, {useValue: appDoc}),
-    provide(DomRenderer, {useClass: DomRenderer_}),
-    provide(Renderer, {useExisting: DomRenderer}),
+    provide(DomRootRenderer, {useClass: DomRootRenderer_}),
+    provide(RootRenderer, {useExisting: DomRootRenderer}),
     provide(APP_ID, {useValue: 'a'}),
     DomSharedStylesHost,
     provide(SharedStylesHost, {useExisting: DomSharedStylesHost}),
-    AppViewPool,
     provide(AppViewManager, {useClass: AppViewManager_}),
-    AppViewManagerUtils,
     Serializer,
     ELEMENT_PROBE_PROVIDERS,
-    provide(APP_VIEW_POOL_CAPACITY, {useValue: 500}),
-    ProtoViewFactory,
+    ResolvedMetadataCache,
     provide(DirectiveResolver, {useClass: MockDirectiveResolver}),
     provide(ViewResolver, {useClass: MockViewResolver}),
     provide(IterableDiffers, {useValue: defaultIterableDiffers}),
diff --git a/modules/angular2/src/upgrade/constants.ts b/modules/angular2/src/upgrade/constants.ts
index b3046c3..5934bea 100644
--- a/modules/angular2/src/upgrade/constants.ts
+++ b/modules/angular2/src/upgrade/constants.ts
@@ -1,7 +1,7 @@
 export const NG2_APP_VIEW_MANAGER = 'ng2.AppViewManager';
 export const NG2_COMPILER = 'ng2.Compiler';
 export const NG2_INJECTOR = 'ng2.Injector';
-export const NG2_PROTO_VIEW_REF_MAP = 'ng2.ProtoViewRefMap';
+export const NG2_HOST_VIEW_FACTORY_REF_MAP = 'ng2.HostViewFactoryRefMap';
 export const NG2_ZONE = 'ng2.NgZone';
 
 export const NG1_CONTROLLER = '$controller';
diff --git a/modules/angular2/src/upgrade/downgrade_ng2_adapter.ts b/modules/angular2/src/upgrade/downgrade_ng2_adapter.ts
index b1172a2..a4984c4 100644
--- a/modules/angular2/src/upgrade/downgrade_ng2_adapter.ts
+++ b/modules/angular2/src/upgrade/downgrade_ng2_adapter.ts
@@ -5,7 +5,7 @@ import {
   HostViewRef,
   Injector,
   OnChanges,
-  ProtoViewRef,
+  HostViewFactoryRef,
   SimpleChange
 } from 'angular2/core';
 import {NG1_SCOPE} from './constants';
@@ -25,13 +25,13 @@ export class DowngradeNg2ComponentAdapter {
   changeDetector: ChangeDetectorRef = null;
   componentScope: angular.IScope;
   childNodes: Node[];
-  contentInserctionPoint: Node = null;
+  contentInsertionPoint: Node = null;
 
   constructor(private id: string, private info: ComponentInfo,
               private element: angular.IAugmentedJQuery, private attrs: angular.IAttributes,
               private scope: angular.IScope, private parentInjector: Injector,
               private parse: angular.IParseService, private viewManager: AppViewManager,
-              private protoView: ProtoViewRef) {
+              private hostViewFactory: HostViewFactoryRef) {
     (<any>this.element[0]).id = id;
     this.componentScope = scope.$new();
     this.childNodes = <Node[]><any>element.contents();
@@ -40,13 +40,13 @@ export class DowngradeNg2ComponentAdapter {
   bootstrapNg2() {
     var childInjector = this.parentInjector.resolveAndCreateChild(
         [provide(NG1_SCOPE, {useValue: this.componentScope})]);
-    this.hostViewRef =
-        this.viewManager.createRootHostView(this.protoView, '#' + this.id, childInjector);
-    var renderer: any = (<any>this.hostViewRef).render;
+    this.contentInsertionPoint = document.createComment('ng1 insertion point');
+
+    this.hostViewRef = this.viewManager.createRootHostView(
+        this.hostViewFactory, '#' + this.id, childInjector, [[this.contentInsertionPoint]]);
     var hostElement = this.viewManager.getHostElement(this.hostViewRef);
     this.changeDetector = this.hostViewRef.changeDetectorRef;
     this.component = this.viewManager.getComponent(hostElement);
-    this.contentInserctionPoint = renderer.rootContentInsertionPoints[0];
   }
 
   setupInputs(): void {
@@ -105,10 +105,10 @@ export class DowngradeNg2ComponentAdapter {
 
   projectContent() {
     var childNodes = this.childNodes;
-    if (this.contentInserctionPoint) {
-      var parent = this.contentInserctionPoint.parentNode;
+    var parent = this.contentInsertionPoint.parentNode;
+    if (parent) {
       for (var i = 0, ii = childNodes.length; i < ii; i++) {
-        parent.insertBefore(childNodes[i], this.contentInserctionPoint);
+        parent.insertBefore(childNodes[i], this.contentInsertionPoint);
       }
     }
   }
diff --git a/modules/angular2/src/upgrade/upgrade_adapter.ts b/modules/angular2/src/upgrade/upgrade_adapter.ts
index baccd8d..a282d7a 100644
--- a/modules/angular2/src/upgrade/upgrade_adapter.ts
+++ b/modules/angular2/src/upgrade/upgrade_adapter.ts
@@ -7,7 +7,7 @@ import {
   Injector,
   NgZone,
   PlatformRef,
-  ProtoViewRef,
+  HostViewFactoryRef,
   Provider,
   Type,
   APPLICATION_COMMON_PROVIDERS
@@ -26,7 +26,7 @@ import {
   NG2_APP_VIEW_MANAGER,
   NG2_COMPILER,
   NG2_INJECTOR,
-  NG2_PROTO_VIEW_REF_MAP,
+  NG2_HOST_VIEW_FACTORY_REF_MAP,
   NG2_ZONE,
   REQUIRE_INJECTOR
 } from './constants';
@@ -307,13 +307,13 @@ export class UpgradeAdapter {
     var original$applyFn: Function;
     var rootScopePrototype: any;
     var rootScope: angular.IRootScopeService;
-    var protoViewRefMap: ProtoViewRefMap = {};
+    var hostViewFactoryRefMap: HostViewFactoryRefMap = {};
     var ng1Module = angular.module(this.idPrefix, modules);
     var ng1compilePromise: Promise<any> = null;
     ng1Module.value(NG2_INJECTOR, injector)
         .value(NG2_ZONE, ngZone)
         .value(NG2_COMPILER, compiler)
-        .value(NG2_PROTO_VIEW_REF_MAP, protoViewRefMap)
+        .value(NG2_HOST_VIEW_FACTORY_REF_MAP, hostViewFactoryRefMap)
         .value(NG2_APP_VIEW_MANAGER, injector.get(AppViewManager))
         .config([
           '$provide',
@@ -347,7 +347,7 @@ export class UpgradeAdapter {
 
     angular.element(element).data(controllerKey(NG2_INJECTOR), injector);
     ngZone.run(() => { angular.bootstrap(element, [this.idPrefix], config); });
-    Promise.all([this.compileNg2Components(compiler, protoViewRefMap), ng1compilePromise])
+    Promise.all([this.compileNg2Components(compiler, hostViewFactoryRefMap), ng1compilePromise])
         .then(() => {
           ngZone.run(() => {
             if (rootScopePrototype) {
@@ -470,33 +470,35 @@ export class UpgradeAdapter {
   }
 
   /* @internal */
-  private compileNg2Components(compiler: Compiler,
-                               protoViewRefMap: ProtoViewRefMap): Promise<ProtoViewRefMap> {
-    var promises: Array<Promise<ProtoViewRef>> = [];
+  private compileNg2Components(compiler: Compiler, hostViewFactoryRefMap: HostViewFactoryRefMap):
+      Promise<HostViewFactoryRefMap> {
+    var promises: Array<Promise<HostViewFactoryRef>> = [];
     var types = this.upgradedComponents;
     for (var i = 0; i < types.length; i++) {
       promises.push(compiler.compileInHost(types[i]));
     }
-    return Promise.all(promises).then((protoViews: Array<ProtoViewRef>) => {
+    return Promise.all(promises).then((hostViewFactories: Array<HostViewFactoryRef>) => {
       var types = this.upgradedComponents;
-      for (var i = 0; i < protoViews.length; i++) {
-        protoViewRefMap[getComponentInfo(types[i]).selector] = protoViews[i];
+      for (var i = 0; i < hostViewFactories.length; i++) {
+        hostViewFactoryRefMap[getComponentInfo(types[i]).selector] = hostViewFactories[i];
       }
-      return protoViewRefMap;
+      return hostViewFactoryRefMap;
     }, onError);
   }
 }
 
-interface ProtoViewRefMap {
-  [selector: string]: ProtoViewRef;
+interface HostViewFactoryRefMap {
+  [selector: string]: HostViewFactoryRef;
 }
 
 function ng1ComponentDirective(info: ComponentInfo, idPrefix: string): Function {
-  (<any>directiveFactory).$inject = [NG2_PROTO_VIEW_REF_MAP, NG2_APP_VIEW_MANAGER, NG1_PARSE];
-  function directiveFactory(protoViewRefMap: ProtoViewRefMap, viewManager: AppViewManager,
+  (<any>directiveFactory).$inject =
+      [NG2_HOST_VIEW_FACTORY_REF_MAP, NG2_APP_VIEW_MANAGER, NG1_PARSE];
+  function directiveFactory(hostViewFactoryRefMap: HostViewFactoryRefMap,
+                            viewManager: AppViewManager,
                             parse: angular.IParseService): angular.IDirective {
-    var protoView: ProtoViewRef = protoViewRefMap[info.selector];
-    if (!protoView) throw new Error('Expecting ProtoViewRef for: ' + info.selector);
+    var hostViewFactory: HostViewFactoryRef = hostViewFactoryRefMap[info.selector];
+    if (!hostViewFactory) throw new Error('Expecting HostViewFactoryRef for: ' + info.selector);
     var idCount = 0;
     return {
       restrict: 'E',
@@ -507,7 +509,7 @@ function ng1ComponentDirective(info: ComponentInfo, idPrefix: string): Function
           var domElement = <any>element[0];
           var facade = new DowngradeNg2ComponentAdapter(idPrefix + (idCount++), info, element,
                                                         attrs, scope, <Injector>parentInjector,
-                                                        parse, viewManager, protoView);
+                                                        parse, viewManager, hostViewFactory);
           facade.setupInputs();
           facade.bootstrapNg2();
           facade.projectContent();
diff --git a/modules/angular2/src/web_workers/shared/api.ts b/modules/angular2/src/web_workers/shared/api.ts
index 268668d..34a7574 100644
--- a/modules/angular2/src/web_workers/shared/api.ts
+++ b/modules/angular2/src/web_workers/shared/api.ts
@@ -1,75 +1,4 @@
 import {CONST_EXPR} from "angular2/src/facade/lang";
 import {OpaqueToken} from "angular2/src/core/di";
-import {
-  RenderElementRef,
-  RenderViewRef,
-  RenderTemplateCmd,
-  RenderTextCmd,
-  RenderNgContentCmd,
-  RenderBeginElementCmd,
-  RenderBeginComponentCmd,
-  RenderEmbeddedTemplateCmd,
-  RenderCommandVisitor
-} from "angular2/src/core/render/api";
 
 export const ON_WEB_WORKER = CONST_EXPR(new OpaqueToken('WebWorker.onWebWorker'));
-
-export class WebWorkerElementRef implements RenderElementRef {
-  constructor(public renderView: RenderViewRef, public boundElementIndex: number) {}
-}
-
-export class WebWorkerTemplateCmd implements RenderTemplateCmd {
-  visit(visitor: RenderCommandVisitor, context: any): any { return null; }
-}
-
-export class WebWorkerTextCmd implements RenderTextCmd {
-  constructor(public isBound: boolean, public ngContentIndex: number, public value: string) {}
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitText(this, context);
-  }
-}
-
-export class WebWorkerNgContentCmd implements RenderNgContentCmd {
-  constructor(public index: number, public ngContentIndex: number) {}
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitNgContent(this, context);
-  }
-}
-
-export class WebWorkerBeginElementCmd implements RenderBeginElementCmd {
-  constructor(public isBound: boolean, public ngContentIndex: number, public name: string,
-              public attrNameAndValues: string[], public eventTargetAndNames: string[]) {}
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitBeginElement(this, context);
-  }
-}
-
-export class WebWorkerEndElementCmd implements RenderTemplateCmd {
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitEndElement(context);
-  }
-}
-
-export class WebWorkerBeginComponentCmd implements RenderBeginComponentCmd {
-  constructor(public isBound: boolean, public ngContentIndex: number, public name: string,
-              public attrNameAndValues: string[], public eventTargetAndNames: string[],
-              public templateId: string) {}
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitBeginComponent(this, context);
-  }
-}
-
-export class WebWorkerEndComponentCmd implements RenderTemplateCmd {
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitEndComponent(context);
-  }
-}
-
-export class WebWorkerEmbeddedTemplateCmd implements RenderEmbeddedTemplateCmd {
-  constructor(public isBound: boolean, public ngContentIndex: number, public name: string,
-              public attrNameAndValues: string[], public eventTargetAndNames: string[],
-              public isMerged: boolean, public children: RenderTemplateCmd[]) {}
-  visit(visitor: RenderCommandVisitor, context: any): any {
-    return visitor.visitEmbeddedTemplate(this, context);
-  }
-}
diff --git a/modules/angular2/src/web_workers/shared/render_proto_view_ref_store.ts b/modules/angular2/src/web_workers/shared/render_proto_view_ref_store.ts
deleted file mode 100644
index 5a278e3..0000000
--- a/modules/angular2/src/web_workers/shared/render_proto_view_ref_store.ts
+++ /dev/null
@@ -1,48 +0,0 @@
-import {Injectable, Inject} from "angular2/src/core/di";
-import {RenderProtoViewRef} from "angular2/src/core/render/api";
-import {ON_WEB_WORKER} from "angular2/src/web_workers/shared/api";
-
-@Injectable()
-export class RenderProtoViewRefStore {
-  private _lookupByIndex: Map<number, RenderProtoViewRef> = new Map<number, RenderProtoViewRef>();
-  private _lookupByProtoView: Map<RenderProtoViewRef, number> =
-      new Map<RenderProtoViewRef, number>();
-  private _nextIndex: number = 0;
-  private _onWebworker: boolean;
-
-  constructor(@Inject(ON_WEB_WORKER) onWebworker) { this._onWebworker = onWebworker; }
-
-  allocate(): RenderProtoViewRef {
-    var index = this._nextIndex++;
-    var result = new WebWorkerRenderProtoViewRef(index);
-    this.store(result, index);
-    return result;
-  }
-
-  store(ref: RenderProtoViewRef, index: number): void {
-    this._lookupByProtoView.set(ref, index);
-    this._lookupByIndex.set(index, ref);
-  }
-
-  deserialize(index: number): RenderProtoViewRef {
-    if (index == null) {
-      return null;
-    }
-    return this._lookupByIndex.get(index);
-  }
-
-  serialize(ref: RenderProtoViewRef): number {
-    if (ref == null) {
-      return null;
-    }
-    if (this._onWebworker) {
-      return (<WebWorkerRenderProtoViewRef>ref).refNumber;
-    } else {
-      return this._lookupByProtoView.get(ref);
-    }
-  }
-}
-
-export class WebWorkerRenderProtoViewRef extends RenderProtoViewRef {
-  constructor(public refNumber: number) { super(); }
-}
diff --git a/modules/angular2/src/web_workers/shared/render_store.ts b/modules/angular2/src/web_workers/shared/render_store.ts
new file mode 100644
index 0000000..3b96c2e
--- /dev/null
+++ b/modules/angular2/src/web_workers/shared/render_store.ts
@@ -0,0 +1,45 @@
+import {Injectable} from "angular2/src/core/di";
+
+@Injectable()
+export class RenderStore {
+  private _nextIndex: number = 0;
+  private _lookupById: Map<number, any>;
+  private _lookupByObject: Map<any, number>;
+
+  constructor() {
+    this._lookupById = new Map<number, any>();
+    this._lookupByObject = new Map<any, number>();
+  }
+
+  allocateId(): number { return this._nextIndex++; }
+
+  store(obj: any, id: number): void {
+    this._lookupById.set(id, obj);
+    this._lookupByObject.set(obj, id);
+  }
+
+  remove(obj: any): void {
+    var index = this._lookupByObject.get(obj);
+    this._lookupByObject.delete(obj);
+    this._lookupById.delete(index);
+  }
+
+  deserialize(id: number): any {
+    if (id == null) {
+      return null;
+    }
+
+    if (!this._lookupById.has(id)) {
+      return null;
+    }
+
+    return this._lookupById.get(id);
+  }
+
+  serialize(obj: any): number {
+    if (obj == null) {
+      return null;
+    }
+    return this._lookupByObject.get(obj);
+  }
+}
diff --git a/modules/angular2/src/web_workers/shared/render_view_with_fragments_store.ts b/modules/angular2/src/web_workers/shared/render_view_with_fragments_store.ts
deleted file mode 100644
index 99efb73..0000000
--- a/modules/angular2/src/web_workers/shared/render_view_with_fragments_store.ts
+++ /dev/null
@@ -1,162 +0,0 @@
-import {Injectable, Inject} from "angular2/src/core/di";
-import {
-  RenderViewRef,
-  RenderFragmentRef,
-  RenderViewWithFragments
-} from "angular2/src/core/render/api";
-import {ON_WEB_WORKER} from "angular2/src/web_workers/shared/api";
-import {MapWrapper, ListWrapper} from "angular2/src/facade/collection";
-
-@Injectable()
-export class RenderViewWithFragmentsStore {
-  private _nextIndex: number = 0;
-  private _onWebWorker: boolean;
-  private _lookupByIndex: Map<number, RenderViewRef | RenderFragmentRef>;
-  private _lookupByView: Map<RenderViewRef | RenderFragmentRef, number>;
-  private _viewFragments: Map<RenderViewRef, RenderFragmentRef[]>;
-
-  constructor(@Inject(ON_WEB_WORKER) onWebWorker) {
-    this._onWebWorker = onWebWorker;
-    this._lookupByIndex = new Map<number, RenderViewRef | RenderFragmentRef>();
-    this._lookupByView = new Map<RenderViewRef | RenderFragmentRef, number>();
-    this._viewFragments = new Map<RenderViewRef, RenderFragmentRef[]>();
-  }
-
-  allocate(fragmentCount: number): RenderViewWithFragments {
-    var initialIndex = this._nextIndex;
-
-    var viewRef = new WebWorkerRenderViewRef(this._nextIndex++);
-    var fragmentRefs = ListWrapper.createGrowableSize(fragmentCount);
-
-    for (var i = 0; i < fragmentCount; i++) {
-      fragmentRefs[i] = new WebWorkerRenderFragmentRef(this._nextIndex++);
-    }
-    var renderViewWithFragments = new RenderViewWithFragments(viewRef, fragmentRefs);
-    this.store(renderViewWithFragments, initialIndex);
-    return renderViewWithFragments;
-  }
-
-  store(view: RenderViewWithFragments, startIndex: number): void {
-    this._lookupByIndex.set(startIndex, view.viewRef);
-    this._lookupByView.set(view.viewRef, startIndex);
-    startIndex++;
-
-    view.fragmentRefs.forEach(ref => {
-      this._lookupByIndex.set(startIndex, ref);
-      this._lookupByView.set(ref, startIndex);
-      startIndex++;
-    });
-
-    this._viewFragments.set(view.viewRef, view.fragmentRefs);
-  }
-
-  remove(view: RenderViewRef): void {
-    this._removeRef(view);
-    var fragments = this._viewFragments.get(view);
-    fragments.forEach((fragment) => { this._removeRef(fragment); });
-    this._viewFragments.delete(view);
-  }
-
-  private _removeRef(ref: RenderViewRef | RenderFragmentRef) {
-    var index = this._lookupByView.get(ref);
-    this._lookupByView.delete(ref);
-    this._lookupByIndex.delete(index);
-  }
-
-  serializeRenderViewRef(viewRef: RenderViewRef): number {
-    return this._serializeRenderFragmentOrViewRef(viewRef);
-  }
-
-  serializeRenderFragmentRef(fragmentRef: RenderFragmentRef): number {
-    return this._serializeRenderFragmentOrViewRef(fragmentRef);
-  }
-
-  deserializeRenderViewRef(ref: number): RenderViewRef {
-    if (ref == null) {
-      return null;
-    }
-
-    return this._retrieve(ref);
-  }
-
-  deserializeRenderFragmentRef(ref: number): RenderFragmentRef {
-    if (ref == null) {
-      return null;
-    }
-
-    return this._retrieve(ref);
-  }
-
-  private _retrieve(ref: number): RenderViewRef | RenderFragmentRef {
-    if (ref == null) {
-      return null;
-    }
-
-    if (!this._lookupByIndex.has(ref)) {
-      return null;
-    }
-
-    return this._lookupByIndex.get(ref);
-  }
-
-
-  private _serializeRenderFragmentOrViewRef(ref: RenderViewRef | RenderFragmentRef): number {
-    if (ref == null) {
-      return null;
-    }
-
-    if (this._onWebWorker) {
-      return (<WebWorkerRenderFragmentRef | WebWorkerRenderViewRef>ref).serialize();
-    } else {
-      return this._lookupByView.get(ref);
-    }
-  }
-
-  serializeViewWithFragments(view: RenderViewWithFragments): {[key: string]: any} {
-    if (view == null) {
-      return null;
-    }
-
-    if (this._onWebWorker) {
-      return {
-        'viewRef': (<WebWorkerRenderViewRef>view.viewRef).serialize(),
-        'fragmentRefs': view.fragmentRefs.map(val => (<any>val).serialize())
-      };
-    } else {
-      return {
-        'viewRef': this._lookupByView.get(view.viewRef),
-        'fragmentRefs': view.fragmentRefs.map(val => this._lookupByView.get(val))
-      };
-    }
-  }
-
-  deserializeViewWithFragments(obj: {[key: string]: any}): RenderViewWithFragments {
-    if (obj == null) {
-      return null;
-    }
-
-    var viewRef = this.deserializeRenderViewRef(obj['viewRef']);
-    var fragments = (<any[]>obj['fragmentRefs']).map(val => this.deserializeRenderFragmentRef(val));
-
-    return new RenderViewWithFragments(viewRef, fragments);
-  }
-}
-
-export class WebWorkerRenderViewRef extends RenderViewRef {
-  constructor(public refNumber: number) { super(); }
-  serialize(): number { return this.refNumber; }
-
-  static deserialize(ref: number): WebWorkerRenderViewRef {
-    return new WebWorkerRenderViewRef(ref);
-  }
-}
-
-export class WebWorkerRenderFragmentRef extends RenderFragmentRef {
-  constructor(public refNumber: number) { super(); }
-
-  serialize(): number { return this.refNumber; }
-
-  static deserialize(ref: number): WebWorkerRenderFragmentRef {
-    return new WebWorkerRenderFragmentRef(ref);
-  }
-}
diff --git a/modules/angular2/src/web_workers/shared/serializer.ts b/modules/angular2/src/web_workers/shared/serializer.ts
index 98b6b2a..7de8f39 100644
--- a/modules/angular2/src/web_workers/shared/serializer.ts
+++ b/modules/angular2/src/web_workers/shared/serializer.ts
@@ -2,36 +2,9 @@ import {Type, isArray, isPresent, serializeEnum, deserializeEnum} from "angular2
 import {BaseException, WrappedException} from 'angular2/src/facade/exceptions';
 
 import {Map, StringMapWrapper, MapWrapper} from "angular2/src/facade/collection";
-import {
-  RenderProtoViewRef,
-  RenderViewRef,
-  RenderFragmentRef,
-  RenderElementRef,
-  RenderTemplateCmd,
-  RenderCommandVisitor,
-  RenderTextCmd,
-  RenderNgContentCmd,
-  RenderBeginElementCmd,
-  RenderBeginComponentCmd,
-  RenderEmbeddedTemplateCmd,
-  RenderComponentTemplate
-} from "angular2/src/core/render/api";
-import {
-  WebWorkerElementRef,
-  WebWorkerTemplateCmd,
-  WebWorkerTextCmd,
-  WebWorkerNgContentCmd,
-  WebWorkerBeginElementCmd,
-  WebWorkerEndElementCmd,
-  WebWorkerBeginComponentCmd,
-  WebWorkerEndComponentCmd,
-  WebWorkerEmbeddedTemplateCmd
-} from 'angular2/src/web_workers/shared/api';
+import {RenderComponentType} from "angular2/src/core/render/api";
 import {Injectable} from "angular2/src/core/di";
-import {RenderProtoViewRefStore} from 'angular2/src/web_workers/shared/render_proto_view_ref_store';
-import {
-  RenderViewWithFragmentsStore
-} from 'angular2/src/web_workers/shared/render_view_with_fragments_store';
+import {RenderStore} from 'angular2/src/web_workers/shared/render_store';
 import {ViewEncapsulation, VIEW_ENCAPSULATION_VALUES} from 'angular2/src/core/metadata/view';
 
 // PRIMITIVE is any type that does not need to be serialized (string, number, boolean)
@@ -40,8 +13,7 @@ export const PRIMITIVE: Type = String;
 
 @Injectable()
 export class Serializer {
-  constructor(private _protoViewStore: RenderProtoViewRefStore,
-              private _renderViewStore: RenderViewWithFragmentsStore) {}
+  constructor(private _renderStore: RenderStore) {}
 
   serialize(obj: any, type: any): Object {
     if (!isPresent(obj)) {
@@ -53,18 +25,10 @@ export class Serializer {
     if (type == PRIMITIVE) {
       return obj;
     }
-    if (type == RenderProtoViewRef) {
-      return this._protoViewStore.serialize(obj);
-    } else if (type == RenderViewRef) {
-      return this._renderViewStore.serializeRenderViewRef(obj);
-    } else if (type == RenderFragmentRef) {
-      return this._renderViewStore.serializeRenderFragmentRef(obj);
-    } else if (type == WebWorkerElementRef) {
-      return this._serializeWorkerElementRef(obj);
-    } else if (type == WebWorkerTemplateCmd) {
-      return serializeTemplateCmd(obj);
-    } else if (type === RenderComponentTemplate) {
-      return this._serializeRenderTemplate(obj);
+    if (type == RenderStoreObject) {
+      return this._renderStore.serialize(obj);
+    } else if (type === RenderComponentType) {
+      return this._serializeRenderComponentType(obj);
     } else if (type === ViewEncapsulation) {
       return serializeEnum(obj);
     } else {
@@ -85,18 +49,10 @@ export class Serializer {
       return map;
     }
 
-    if (type == RenderProtoViewRef) {
-      return this._protoViewStore.deserialize(map);
-    } else if (type == RenderViewRef) {
-      return this._renderViewStore.deserializeRenderViewRef(map);
-    } else if (type == RenderFragmentRef) {
-      return this._renderViewStore.deserializeRenderFragmentRef(map);
-    } else if (type == WebWorkerElementRef) {
-      return this._deserializeWorkerElementRef(map);
-    } else if (type == WebWorkerTemplateCmd) {
-      return deserializeTemplateCmd(map);
-    } else if (type === RenderComponentTemplate) {
-      return this._deserializeRenderTemplate(map);
+    if (type == RenderStoreObject) {
+      return this._renderStore.deserialize(map);
+    } else if (type === RenderComponentType) {
+      return this._deserializeRenderComponentType(map);
     } else if (type === ViewEncapsulation) {
       return VIEW_ENCAPSULATION_VALUES[map];
     } else {
@@ -134,114 +90,20 @@ export class Serializer {
     }
   }
 
-  allocateRenderViews(fragmentCount: number) { this._renderViewStore.allocate(fragmentCount); }
-
-  private _serializeWorkerElementRef(elementRef: RenderElementRef): {[key: string]: any} {
-    return {
-      'renderView': this.serialize(elementRef.renderView, RenderViewRef),
-      'boundElementIndex': elementRef.boundElementIndex
-    };
-  }
-
-  private _deserializeWorkerElementRef(map: {[key: string]: any}): RenderElementRef {
-    return new WebWorkerElementRef(this.deserialize(map['renderView'], RenderViewRef),
-                                   map['boundElementIndex']);
-  }
-
-
-  private _serializeRenderTemplate(obj: RenderComponentTemplate): Object {
+  private _serializeRenderComponentType(obj: RenderComponentType): Object {
     return {
       'id': obj.id,
-      'shortId': obj.shortId,
       'encapsulation': this.serialize(obj.encapsulation, ViewEncapsulation),
-      'commands': this.serialize(obj.commands, WebWorkerTemplateCmd),
       'styles': this.serialize(obj.styles, PRIMITIVE)
     };
   }
 
-  private _deserializeRenderTemplate(map: {[key: string]: any}): RenderComponentTemplate {
-    return new RenderComponentTemplate(map['id'], map['shortId'],
-                                       this.deserialize(map['encapsulation'], ViewEncapsulation),
-                                       this.deserialize(map['commands'], WebWorkerTemplateCmd),
-                                       this.deserialize(map['styles'], PRIMITIVE));
-  }
-}
-
-
-function serializeTemplateCmd(cmd: RenderTemplateCmd): Object {
-  return cmd.visit(RENDER_TEMPLATE_CMD_SERIALIZER, null);
-}
-
-function deserializeTemplateCmd(data: {[key: string]: any}): RenderTemplateCmd {
-  return RENDER_TEMPLATE_CMD_DESERIALIZERS[data['deserializerIndex']](data);
-}
-
-class RenderTemplateCmdSerializer implements RenderCommandVisitor {
-  visitText(cmd: RenderTextCmd, context: any): any {
-    return {
-      'deserializerIndex': 0,
-      'isBound': cmd.isBound,
-      'ngContentIndex': cmd.ngContentIndex,
-      'value': cmd.value
-    };
-  }
-  visitNgContent(cmd: RenderNgContentCmd, context: any): any {
-    return {'deserializerIndex': 1, 'index': cmd.index, 'ngContentIndex': cmd.ngContentIndex};
-  }
-  visitBeginElement(cmd: RenderBeginElementCmd, context: any): any {
-    return {
-      'deserializerIndex': 2,
-      'isBound': cmd.isBound,
-      'ngContentIndex': cmd.ngContentIndex,
-      'name': cmd.name,
-      'attrNameAndValues': cmd.attrNameAndValues,
-      'eventTargetAndNames': cmd.eventTargetAndNames
-    };
-  }
-  visitEndElement(context: any): any { return {'deserializerIndex': 3}; }
-  visitBeginComponent(cmd: RenderBeginComponentCmd, context: any): any {
-    return {
-      'deserializerIndex': 4,
-      'isBound': cmd.isBound,
-      'ngContentIndex': cmd.ngContentIndex,
-      'name': cmd.name,
-      'attrNameAndValues': cmd.attrNameAndValues,
-      'eventTargetAndNames': cmd.eventTargetAndNames,
-      'templateId': cmd.templateId
-    };
-  }
-  visitEndComponent(context: any): any { return {'deserializerIndex': 5}; }
-  visitEmbeddedTemplate(cmd: RenderEmbeddedTemplateCmd, context: any): any {
-    var children = cmd.children.map(child => child.visit(this, null));
-    return {
-      'deserializerIndex': 6,
-      'isBound': cmd.isBound,
-      'ngContentIndex': cmd.ngContentIndex,
-      'name': cmd.name,
-      'attrNameAndValues': cmd.attrNameAndValues,
-      'eventTargetAndNames': cmd.eventTargetAndNames,
-      'isMerged': cmd.isMerged,
-      'children': children
-    };
+  private _deserializeRenderComponentType(map: {[key: string]: any}): RenderComponentType {
+    return new RenderComponentType(map['id'],
+                                   this.deserialize(map['encapsulation'], ViewEncapsulation),
+                                   this.deserialize(map['styles'], PRIMITIVE));
   }
 }
 
-var RENDER_TEMPLATE_CMD_SERIALIZER = new RenderTemplateCmdSerializer();
 
-var RENDER_TEMPLATE_CMD_DESERIALIZERS = [
-  (data: {[key: string]: any}) =>
-      new WebWorkerTextCmd(data['isBound'], data['ngContentIndex'], data['value']),
-  (data: {[key: string]: any}) => new WebWorkerNgContentCmd(data['index'], data['ngContentIndex']),
-  (data: {[key: string]: any}) =>
-      new WebWorkerBeginElementCmd(data['isBound'], data['ngContentIndex'], data['name'],
-                                   data['attrNameAndValues'], data['eventTargetAndNames']),
-  (data: {[key: string]: any}) => new WebWorkerEndElementCmd(),
-  (data: {[key: string]: any}) => new WebWorkerBeginComponentCmd(
-      data['isBound'], data['ngContentIndex'], data['name'], data['attrNameAndValues'],
-      data['eventTargetAndNames'], data['templateId']),
-  (data: {[key: string]: any}) => new WebWorkerEndComponentCmd(),
-  (data: {[key: string]: any}) => new WebWorkerEmbeddedTemplateCmd(
-      data['isBound'], data['ngContentIndex'], data['name'], data['attrNameAndValues'],
-      data['eventTargetAndNames'], data['isMerged'],
-      (<any[]>data['children']).map(childData => deserializeTemplateCmd(childData))),
-];
+export class RenderStoreObject {}
\ No newline at end of file
diff --git a/modules/angular2/src/web_workers/ui/event_dispatcher.ts b/modules/angular2/src/web_workers/ui/event_dispatcher.ts
index 66bd879..e316577 100644
--- a/modules/angular2/src/web_workers/ui/event_dispatcher.ts
+++ b/modules/angular2/src/web_workers/ui/event_dispatcher.ts
@@ -1,8 +1,4 @@
-import {
-  RenderViewRef,
-  RenderEventDispatcher,
-} from 'angular2/src/core/render/api';
-import {Serializer} from 'angular2/src/web_workers/shared/serializer';
+import {Serializer, RenderStoreObject} from 'angular2/src/web_workers/shared/serializer';
 import {
   serializeMouseEvent,
   serializeKeyboardEvent,
@@ -13,15 +9,13 @@ import {BaseException, WrappedException} from 'angular2/src/facade/exceptions';
 import {StringMapWrapper} from 'angular2/src/facade/collection';
 import {EventEmitter, ObservableWrapper} from 'angular2/src/facade/async';
 
-export class EventDispatcher implements RenderEventDispatcher {
-  constructor(private _viewRef: RenderViewRef, private _sink: EventEmitter<any>,
-              private _serializer: Serializer) {}
+export class EventDispatcher {
+  constructor(private _sink: EventEmitter<any>, private _serializer: Serializer) {}
 
-  dispatchRenderEvent(elementIndex: number, eventName: string, locals: Map<string, any>): boolean {
-    var e = locals.get('$event');
+  dispatchRenderEvent(element: any, eventTarget: string, eventName: string, event: any): boolean {
     var serializedEvent;
     // TODO (jteplitz602): support custom events #3350
-    switch (e.type) {
+    switch (event.type) {
       case "click":
       case "mouseup":
       case "mousedown":
@@ -33,17 +27,17 @@ export class EventDispatcher implements RenderEventDispatcher {
       case "mouseout":
       case "mouseover":
       case "show":
-        serializedEvent = serializeMouseEvent(e);
+        serializedEvent = serializeMouseEvent(event);
         break;
       case "keydown":
       case "keypress":
       case "keyup":
-        serializedEvent = serializeKeyboardEvent(e);
+        serializedEvent = serializeKeyboardEvent(event);
         break;
       case "input":
       case "change":
       case "blur":
-        serializedEvent = serializeEventWithTarget(e);
+        serializedEvent = serializeEventWithTarget(event);
         break;
       case "abort":
       case "afterprint":
@@ -93,19 +87,16 @@ export class EventDispatcher implements RenderEventDispatcher {
       case "visibilitychange":
       case "volumechange":
       case "waiting":
-        serializedEvent = serializeGenericEvent(e);
+        serializedEvent = serializeGenericEvent(event);
         break;
       default:
         throw new BaseException(eventName + " not supported on WebWorkers");
     }
-    var serializedLocals = StringMapWrapper.create();
-    StringMapWrapper.set(serializedLocals, '$event', serializedEvent);
-
     ObservableWrapper.callEmit(this._sink, {
-      "viewRef": this._serializer.serialize(this._viewRef, RenderViewRef),
-      "elementIndex": elementIndex,
+      "element": this._serializer.serialize(element, RenderStoreObject),
       "eventName": eventName,
-      "locals": serializedLocals
+      "eventTarget": eventTarget,
+      "event": serializedEvent
     });
 
     // TODO(kegluneq): Eventually, we want the user to indicate from the UI side whether the event
diff --git a/modules/angular2/src/web_workers/ui/renderer.ts b/modules/angular2/src/web_workers/ui/renderer.ts
index 9a9a36e..c34bd6d 100644
--- a/modules/angular2/src/web_workers/ui/renderer.ts
+++ b/modules/angular2/src/web_workers/ui/renderer.ts
@@ -1,99 +1,172 @@
 import {Injectable} from 'angular2/src/core/di';
 import {MessageBus} from 'angular2/src/web_workers/shared/message_bus';
-import {Serializer, PRIMITIVE} from 'angular2/src/web_workers/shared/serializer';
-import {
-  RenderViewRef,
-  RenderFragmentRef,
-  RenderProtoViewRef,
-  Renderer,
-  RenderTemplateCmd,
-  RenderComponentTemplate
-} from 'angular2/src/core/render/api';
-import {WebWorkerElementRef, WebWorkerTemplateCmd} from 'angular2/src/web_workers/shared/api';
+import {Serializer, PRIMITIVE, RenderStoreObject} from 'angular2/src/web_workers/shared/serializer';
+import {RootRenderer, Renderer, RenderComponentType} from 'angular2/src/core/render/api';
 import {EVENT_CHANNEL, RENDERER_CHANNEL} from 'angular2/src/web_workers/shared/messaging_api';
 import {Type} from 'angular2/src/facade/lang';
 import {bind} from './bind';
 import {EventDispatcher} from 'angular2/src/web_workers/ui/event_dispatcher';
-import {RenderProtoViewRefStore} from 'angular2/src/web_workers/shared/render_proto_view_ref_store';
-import {
-  RenderViewWithFragmentsStore
-} from 'angular2/src/web_workers/shared/render_view_with_fragments_store';
+import {RenderStore} from 'angular2/src/web_workers/shared/render_store';
 import {ServiceMessageBrokerFactory} from 'angular2/src/web_workers/shared/service_message_broker';
 
 @Injectable()
 export class MessageBasedRenderer {
+  private _eventDispatcher: EventDispatcher;
+
   constructor(private _brokerFactory: ServiceMessageBrokerFactory, private _bus: MessageBus,
-              private _serializer: Serializer,
-              private _renderProtoViewRefStore: RenderProtoViewRefStore,
-              private _renderViewWithFragmentsStore: RenderViewWithFragmentsStore,
-              private _renderer: Renderer) {}
+              private _serializer: Serializer, private _renderStore: RenderStore,
+              private _rootRenderer: RootRenderer) {}
 
   start(): void {
     var broker = this._brokerFactory.createMessageBroker(RENDERER_CHANNEL);
     this._bus.initChannel(EVENT_CHANNEL);
+    this._eventDispatcher = new EventDispatcher(this._bus.to(EVENT_CHANNEL), this._serializer);
+
+    broker.registerMethod("renderComponent", [RenderComponentType, PRIMITIVE],
+                          bind(this._renderComponent, this));
+
+    broker.registerMethod("selectRootElement", [RenderStoreObject, PRIMITIVE, PRIMITIVE],
+                          bind(this._selectRootElement, this));
+    broker.registerMethod("createElement",
+                          [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE],
+                          bind(this._createElement, this));
+    broker.registerMethod("createViewRoot", [RenderStoreObject, RenderStoreObject, PRIMITIVE],
+                          bind(this._createViewRoot, this));
+    broker.registerMethod("createTemplateAnchor", [RenderStoreObject, RenderStoreObject, PRIMITIVE],
+                          bind(this._createTemplateAnchor, this));
+    broker.registerMethod("createText",
+                          [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE],
+                          bind(this._createText, this));
+    broker.registerMethod("projectNodes", [RenderStoreObject, RenderStoreObject, RenderStoreObject],
+                          bind(this._projectNodes, this));
+    broker.registerMethod("attachViewAfter",
+                          [RenderStoreObject, RenderStoreObject, RenderStoreObject],
+                          bind(this._attachViewAfter, this));
+    broker.registerMethod("detachView", [RenderStoreObject, RenderStoreObject],
+                          bind(this._detachView, this));
+    broker.registerMethod("destroyView", [RenderStoreObject, RenderStoreObject, RenderStoreObject],
+                          bind(this._destroyView, this));
+    broker.registerMethod("setElementProperty",
+                          [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE],
+                          bind(this._setElementProperty, this));
+    broker.registerMethod("setElementAttribute",
+                          [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE],
+                          bind(this._setElementAttribute, this));
+    broker.registerMethod("setBindingDebugInfo",
+                          [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE],
+                          bind(this._setBindingDebugInfo, this));
+    broker.registerMethod("setElementClass",
+                          [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE],
+                          bind(this._setElementClass, this));
+    broker.registerMethod("setElementStyle",
+                          [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE],
+                          bind(this._setElementStyle, this));
+    broker.registerMethod("invokeElementMethod",
+                          [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE],
+                          bind(this._invokeElementMethod, this));
+    broker.registerMethod("setText", [RenderStoreObject, RenderStoreObject, PRIMITIVE],
+                          bind(this._setText, this));
+    broker.registerMethod("listen", [RenderStoreObject, RenderStoreObject, PRIMITIVE],
+                          bind(this._listen, this));
+    broker.registerMethod("listenGlobal", [RenderStoreObject, PRIMITIVE, PRIMITIVE, PRIMITIVE],
+                          bind(this._listenGlobal, this));
+    broker.registerMethod("listenGlobalDone", [RenderStoreObject, RenderStoreObject],
+                          bind(this._listenGlobalDone, this));
+  }
+
+  private _renderComponent(renderComponentType: RenderComponentType, rendererId: number) {
+    var renderer = this._rootRenderer.renderComponent(renderComponentType);
+    this._renderStore.store(renderer, rendererId);
+  }
 
-    broker.registerMethod("registerComponentTemplate", [RenderComponentTemplate],
-                          bind(this._renderer.registerComponentTemplate, this._renderer));
-    broker.registerMethod("createProtoView", [PRIMITIVE, WebWorkerTemplateCmd, PRIMITIVE],
-                          bind(this._createProtoView, this));
-    broker.registerMethod("createRootHostView",
-                          [RenderProtoViewRef, PRIMITIVE, PRIMITIVE, PRIMITIVE],
-                          bind(this._createRootHostView, this));
-    broker.registerMethod("createView", [RenderProtoViewRef, PRIMITIVE, PRIMITIVE],
-                          bind(this._createView, this));
-    broker.registerMethod("destroyView", [RenderViewRef], bind(this._destroyView, this));
-    broker.registerMethod("attachFragmentAfterFragment", [RenderFragmentRef, RenderFragmentRef],
-                          bind(this._renderer.attachFragmentAfterFragment, this._renderer));
-    broker.registerMethod("attachFragmentAfterElement", [WebWorkerElementRef, RenderFragmentRef],
-                          bind(this._renderer.attachFragmentAfterElement, this._renderer));
-    broker.registerMethod("detachFragment", [RenderFragmentRef],
-                          bind(this._renderer.detachFragment, this._renderer));
-    broker.registerMethod("hydrateView", [RenderViewRef],
-                          bind(this._renderer.hydrateView, this._renderer));
-    broker.registerMethod("dehydrateView", [RenderViewRef],
-                          bind(this._renderer.dehydrateView, this._renderer));
-    broker.registerMethod("setText", [RenderViewRef, PRIMITIVE, PRIMITIVE],
-                          bind(this._renderer.setText, this._renderer));
-    broker.registerMethod("setElementProperty", [WebWorkerElementRef, PRIMITIVE, PRIMITIVE],
-                          bind(this._renderer.setElementProperty, this._renderer));
-    broker.registerMethod("setElementAttribute", [WebWorkerElementRef, PRIMITIVE, PRIMITIVE],
-                          bind(this._renderer.setElementAttribute, this._renderer));
-    broker.registerMethod("setBindingDebugInfo", [WebWorkerElementRef, PRIMITIVE, PRIMITIVE],
-                          bind(this._renderer.setBindingDebugInfo, this._renderer));
-    broker.registerMethod("setElementClass", [WebWorkerElementRef, PRIMITIVE, PRIMITIVE],
-                          bind(this._renderer.setElementClass, this._renderer));
-    broker.registerMethod("setElementStyle", [WebWorkerElementRef, PRIMITIVE, PRIMITIVE],
-                          bind(this._renderer.setElementStyle, this._renderer));
-    broker.registerMethod("invokeElementMethod", [WebWorkerElementRef, PRIMITIVE, PRIMITIVE],
-                          bind(this._renderer.invokeElementMethod, this._renderer));
-    broker.registerMethod("setEventDispatcher", [RenderViewRef],
-                          bind(this._setEventDispatcher, this));
-  }
-
-  private _destroyView(viewRef: RenderViewRef): void {
-    this._renderer.destroyView(viewRef);
-    this._renderViewWithFragmentsStore.remove(viewRef);
-  }
-
-  private _createProtoView(componentTemplateId: string, cmds: RenderTemplateCmd[],
-                           refIndex: number) {
-    var protoViewRef = this._renderer.createProtoView(componentTemplateId, cmds);
-    this._renderProtoViewRefStore.store(protoViewRef, refIndex);
-  }
-
-  private _createRootHostView(ref: RenderProtoViewRef, fragmentCount: number, selector: string,
-                              startIndex: number) {
-    var renderViewWithFragments = this._renderer.createRootHostView(ref, fragmentCount, selector);
-    this._renderViewWithFragmentsStore.store(renderViewWithFragments, startIndex);
-  }
-
-  private _createView(ref: RenderProtoViewRef, fragmentCount: number, startIndex: number) {
-    var renderViewWithFragments = this._renderer.createView(ref, fragmentCount);
-    this._renderViewWithFragmentsStore.store(renderViewWithFragments, startIndex);
-  }
-
-  private _setEventDispatcher(viewRef: RenderViewRef) {
-    var dispatcher = new EventDispatcher(viewRef, this._bus.to(EVENT_CHANNEL), this._serializer);
-    this._renderer.setEventDispatcher(viewRef, dispatcher);
+  private _selectRootElement(renderer: Renderer, selector: string, elId: number) {
+    this._renderStore.store(renderer.selectRootElement(selector), elId);
   }
+
+  private _createElement(renderer: Renderer, parentElement: any, name: string, elId: number) {
+    this._renderStore.store(renderer.createElement(parentElement, name), elId);
+  }
+
+  private _createViewRoot(renderer: Renderer, hostElement: any, elId: number) {
+    var viewRoot = renderer.createViewRoot(hostElement);
+    if (this._renderStore.serialize(hostElement) !== elId) {
+      this._renderStore.store(viewRoot, elId);
+    }
+  }
+
+  private _createTemplateAnchor(renderer: Renderer, parentElement: any, elId: number) {
+    this._renderStore.store(renderer.createTemplateAnchor(parentElement), elId);
+  }
+
+  private _createText(renderer: Renderer, parentElement: any, value: string, elId: number) {
+    this._renderStore.store(renderer.createText(parentElement, value), elId);
+  }
+
+  private _projectNodes(renderer: Renderer, parentElement: any, nodes: any[]) {
+    renderer.projectNodes(parentElement, nodes);
+  }
+
+  private _attachViewAfter(renderer: Renderer, node: any, viewRootNodes: any[]) {
+    renderer.attachViewAfter(node, viewRootNodes);
+  }
+
+  private _detachView(renderer: Renderer, viewRootNodes: any[]) {
+    renderer.detachView(viewRootNodes);
+  }
+
+  private _destroyView(renderer: Renderer, hostElement: any, viewAllNodes: any[]) {
+    renderer.destroyView(hostElement, viewAllNodes);
+    for (var i = 0; i < viewAllNodes.length; i++) {
+      this._renderStore.remove(viewAllNodes[i]);
+    }
+  }
+
+  private _setElementProperty(renderer: Renderer, renderElement: any, propertyName: string,
+                              propertyValue: any) {
+    renderer.setElementProperty(renderElement, propertyName, propertyValue);
+  }
+
+  private _setElementAttribute(renderer: Renderer, renderElement: any, attributeName: string,
+                               attributeValue: string) {
+    renderer.setElementAttribute(renderElement, attributeName, attributeValue);
+  }
+
+  private _setBindingDebugInfo(renderer: Renderer, renderElement: any, propertyName: string,
+                               propertyValue: string) {
+    renderer.setBindingDebugInfo(renderElement, propertyName, propertyValue);
+  }
+
+  private _setElementClass(renderer: Renderer, renderElement: any, className: string,
+                           isAdd: boolean) {
+    renderer.setElementClass(renderElement, className, isAdd);
+  }
+
+  private _setElementStyle(renderer: Renderer, renderElement: any, styleName: string,
+                           styleValue: string) {
+    renderer.setElementStyle(renderElement, styleName, styleValue);
+  }
+
+  private _invokeElementMethod(renderer: Renderer, renderElement: any, methodName: string,
+                               args: any[]) {
+    renderer.invokeElementMethod(renderElement, methodName, args);
+  }
+
+  private _setText(renderer: Renderer, renderNode: any, text: string) {
+    renderer.setText(renderNode, text);
+  }
+
+  private _listen(renderer: Renderer, renderElement: any, eventName: string) {
+    renderer.listen(renderElement, eventName, (event) => this._eventDispatcher.dispatchRenderEvent(
+                                                  renderElement, null, eventName, event));
+  }
+
+  private _listenGlobal(renderer: Renderer, eventTarget: string, eventName: string,
+                        unlistenId: number) {
+    var unregisterCallback = renderer.listenGlobal(
+        eventTarget, eventName,
+        (event) => this._eventDispatcher.dispatchRenderEvent(null, eventTarget, eventName, event));
+    this._renderStore.store(unregisterCallback, unlistenId);
+  }
+
+  private _listenGlobalDone(renderer: Renderer, unlistenCallback: Function) { unlistenCallback(); }
 }
diff --git a/modules/angular2/src/web_workers/worker/event_dispatcher.ts b/modules/angular2/src/web_workers/worker/event_dispatcher.ts
deleted file mode 100644
index 287995b..0000000
--- a/modules/angular2/src/web_workers/worker/event_dispatcher.ts
+++ /dev/null
@@ -1,47 +0,0 @@
-import {Injectable} from 'angular2/src/core/di';
-import {Map, MapWrapper} from 'angular2/src/facade/collection';
-import {RenderViewRef, RenderEventDispatcher} from 'angular2/src/core/render/api';
-import {Serializer} from 'angular2/src/web_workers/shared/serializer';
-import {EVENT_CHANNEL} from 'angular2/src/web_workers/shared/messaging_api';
-import {MessageBus} from 'angular2/src/web_workers/shared/message_bus';
-import {EventEmitter, ObservableWrapper} from 'angular2/src/facade/async';
-import {deserializeGenericEvent} from './event_deserializer';
-
-@Injectable()
-export class WebWorkerEventDispatcher {
-  private _eventDispatchRegistry: Map<RenderViewRef, RenderEventDispatcher> =
-      new Map<RenderViewRef, RenderEventDispatcher>();
-
-  constructor(bus: MessageBus, private _serializer: Serializer) {
-    bus.initChannel(EVENT_CHANNEL);
-    var source = bus.from(EVENT_CHANNEL);
-    ObservableWrapper.subscribe(
-        source, (message) => this._dispatchEvent(new RenderEventData(message, _serializer)));
-  }
-
-
-  private _dispatchEvent(eventData: RenderEventData): void {
-    var dispatcher = this._eventDispatchRegistry.get(eventData.viewRef);
-    eventData.locals['$event'] = deserializeGenericEvent(eventData.locals['$event']);
-    dispatcher.dispatchRenderEvent(eventData.elementIndex, eventData.eventName, eventData.locals);
-  }
-
-  registerEventDispatcher(viewRef: RenderViewRef, dispatcher: RenderEventDispatcher): void {
-    this._eventDispatchRegistry.set(viewRef, dispatcher);
-  }
-}
-
-
-class RenderEventData {
-  viewRef: RenderViewRef;
-  elementIndex: number;
-  eventName: string;
-  locals: Map<string, any>;
-
-  constructor(message: {[key: string]: any}, serializer: Serializer) {
-    this.viewRef = serializer.deserialize(message['viewRef'], RenderViewRef);
-    this.elementIndex = message['elementIndex'];
-    this.eventName = message['eventName'];
-    this.locals = MapWrapper.createFromStringMap(message['locals']);
-  }
-}
diff --git a/modules/angular2/src/web_workers/worker/renderer.ts b/modules/angular2/src/web_workers/worker/renderer.ts
index 3e3fca3..7d13777 100644
--- a/modules/angular2/src/web_workers/worker/renderer.ts
+++ b/modules/angular2/src/web_workers/worker/renderer.ts
@@ -1,269 +1,270 @@
-import {
-  Renderer,
-  RenderProtoViewRef,
-  RenderViewRef,
-  RenderElementRef,
-  RenderEventDispatcher,
-  RenderViewWithFragments,
-  RenderFragmentRef,
-  RenderTemplateCmd,
-  RenderComponentTemplate
-} from 'angular2/src/core/render/api';
+import {Renderer, RootRenderer, RenderComponentType} from 'angular2/src/core/render/api';
 import {
   ClientMessageBroker,
   ClientMessageBrokerFactory,
   FnArg,
   UiArguments
 } from "angular2/src/web_workers/shared/client_message_broker";
-import {isPresent, print} from "angular2/src/facade/lang";
+import {isPresent, isBlank, print} from "angular2/src/facade/lang";
+import {ListWrapper} from 'angular2/src/facade/collection';
 import {Injectable} from "angular2/src/core/di";
-import {RenderProtoViewRefStore} from 'angular2/src/web_workers/shared/render_proto_view_ref_store';
-import {
-  RenderViewWithFragmentsStore,
-  WebWorkerRenderViewRef
-} from 'angular2/src/web_workers/shared/render_view_with_fragments_store';
-import {WebWorkerElementRef, WebWorkerTemplateCmd} from 'angular2/src/web_workers/shared/api';
+import {RenderStore} from 'angular2/src/web_workers/shared/render_store';
 import {RENDERER_CHANNEL} from 'angular2/src/web_workers/shared/messaging_api';
-import {WebWorkerEventDispatcher} from 'angular2/src/web_workers/worker/event_dispatcher';
+import {Serializer, RenderStoreObject} from 'angular2/src/web_workers/shared/serializer';
+import {EVENT_CHANNEL} from 'angular2/src/web_workers/shared/messaging_api';
+import {MessageBus} from 'angular2/src/web_workers/shared/message_bus';
+import {EventEmitter, ObservableWrapper} from 'angular2/src/facade/async';
+import {ViewEncapsulation} from 'angular2/src/core/metadata/view';
+import {deserializeGenericEvent} from './event_deserializer';
 
 @Injectable()
-export class WebWorkerRenderer implements Renderer {
+export class WebWorkerRootRenderer implements RootRenderer {
   private _messageBroker;
-  constructor(messageBrokerFactory: ClientMessageBrokerFactory,
-              private _renderProtoViewRefStore: RenderProtoViewRefStore,
-              private _renderViewStore: RenderViewWithFragmentsStore,
-              private _eventDispatcher: WebWorkerEventDispatcher) {
+  public globalEvents: NamedEventEmitter = new NamedEventEmitter();
+  private _componentRenderers: Map<string, WebWorkerRenderer> =
+      new Map<string, WebWorkerRenderer>();
+
+  constructor(messageBrokerFactory: ClientMessageBrokerFactory, bus: MessageBus,
+              private _serializer: Serializer, private _renderStore: RenderStore) {
     this._messageBroker = messageBrokerFactory.createMessageBroker(RENDERER_CHANNEL);
+    bus.initChannel(EVENT_CHANNEL);
+    var source = bus.from(EVENT_CHANNEL);
+    ObservableWrapper.subscribe(source, (message) => this._dispatchEvent(message));
   }
 
-  registerComponentTemplate(template: RenderComponentTemplate) {
-    var fnArgs = [new FnArg(template, RenderComponentTemplate)];
-    var args = new UiArguments("registerComponentTemplate", fnArgs);
-    this._messageBroker.runOnService(args, null);
+  private _dispatchEvent(message: {[key: string]: any}): void {
+    var eventName = message['eventName'];
+    var target = message['eventTarget'];
+    var event = deserializeGenericEvent(message['event']);
+    if (isPresent(target)) {
+      this.globalEvents.dispatchEvent(eventNameWithTarget(target, eventName), event);
+    } else {
+      var element =
+          <WebWorkerRenderNode>this._serializer.deserialize(message['element'], RenderStoreObject);
+      element.events.dispatchEvent(eventName, event);
+    }
   }
 
-  createProtoView(componentTemplateId: string, cmds: RenderTemplateCmd[]): RenderProtoViewRef {
-    var renderProtoViewRef = this._renderProtoViewRefStore.allocate();
+  renderComponent(componentType: RenderComponentType): Renderer {
+    var result = this._componentRenderers.get(componentType.id);
+    if (isBlank(result)) {
+      result = new WebWorkerRenderer(this, componentType);
+      this._componentRenderers.set(componentType.id, result);
+      var id = this._renderStore.allocateId();
+      this._renderStore.store(result, id);
+      this.runOnService('renderComponent', [
+        new FnArg(componentType, RenderComponentType),
+        new FnArg(result, RenderStoreObject),
+      ]);
+    }
+    return result;
+  }
 
-    var fnArgs: FnArg[] = [
-      new FnArg(componentTemplateId, null),
-      new FnArg(cmds, WebWorkerTemplateCmd),
-      new FnArg(renderProtoViewRef, RenderProtoViewRef)
-    ];
-    var args: UiArguments = new UiArguments("createProtoView", fnArgs);
+  runOnService(fnName: string, fnArgs: FnArg[]) {
+    var args = new UiArguments(fnName, fnArgs);
     this._messageBroker.runOnService(args, null);
-    return renderProtoViewRef;
   }
 
-  /**
-   * Creates a root host view that includes the given element.
-   * Note that the fragmentCount needs to be passed in so that we can create a result
-   * synchronously even when dealing with webworkers!
-   *
-   * @param {RenderProtoViewRef} hostProtoViewRef a RenderProtoViewRef of type
-   * ProtoViewDto.HOST_VIEW_TYPE
-   * @param {any} hostElementSelector css selector for the host element (will be queried against the
-   * main document)
-   * @return {RenderViewRef} the created view
-   */
-  createRootHostView(hostProtoViewRef: RenderProtoViewRef, fragmentCount: number,
-                     hostElementSelector: string): RenderViewWithFragments {
-    return this._createViewHelper(hostProtoViewRef, fragmentCount, hostElementSelector);
+  allocateNode(): WebWorkerRenderNode {
+    var result = new WebWorkerRenderNode();
+    var id = this._renderStore.allocateId();
+    this._renderStore.store(result, id);
+    return result;
   }
 
-  /**
-   * Creates a regular view out of the given ProtoView
-   * Note that the fragmentCount needs to be passed in so that we can create a result
-   * synchronously even when dealing with webworkers!
-   */
-  createView(protoViewRef: RenderProtoViewRef, fragmentCount: number): RenderViewWithFragments {
-    return this._createViewHelper(protoViewRef, fragmentCount);
-  }
+  allocateId(): number { return this._renderStore.allocateId(); }
 
-  private _createViewHelper(protoViewRef: RenderProtoViewRef, fragmentCount: number,
-                            hostElementSelector?: string): RenderViewWithFragments {
-    var renderViewWithFragments = this._renderViewStore.allocate(fragmentCount);
-
-    var startIndex = (<WebWorkerRenderViewRef>(renderViewWithFragments.viewRef)).refNumber;
-    var fnArgs: FnArg[] = [
-      new FnArg(protoViewRef, RenderProtoViewRef),
-      new FnArg(fragmentCount, null),
-    ];
-    var method = "createView";
-    if (isPresent(hostElementSelector) && hostElementSelector != null) {
-      fnArgs.push(new FnArg(hostElementSelector, null));
-      method = "createRootHostView";
+  destroyNodes(nodes: any[]) {
+    for (var i = 0; i < nodes.length; i++) {
+      this._renderStore.remove(nodes[i]);
     }
-    fnArgs.push(new FnArg(startIndex, null));
+  }
+}
 
-    var args = new UiArguments(method, fnArgs);
-    this._messageBroker.runOnService(args, null);
+export class WebWorkerRenderer implements Renderer, RenderStoreObject {
+  constructor(private _rootRenderer: WebWorkerRootRenderer,
+              private _componentType: RenderComponentType) {}
 
-    return renderViewWithFragments;
+  renderComponent(componentType: RenderComponentType): Renderer {
+    return this._rootRenderer.renderComponent(componentType);
   }
 
-  /**
-   * Destroys the given view after it has been dehydrated and detached
-   */
-  destroyView(viewRef: RenderViewRef) {
-    var fnArgs = [new FnArg(viewRef, RenderViewRef)];
-    var args = new UiArguments("destroyView", fnArgs);
-    this._messageBroker.runOnService(args, null);
-    this._renderViewStore.remove(viewRef);
+  private _runOnService(fnName: string, fnArgs: FnArg[]) {
+    var fnArgsWithRenderer = [new FnArg(this, RenderStoreObject)].concat(fnArgs);
+    this._rootRenderer.runOnService(fnName, fnArgsWithRenderer);
   }
 
-  /**
-   * Attaches a fragment after another fragment.
-   */
-  attachFragmentAfterFragment(previousFragmentRef: RenderFragmentRef,
-                              fragmentRef: RenderFragmentRef) {
-    var fnArgs = [
-      new FnArg(previousFragmentRef, RenderFragmentRef),
-      new FnArg(fragmentRef, RenderFragmentRef)
-    ];
-    var args = new UiArguments("attachFragmentAfterFragment", fnArgs);
-    this._messageBroker.runOnService(args, null);
+  selectRootElement(selector: string): any {
+    var node = this._rootRenderer.allocateNode();
+    this._runOnService('selectRootElement',
+                       [new FnArg(selector, null), new FnArg(node, RenderStoreObject)]);
+    return node;
   }
 
-  /**
-   * Attaches a fragment after an element.
-   */
-  attachFragmentAfterElement(elementRef: RenderElementRef, fragmentRef: RenderFragmentRef) {
-    var fnArgs =
-        [new FnArg(elementRef, WebWorkerElementRef), new FnArg(fragmentRef, RenderFragmentRef)];
-    var args = new UiArguments("attachFragmentAfterElement", fnArgs);
-    this._messageBroker.runOnService(args, null);
+  createElement(parentElement: any, name: string): any {
+    var node = this._rootRenderer.allocateNode();
+    this._runOnService('createElement', [
+      new FnArg(parentElement, RenderStoreObject),
+      new FnArg(name, null),
+      new FnArg(node, RenderStoreObject)
+    ]);
+    return node;
   }
 
-  /**
-   * Detaches a fragment.
-   */
-  detachFragment(fragmentRef: RenderFragmentRef) {
-    var fnArgs = [new FnArg(fragmentRef, RenderFragmentRef)];
-    var args = new UiArguments("detachFragment", fnArgs);
-    this._messageBroker.runOnService(args, null);
+  createViewRoot(hostElement: any): any {
+    var viewRoot = this._componentType.encapsulation === ViewEncapsulation.Native ?
+                       this._rootRenderer.allocateNode() :
+                       hostElement;
+    this._runOnService(
+        'createViewRoot',
+        [new FnArg(hostElement, RenderStoreObject), new FnArg(viewRoot, RenderStoreObject)]);
+    return viewRoot;
   }
 
-  /**
-   * Hydrates a view after it has been attached. Hydration/dehydration is used for reusing views
-   * inside of the view pool.
-   */
-  hydrateView(viewRef: RenderViewRef) {
-    var fnArgs = [new FnArg(viewRef, RenderViewRef)];
-    var args = new UiArguments("hydrateView", fnArgs);
-    this._messageBroker.runOnService(args, null);
+  createTemplateAnchor(parentElement: any): any {
+    var node = this._rootRenderer.allocateNode();
+    this._runOnService(
+        'createTemplateAnchor',
+        [new FnArg(parentElement, RenderStoreObject), new FnArg(node, RenderStoreObject)]);
+    return node;
   }
 
-  /**
-   * Dehydrates a view after it has been attached. Hydration/dehydration is used for reusing views
-   * inside of the view pool.
-   */
-  dehydrateView(viewRef: RenderViewRef) {
-    var fnArgs = [new FnArg(viewRef, RenderViewRef)];
-    var args = new UiArguments("dehydrateView", fnArgs);
-    this._messageBroker.runOnService(args, null);
+  createText(parentElement: any, value: string): any {
+    var node = this._rootRenderer.allocateNode();
+    this._runOnService('createText', [
+      new FnArg(parentElement, RenderStoreObject),
+      new FnArg(value, null),
+      new FnArg(node, RenderStoreObject)
+    ]);
+    return node;
+  }
+
+  projectNodes(parentElement: any, nodes: any[]) {
+    this._runOnService(
+        'projectNodes',
+        [new FnArg(parentElement, RenderStoreObject), new FnArg(nodes, RenderStoreObject)]);
+  }
+
+  attachViewAfter(node: any, viewRootNodes: any[]) {
+    this._runOnService(
+        'attachViewAfter',
+        [new FnArg(node, RenderStoreObject), new FnArg(viewRootNodes, RenderStoreObject)]);
+  }
+
+  detachView(viewRootNodes: any[]) {
+    this._runOnService('detachView', [new FnArg(viewRootNodes, RenderStoreObject)]);
+  }
+
+  destroyView(hostElement: any, viewAllNodes: any[]) {
+    this._runOnService(
+        'destroyView',
+        [new FnArg(hostElement, RenderStoreObject), new FnArg(viewAllNodes, RenderStoreObject)]);
+    this._rootRenderer.destroyNodes(viewAllNodes);
   }
 
-  /**
-   * Returns the native element at the given location.
-   * Attention: In a WebWorker scenario, this should always return null!
-   */
-  getNativeElementSync(location: RenderElementRef): any { return null; }
-
-  /**
-   * Sets a property on an element.
-   */
-  setElementProperty(location: RenderElementRef, propertyName: string, propertyValue: any) {
-    var fnArgs = [
-      new FnArg(location, WebWorkerElementRef),
+  setElementProperty(renderElement: any, propertyName: string, propertyValue: any) {
+    this._runOnService('setElementProperty', [
+      new FnArg(renderElement, RenderStoreObject),
       new FnArg(propertyName, null),
       new FnArg(propertyValue, null)
-    ];
-    var args = new UiArguments("setElementProperty", fnArgs);
-    this._messageBroker.runOnService(args, null);
+    ]);
   }
 
-  /**
-   * Sets an attribute on an element.
-   */
-  setElementAttribute(location: RenderElementRef, attributeName: string, attributeValue: string) {
-    var fnArgs = [
-      new FnArg(location, WebWorkerElementRef),
+  setElementAttribute(renderElement: any, attributeName: string, attributeValue: string) {
+    this._runOnService('setElementAttribute', [
+      new FnArg(renderElement, RenderStoreObject),
       new FnArg(attributeName, null),
       new FnArg(attributeValue, null)
-    ];
-    var args = new UiArguments("setElementAttribute", fnArgs);
-    this._messageBroker.runOnService(args, null);
+    ]);
   }
 
-  setBindingDebugInfo(location: RenderElementRef, propertyName: string,
-                      propertyValue: string): void {
-    var fnArgs = [
-      new FnArg(location, WebWorkerElementRef),
+  setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string) {
+    this._runOnService('setBindingDebugInfo', [
+      new FnArg(renderElement, RenderStoreObject),
       new FnArg(propertyName, null),
       new FnArg(propertyValue, null)
-    ];
-    var args = new UiArguments("setBindingDebugInfo", fnArgs);
-    this._messageBroker.runOnService(args, null);
+    ]);
   }
 
-  /**
-   * Sets a class on an element.
-   */
-  setElementClass(location: RenderElementRef, className: string, isAdd: boolean) {
-    var fnArgs = [
-      new FnArg(location, WebWorkerElementRef),
+  setElementClass(renderElement: any, className: string, isAdd: boolean) {
+    this._runOnService('setElementClass', [
+      new FnArg(renderElement, RenderStoreObject),
       new FnArg(className, null),
       new FnArg(isAdd, null)
-    ];
-    var args = new UiArguments("setElementClass", fnArgs);
-    this._messageBroker.runOnService(args, null);
+    ]);
   }
 
-  /**
-   * Sets a style on an element.
-   */
-  setElementStyle(location: RenderElementRef, styleName: string, styleValue: string) {
-    var fnArgs = [
-      new FnArg(location, WebWorkerElementRef),
+  setElementStyle(renderElement: any, styleName: string, styleValue: string) {
+    this._runOnService('setElementStyle', [
+      new FnArg(renderElement, RenderStoreObject),
       new FnArg(styleName, null),
       new FnArg(styleValue, null)
-    ];
-    var args = new UiArguments("setElementStyle", fnArgs);
-    this._messageBroker.runOnService(args, null);
+    ]);
   }
 
-  /**
-   * Calls a method on an element.
-   * Note: For now we're assuming that everything in the args list are primitive
-   */
-  invokeElementMethod(location: RenderElementRef, methodName: string, args: any[]) {
-    var fnArgs = [
-      new FnArg(location, WebWorkerElementRef),
+  invokeElementMethod(renderElement: any, methodName: string, args: any[]) {
+    this._runOnService('invokeElementMethod', [
+      new FnArg(renderElement, RenderStoreObject),
       new FnArg(methodName, null),
       new FnArg(args, null)
-    ];
-    var uiArgs = new UiArguments("invokeElementMethod", fnArgs);
-    this._messageBroker.runOnService(uiArgs, null);
+    ]);
   }
 
-  /**
-   * Sets the value of a text node.
-   */
-  setText(viewRef: RenderViewRef, textNodeIndex: number, text: string) {
-    var fnArgs =
-        [new FnArg(viewRef, RenderViewRef), new FnArg(textNodeIndex, null), new FnArg(text, null)];
-    var args = new UiArguments("setText", fnArgs);
-    this._messageBroker.runOnService(args, null);
+  setText(renderNode: any, text: string) {
+    this._runOnService('setText',
+                       [new FnArg(renderNode, RenderStoreObject), new FnArg(text, null)]);
   }
 
-  /**
-   * Sets the dispatcher for all events of the given view
-   */
-  setEventDispatcher(viewRef: RenderViewRef, dispatcher: RenderEventDispatcher) {
-    var fnArgs = [new FnArg(viewRef, RenderViewRef)];
-    var args = new UiArguments("setEventDispatcher", fnArgs);
-    this._eventDispatcher.registerEventDispatcher(viewRef, dispatcher);
-    this._messageBroker.runOnService(args, null);
+  listen(renderElement: WebWorkerRenderNode, name: string, callback: Function) {
+    renderElement.events.listen(name, callback);
+    this._runOnService('listen',
+                       [new FnArg(renderElement, RenderStoreObject), new FnArg(name, null)]);
+  }
+
+  listenGlobal(target: string, name: string, callback: Function): Function {
+    this._rootRenderer.globalEvents.listen(eventNameWithTarget(target, name), callback);
+    var unlistenCallbackId = this._rootRenderer.allocateId();
+    this._runOnService(
+        'listenGlobal',
+        [new FnArg(target, null), new FnArg(name, null), new FnArg(unlistenCallbackId, null)]);
+    return () => {
+      this._rootRenderer.globalEvents.unlisten(eventNameWithTarget(target, name), callback);
+      this._runOnService('listenGlobalDone', [new FnArg(unlistenCallbackId, null)]);
+    };
+  }
+}
+
+export class NamedEventEmitter {
+  private _listeners: Map<string, Function[]>;
+
+  private _getListeners(eventName: string): Function[] {
+    if (isBlank(this._listeners)) {
+      this._listeners = new Map<string, Function[]>();
+    }
+    var listeners = this._listeners.get(eventName);
+    if (isBlank(listeners)) {
+      listeners = [];
+      this._listeners.set(eventName, listeners);
+    }
+    return listeners;
+  }
+
+  listen(eventName: string, callback: Function) { this._getListeners(eventName).push(callback); }
+
+  unlisten(eventName: string, callback: Function) {
+    ListWrapper.remove(this._getListeners(eventName), callback);
+  }
+
+  dispatchEvent(eventName: string, event: any) {
+    var listeners = this._getListeners(eventName);
+    for (var i = 0; i < listeners.length; i++) {
+      listeners[i](event);
+    }
   }
 }
+
+function eventNameWithTarget(target: string, eventName: string): string {
+  return `${target}:${eventName}`;
+}
+
+export class WebWorkerRenderNode { events: NamedEventEmitter = new NamedEventEmitter(); }
diff --git a/modules/angular2/test/common/directives/ng_class_spec.ts b/modules/angular2/test/common/directives/ng_class_spec.ts
index b3c7a6c..beff6db 100644
--- a/modules/angular2/test/common/directives/ng_class_spec.ts
+++ b/modules/angular2/test/common/directives/ng_class_spec.ts
@@ -18,7 +18,6 @@ import {ListWrapper, StringMapWrapper, SetWrapper} from 'angular2/src/facade/col
 import {Component, View, provide} from 'angular2/core';
 import {NgFor} from 'angular2/common';
 import {NgClass} from 'angular2/src/common/directives/ng_class';
-import {APP_VIEW_POOL_CAPACITY} from 'angular2/src/core/linker/view_pool';
 
 function detectChangesAndCheck(fixture: ComponentFixture, classes: string, elIndex: number = 0) {
   fixture.detectChanges();
@@ -30,8 +29,6 @@ export function main() {
   describe('binding to CSS class list', () => {
 
     describe('viewpool support', () => {
-      beforeEachProviders(() => { return [provide(APP_VIEW_POOL_CAPACITY, {useValue: 100})]; });
-
       it('should clean up when the directive is destroyed',
          inject([TestComponentBuilder, AsyncTestCompleter], (tcb: TestComponentBuilder, async) => {
            var template = '<div *ngFor="var item of items" [ngClass]="item"></div>';
diff --git a/modules/angular2/test/common/spies.ts b/modules/angular2/test/common/spies.ts
index 65d5a04..28edae5 100644
--- a/modules/angular2/test/common/spies.ts
+++ b/modules/angular2/test/common/spies.ts
@@ -1,8 +1,11 @@
-import {ChangeDetectorRef_} from 'angular2/src/core/change_detection/change_detector_ref';
+import {ChangeDetectorRef} from 'angular2/src/core/change_detection/change_detector_ref';
 import {SpyObject, proxy} from 'angular2/testing_internal';
 
 export class SpyChangeDetectorRef extends SpyObject {
-  constructor() { super(ChangeDetectorRef_); }
+  constructor() {
+    super(ChangeDetectorRef);
+    this.spy('markForCheck');
+  }
 }
 
 export class SpyNgControl extends SpyObject {}
diff --git a/modules/angular2/test/compiler/change_definition_factory_spec.ts b/modules/angular2/test/compiler/change_definition_factory_spec.ts
index e7ba9ea..300b326 100644
--- a/modules/angular2/test/compiler/change_definition_factory_spec.ts
+++ b/modules/angular2/test/compiler/change_definition_factory_spec.ts
@@ -47,7 +47,6 @@ export function main() {
     var directive: TestDirective;
     var locals: Locals;
     var pipes: Pipes;
-    var eventLocals: Locals;
 
     beforeEach(inject([TemplateParser], (_templateParser) => {
       parser = _templateParser;
@@ -55,7 +54,6 @@ export function main() {
       directive = new TestDirective();
       dispatcher = new TestDispatcher([directive], []);
       locals = new Locals(null, MapWrapper.createFromStringMap({'someVar': null}));
-      eventLocals = new Locals(null, MapWrapper.createFromStringMap({'$event': null}));
       pipes = new TestPipes();
     }));
 
@@ -65,9 +63,9 @@ export function main() {
           createChangeDetectorDefinitions(new CompileTypeMetadata({name: 'SomeComp'}),
                                           ChangeDetectionStrategy.Default,
                                           new ChangeDetectorGenConfig(true, false, false),
-                                          parser.parse(template, directives, 'TestComp'))
+                                          parser.parse(template, directives, [], 'TestComp'))
               .map(definition => new DynamicProtoChangeDetector(definition));
-      var changeDetector = protoChangeDetectors[protoViewIndex].instantiate(dispatcher);
+      var changeDetector = protoChangeDetectors[protoViewIndex].instantiate();
       changeDetector.hydrate(context, locals, dispatcher, pipes);
       return changeDetector;
     }
@@ -91,8 +89,7 @@ export function main() {
     it('should handle events on regular elements', () => {
       var changeDetector = createChangeDetector('<div on-click="onEvent($event)">', [], 0);
 
-      eventLocals.set('$event', 'click');
-      changeDetector.handleEvent('click', 0, eventLocals);
+      changeDetector.handleEvent('click', 0, 'click');
       expect(context.eventLog).toEqual(['click']);
     });
 
@@ -105,16 +102,14 @@ export function main() {
       var changeDetector =
           createChangeDetector('<template on-click="onEvent($event)">', [dirMeta], 0);
 
-      eventLocals.set('$event', 'click');
-      changeDetector.handleEvent('click', 0, eventLocals);
+      changeDetector.handleEvent('click', 0, 'click');
       expect(context.eventLog).toEqual(['click']);
     });
 
     it('should handle events with targets', () => {
       var changeDetector = createChangeDetector('<div (window:click)="onEvent($event)">', [], 0);
 
-      eventLocals.set('$event', 'click');
-      changeDetector.handleEvent('window:click', 0, eventLocals);
+      changeDetector.handleEvent('window:click', 0, 'click');
       expect(context.eventLog).toEqual(['click']);
     });
 
@@ -177,8 +172,7 @@ export function main() {
 
       var changeDetector = createChangeDetector('<div>', [dirMeta], 0);
 
-      eventLocals.set('$event', 'click');
-      changeDetector.handleEvent('click', 0, eventLocals);
+      changeDetector.handleEvent('click', 0, 'click');
       expect(directive.eventLog).toEqual(['click']);
     });
 
diff --git a/modules/angular2/test/compiler/change_detector_compiler_spec.ts b/modules/angular2/test/compiler/change_detector_compiler_spec.ts
index ec44ca9..2f76e0e 100644
--- a/modules/angular2/test/compiler/change_detector_compiler_spec.ts
+++ b/modules/angular2/test/compiler/change_detector_compiler_spec.ts
@@ -56,10 +56,18 @@ var THIS_MODULE_REF = moduleRef(THIS_MODULE_URL);
 
 export function main() {
   describe('ChangeDetectorCompiler', () => {
-    beforeEachProviders(() => TEST_PROVIDERS);
+    beforeEachProviders(() => [
+      TEST_PROVIDERS,
+      provide(ChangeDetectorGenConfig,
+              {useValue: new ChangeDetectorGenConfig(true, false, false)})
+    ]);
 
     var parser: TemplateParser;
     var compiler: ChangeDetectionCompiler;
+    beforeEachProviders(() => [
+      provide(ChangeDetectorGenConfig,
+              {useValue: new ChangeDetectorGenConfig(true, false, false)})
+    ]);
 
     beforeEach(inject([TemplateParser, ChangeDetectionCompiler], (_parser, _compiler) => {
       parser = _parser;
@@ -71,35 +79,16 @@ export function main() {
                              directives: CompileDirectiveMetadata[] = CONST_EXPR([])): string[] {
         var type =
             new CompileTypeMetadata({name: stringify(SomeComponent), moduleUrl: THIS_MODULE_URL});
-        var parsedTemplate = parser.parse(template, directives, 'TestComp');
+        var parsedTemplate = parser.parse(template, directives, [], 'TestComp');
         var factories =
             compiler.compileComponentRuntime(type, ChangeDetectionStrategy.Default, parsedTemplate);
         return testChangeDetector(factories[0]);
       }
 
-      describe('no jit', () => {
-        beforeEachProviders(() => [
-          provide(ChangeDetectorGenConfig,
-                  {useValue: new ChangeDetectorGenConfig(true, false, false)})
-        ]);
-        it('should watch element properties', () => {
-          expect(detectChanges(compiler, '<div [elProp]="someProp">'))
-              .toEqual(['elementProperty(elProp)=someValue']);
-        });
+      it('should watch element properties', () => {
+        expect(detectChanges(compiler, '<div [elProp]="someProp">'))
+            .toEqual(['elementProperty(elProp)=someValue']);
       });
-
-      describe('jit', () => {
-        beforeEachProviders(() => [
-          provide(ChangeDetectorGenConfig,
-                  {useValue: new ChangeDetectorGenConfig(true, false, true)})
-        ]);
-        it('should watch element properties', () => {
-          expect(detectChanges(compiler, '<div [elProp]="someProp">'))
-              .toEqual(['elementProperty(elProp)=someValue']);
-        });
-      });
-
-
     });
 
     describe('compileComponentCodeGen', () => {
@@ -108,7 +97,7 @@ export function main() {
           directives: CompileDirectiveMetadata[] = CONST_EXPR([])): Promise<string[]> {
         var type =
             new CompileTypeMetadata({name: stringify(SomeComponent), moduleUrl: THIS_MODULE_URL});
-        var parsedTemplate = parser.parse(template, directives, 'TestComp');
+        var parsedTemplate = parser.parse(template, directives, [], 'TestComp');
         var sourceExpressions =
             compiler.compileComponentCodeGen(type, ChangeDetectionStrategy.Default, parsedTemplate);
         var testableModule = createTestableModule(sourceExpressions, 0).getSourceWithImports();
@@ -140,7 +129,7 @@ function createTestableModule(source: SourceExpressions,
 
 export function testChangeDetector(changeDetectorFactory: Function): string[] {
   var dispatcher = new TestDispatcher([], []);
-  var cd = changeDetectorFactory(dispatcher);
+  var cd = changeDetectorFactory();
   var ctx = new SomeComponent();
   ctx.someProp = 'someValue';
   var locals = new Locals(null, MapWrapper.createFromStringMap({'someVar': null}));
diff --git a/modules/angular2/test/compiler/change_detector_mocks.ts b/modules/angular2/test/compiler/change_detector_mocks.ts
index 97e32c9..ee8ca9b 100644
--- a/modules/angular2/test/compiler/change_detector_mocks.ts
+++ b/modules/angular2/test/compiler/change_detector_mocks.ts
@@ -1,7 +1,8 @@
 import {isBlank} from 'angular2/src/facade/lang';
 import {Pipes} from 'angular2/src/core/change_detection/pipes';
+import {EventEmitter} from 'angular2/src/facade/async';
 import {
-  ProtoChangeDetector,
+  ChangeDetector,
   ChangeDispatcher,
   DirectiveIndex,
   BindingTarget
@@ -10,6 +11,7 @@ import {
 export class TestDirective {
   eventLog: string[] = [];
   dirProp: string;
+  click: EventEmitter<any> = new EventEmitter<any>();
 
   onEvent(value: string) { this.eventLog.push(value); }
 }
@@ -17,7 +19,7 @@ export class TestDirective {
 export class TestDispatcher implements ChangeDispatcher {
   log: string[];
 
-  constructor(public directives: any[], public detectors: ProtoChangeDetector[]) { this.clear(); }
+  constructor(public directives: any[], public detectors: ChangeDetector[]) { this.clear(); }
 
   getDirectiveFor(di: DirectiveIndex) { return this.directives[di.directiveIndex]; }
 
@@ -34,7 +36,9 @@ export class TestDispatcher implements ChangeDispatcher {
   notifyAfterContentChecked() {}
   notifyAfterViewChecked() {}
 
-  getDebugContext(a, b) { return null; }
+  notifyOnDestroy() {}
+
+  getDebugContext(a, b, c) { return null; }
 
   _asString(value) { return (isBlank(value) ? 'null' : value.toString()); }
 }
diff --git a/modules/angular2/test/compiler/command_compiler_spec.ts b/modules/angular2/test/compiler/command_compiler_spec.ts
deleted file mode 100644
index 342f627..0000000
--- a/modules/angular2/test/compiler/command_compiler_spec.ts
+++ /dev/null
@@ -1,597 +0,0 @@
-import {
-  ddescribe,
-  describe,
-  xdescribe,
-  it,
-  iit,
-  xit,
-  expect,
-  beforeEach,
-  afterEach,
-  AsyncTestCompleter,
-  inject,
-  beforeEachProviders
-} from 'angular2/testing_internal';
-
-import {
-  CONST_EXPR,
-  stringify,
-  isType,
-  Type,
-  isBlank,
-  serializeEnum,
-  IS_DART
-} from 'angular2/src/facade/lang';
-import {MapWrapper} from 'angular2/src/facade/collection';
-import {PromiseWrapper, Promise} from 'angular2/src/facade/async';
-import {TemplateParser} from 'angular2/src/compiler/template_parser';
-import {
-  CommandVisitor,
-  TextCmd,
-  NgContentCmd,
-  BeginElementCmd,
-  BeginComponentCmd,
-  EmbeddedTemplateCmd,
-  TemplateCmd,
-  visitAllCommands,
-  CompiledComponentTemplate
-} from 'angular2/src/core/linker/template_commands';
-import {CommandCompiler} from 'angular2/src/compiler/command_compiler';
-import {
-  CompileDirectiveMetadata,
-  CompileTypeMetadata,
-  CompileTemplateMetadata
-} from 'angular2/src/compiler/directive_metadata';
-import {SourceModule, SourceExpression, moduleRef} from 'angular2/src/compiler/source_module';
-import {ViewEncapsulation} from 'angular2/src/core/metadata/view';
-import {evalModule} from './eval_module';
-import {
-  escapeSingleQuoteString,
-  codeGenValueFn,
-  codeGenExportVariable,
-  codeGenConstConstructorCall,
-  MODULE_SUFFIX
-} from 'angular2/src/compiler/util';
-import {TEST_PROVIDERS} from './test_bindings';
-
-const BEGIN_ELEMENT = 'BEGIN_ELEMENT';
-const END_ELEMENT = 'END_ELEMENT';
-const BEGIN_COMPONENT = 'BEGIN_COMPONENT';
-const END_COMPONENT = 'END_COMPONENT';
-const TEXT = 'TEXT';
-const NG_CONTENT = 'NG_CONTENT';
-const EMBEDDED_TEMPLATE = 'EMBEDDED_TEMPLATE';
-
-// Attention: These module names have to correspond to real modules!
-var THIS_MODULE_URL = `package:angular2/test/compiler/command_compiler_spec${MODULE_SUFFIX}`;
-var THIS_MODULE_REF = moduleRef(THIS_MODULE_URL);
-var TEMPLATE_COMMANDS_MODULE_REF =
-    moduleRef(`package:angular2/src/core/linker/template_commands${MODULE_SUFFIX}`);
-
-// Attention: read by eval!
-export class RootComp {}
-export class SomeDir {}
-export class AComp {}
-
-var RootCompTypeMeta =
-    new CompileTypeMetadata({name: 'RootComp', runtime: RootComp, moduleUrl: THIS_MODULE_URL});
-var SomeDirTypeMeta =
-    new CompileTypeMetadata({name: 'SomeDir', runtime: SomeDir, moduleUrl: THIS_MODULE_URL});
-var ACompTypeMeta =
-    new CompileTypeMetadata({name: 'AComp', runtime: AComp, moduleUrl: THIS_MODULE_URL});
-var compTypeTemplateId: Map<CompileTypeMetadata, string> = MapWrapper.createFromPairs(
-    [[RootCompTypeMeta, 'rootCompId'], [SomeDirTypeMeta, 'someDirId'], [ACompTypeMeta, 'aCompId']]);
-
-export function main() {
-  describe('CommandCompiler', () => {
-    beforeEachProviders(() => TEST_PROVIDERS);
-
-    var parser: TemplateParser;
-    var commandCompiler: CommandCompiler;
-    var componentTemplateFactory: Function;
-
-    beforeEach(inject([TemplateParser, CommandCompiler], (_templateParser, _commandCompiler) => {
-      parser = _templateParser;
-      commandCompiler = _commandCompiler;
-    }));
-
-    function createComp({type, selector, template, encapsulation, ngContentSelectors}: {
-      type?: CompileTypeMetadata,
-      selector?: string,
-      template?: string,
-      encapsulation?: ViewEncapsulation,
-      ngContentSelectors?: string[]
-    }): CompileDirectiveMetadata {
-      if (isBlank(encapsulation)) {
-        encapsulation = ViewEncapsulation.None;
-      }
-      if (isBlank(selector)) {
-        selector = 'root';
-      }
-      if (isBlank(ngContentSelectors)) {
-        ngContentSelectors = [];
-      }
-      if (isBlank(template)) {
-        template = '';
-      }
-      return CompileDirectiveMetadata.create({
-        selector: selector,
-        isComponent: true,
-        type: type,
-        template: new CompileTemplateMetadata({
-          template: template,
-          ngContentSelectors: ngContentSelectors,
-          encapsulation: encapsulation
-        })
-      });
-    }
-
-    function createDirective(type: CompileTypeMetadata, selector: string,
-                             exportAs: string = null): CompileDirectiveMetadata {
-      return CompileDirectiveMetadata.create(
-          {selector: selector, exportAs: exportAs, isComponent: false, type: type});
-    }
-
-
-    function createTests(run: Function) {
-      describe('text', () => {
-
-        it('should create unbound text commands', inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({type: RootCompTypeMeta, template: 'a'});
-             run(rootComp, [])
-                 .then((data) => {
-                   expect(data).toEqual([[TEXT, 'a', false, null]]);
-                   async.done();
-                 });
-           }));
-
-        it('should create bound text commands', inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({type: RootCompTypeMeta, template: '{{a}}'});
-             run(rootComp, [])
-                 .then((data) => {
-                   expect(data).toEqual([[TEXT, null, true, null]]);
-                   async.done();
-                 });
-           }));
-
-      });
-
-      describe('elements', () => {
-
-        it('should create unbound element commands', inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({type: RootCompTypeMeta, template: '<div a="b">'});
-             run(rootComp, [])
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [BEGIN_ELEMENT, 'div', ['a', 'b'], [], [], [], false, null],
-                     [END_ELEMENT]
-                   ]);
-                   async.done();
-                 });
-           }));
-
-        it('should create bound element commands', inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({
-               type: RootCompTypeMeta,
-               template: '<div a="b" #someVar (click)="someHandler" (window:scroll)="scrollTo()">'
-             });
-             run(rootComp, [])
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [
-                       BEGIN_ELEMENT,
-                       'div',
-                       ['a', 'b'],
-                       [null, 'click', 'window', 'scroll'],
-                       ['someVar', null],
-                       [],
-                       true,
-                       null
-                     ],
-                     [END_ELEMENT]
-                   ]);
-                   async.done();
-                 });
-           }));
-
-        it('should create element commands with directives',
-           inject([AsyncTestCompleter], (async) => {
-             var rootComp =
-                 createComp({type: RootCompTypeMeta, template: '<div a #someVar="someExport">'});
-             var dir = CompileDirectiveMetadata.create({
-               selector: '[a]',
-               exportAs: 'someExport',
-               isComponent: false,
-               type: SomeDirTypeMeta,
-               host: {'(click)': 'doIt()', '(window:scroll)': 'doIt()', 'role': 'button'}
-             });
-             run(rootComp, [dir])
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [
-                       BEGIN_ELEMENT,
-                       'div',
-                       ['a', '', 'role', 'button'],
-                       [null, 'click', 'window', 'scroll'],
-                       ['someVar', 0],
-                       ['SomeDirType'],
-                       true,
-                       null
-                     ],
-                     [END_ELEMENT]
-                   ]);
-                   async.done();
-                 });
-           }));
-
-        it('should merge element attributes with host attributes',
-           inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({
-               type: RootCompTypeMeta,
-               template: '<div class="origclass" style="color: red;" role="origrole" attr1>'
-             });
-             var dir = CompileDirectiveMetadata.create({
-               selector: 'div',
-               isComponent: false,
-               type: SomeDirTypeMeta,
-               host: {'class': 'newclass', 'style': 'newstyle', 'role': 'newrole', 'attr2': ''}
-             });
-             run(rootComp, [dir])
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [
-                       BEGIN_ELEMENT,
-                       'div',
-                       [
-                         'attr1',
-                         '',
-                         'attr2',
-                         '',
-                         'class',
-                         'origclass newclass',
-                         'role',
-                         'newrole',
-                         'style',
-                         'color: red; newstyle'
-                       ],
-                       [],
-                       [],
-                       ['SomeDirType'],
-                       true,
-                       null
-                     ],
-                     [END_ELEMENT]
-                   ]);
-                   async.done();
-                 });
-           }));
-
-        it('should create nested nodes', inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({type: RootCompTypeMeta, template: '<div>a</div>'});
-             run(rootComp, [])
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [BEGIN_ELEMENT, 'div', [], [], [], [], false, null],
-                     [TEXT, 'a', false, null],
-                     [END_ELEMENT]
-                   ]);
-                   async.done();
-                 });
-           }));
-      });
-
-      describe('components', () => {
-
-        it('should create component commands', inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp(
-                 {type: RootCompTypeMeta, template: '<a a="b" #someVar (click)="someHandler">'});
-             var comp = createComp({type: ACompTypeMeta, selector: 'a'});
-             run(rootComp, [comp])
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [
-                       BEGIN_COMPONENT,
-                       'a',
-                       ['a', 'b'],
-                       [null, 'click'],
-                       ['someVar', 0],
-                       ['ACompType'],
-                       serializeEnum(ViewEncapsulation.None),
-                       null,
-                       'aCompId'
-                     ],
-                     [END_COMPONENT]
-                   ]);
-                   async.done();
-                 });
-           }));
-
-        it('should store viewEncapsulation', inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({type: RootCompTypeMeta, template: '<a></a>'});
-             var comp = createComp(
-                 {type: ACompTypeMeta, selector: 'a', encapsulation: ViewEncapsulation.Native});
-             run(rootComp, [comp])
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [
-                       BEGIN_COMPONENT,
-                       'a',
-                       [],
-                       [],
-                       [],
-                       ['ACompType'],
-                       serializeEnum(ViewEncapsulation.Native),
-                       null,
-                       'aCompId'
-                     ],
-                     [END_COMPONENT]
-                   ]);
-                   async.done();
-                 });
-           }));
-
-        it('should create nested nodes and set ngContentIndex',
-           inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({type: RootCompTypeMeta, template: '<a>t</a>'});
-             var comp = createComp({type: ACompTypeMeta, selector: 'a', ngContentSelectors: ['*']});
-             run(rootComp, [comp])
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [
-                       BEGIN_COMPONENT,
-                       'a',
-                       [],
-                       [],
-                       [],
-                       ['ACompType'],
-                       serializeEnum(ViewEncapsulation.None),
-                       null,
-                       'aCompId'
-                     ],
-                     [TEXT, 't', false, 0],
-                     [END_COMPONENT]
-                   ]);
-                   async.done();
-                 });
-           }));
-      });
-
-      describe('embedded templates', () => {
-        it('should create embedded template commands', inject([AsyncTestCompleter], (async) => {
-             var rootComp =
-                 createComp({type: RootCompTypeMeta, template: '<template a="b"></template>'});
-             var dir = createDirective(SomeDirTypeMeta, '[a]');
-             run(rootComp, [dir], 1)
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [EMBEDDED_TEMPLATE, ['a', 'b'], [], ['SomeDirType'], false, null, 'cd1', []]
-                   ]);
-                   async.done();
-                 });
-           }));
-
-        it('should keep variable name and value for <template> elements',
-           inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({
-               type: RootCompTypeMeta,
-               template: '<template #someVar="someValue" #someEmptyVar></template>'
-             });
-             var dir = createDirective(SomeDirTypeMeta, '[a]');
-             run(rootComp, [dir], 1)
-                 .then((data) => {
-                   expect(data[0][2])
-                       .toEqual(['someVar', 'someValue', 'someEmptyVar', '$implicit']);
-                   async.done();
-                 });
-           }));
-
-        it('should keep variable name and value for template attributes',
-           inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({
-               type: RootCompTypeMeta,
-               template: '<div template="var someVar=someValue; var someEmptyVar"></div>'
-             });
-             var dir = createDirective(SomeDirTypeMeta, '[a]');
-             run(rootComp, [dir], 1)
-                 .then((data) => {
-                   expect(data[0][2])
-                       .toEqual(['someVar', 'someValue', 'someEmptyVar', '$implicit']);
-                   async.done();
-                 });
-           }));
-
-        it('should created nested nodes', inject([AsyncTestCompleter], (async) => {
-             var rootComp =
-                 createComp({type: RootCompTypeMeta, template: '<template>t</template>'});
-             run(rootComp, [], 1)
-                 .then((data) => {
-                   expect(data).toEqual([
-                     [
-                       EMBEDDED_TEMPLATE,
-                       [],
-                       [],
-                       [],
-                       false,
-                       null,
-                       'cd1',
-                       [[TEXT, 't', false, null]]
-                     ]
-                   ]);
-                   async.done();
-                 });
-           }));
-
-        it('should calculate wether the template is merged based on nested ng-content elements',
-           inject([AsyncTestCompleter], (async) => {
-             var rootComp = createComp({
-               type: RootCompTypeMeta,
-               template: '<template><ng-content></ng-content></template>'
-             });
-             run(rootComp, [], 1)
-                 .then((data) => {
-                   expect(data).toEqual(
-                       [[EMBEDDED_TEMPLATE, [], [], [], true, null, 'cd1', [[NG_CONTENT, null]]]]);
-                   async.done();
-                 });
-           }));
-
-      });
-
-      describe('ngContent', () => {
-        it('should create ng-content commands', inject([AsyncTestCompleter], (async) => {
-             var rootComp =
-                 createComp({type: RootCompTypeMeta, template: '<ng-content></ng-content>'});
-             run(rootComp, [])
-                 .then((data) => {
-                   expect(data).toEqual([[NG_CONTENT, null]]);
-                   async.done();
-                 });
-           }));
-      });
-    }
-
-    describe('compileComponentRuntime', () => {
-      beforeEach(() => {
-        componentTemplateFactory = (directive: CompileDirectiveMetadata) => {
-          return () => new CompiledComponentTemplate(compTypeTemplateId.get(directive.type), null,
-                                                     null, null);
-        };
-      });
-
-      function run(component: CompileDirectiveMetadata, directives: CompileDirectiveMetadata[],
-                   embeddedTemplateCount: number = 0): Promise<any[][]> {
-        var changeDetectorFactories = [];
-        for (var i = 0; i < embeddedTemplateCount + 1; i++) {
-          (function(i) { changeDetectorFactories.push((_) => `cd${i}`); })(i);
-        }
-        var parsedTemplate =
-            parser.parse(component.template.template, directives, component.type.name);
-        var commands = commandCompiler.compileComponentRuntime(
-            component, parsedTemplate, changeDetectorFactories, componentTemplateFactory);
-        return PromiseWrapper.resolve(humanize(commands));
-      }
-
-      createTests(run);
-    });
-
-
-    describe('compileComponentCodeGen', () => {
-      beforeEach(() => {
-        componentTemplateFactory = (directive: CompileDirectiveMetadata) => {
-          return `${directive.type.name}TemplateGetter`;
-        };
-      });
-
-      function run(component: CompileDirectiveMetadata, directives: CompileDirectiveMetadata[],
-                   embeddedTemplateCount: number = 0): Promise<any[][]> {
-        var testDeclarations = [];
-        var changeDetectorFactoryExpressions = [];
-        for (var i = 0; i < embeddedTemplateCount + 1; i++) {
-          var fnName = `cd${i}`;
-          testDeclarations.push(`${codeGenValueFn(['_'], ` 'cd${i}' `, fnName)};`);
-          changeDetectorFactoryExpressions.push(fnName);
-        }
-        for (var i = 0; i < directives.length; i++) {
-          var directive = directives[i];
-          if (directive.isComponent) {
-            var nestedTemplate =
-                `${codeGenConstConstructorCall(TEMPLATE_COMMANDS_MODULE_REF+'CompiledComponentTemplate')}('${compTypeTemplateId.get(directive.type)}', null, null, null)`;
-            var getterName = `${directive.type.name}TemplateGetter`;
-            testDeclarations.push(`${codeGenValueFn([], nestedTemplate, getterName)};`)
-          }
-        }
-        var parsedTemplate =
-            parser.parse(component.template.template, directives, component.type.name);
-        var sourceExpression = commandCompiler.compileComponentCodeGen(
-            component, parsedTemplate, changeDetectorFactoryExpressions, componentTemplateFactory);
-        testDeclarations.forEach(decl => sourceExpression.declarations.push(decl));
-        var testableModule = createTestableModule(sourceExpression).getSourceWithImports();
-        return evalModule(testableModule.source, testableModule.imports, null);
-      }
-
-      createTests(run);
-    });
-
-  });
-}
-
-// Attention: read by eval!
-export function humanize(cmds: TemplateCmd[]): any[][] {
-  var visitor = new CommandHumanizer();
-  visitAllCommands(visitor, cmds);
-  return visitor.result;
-}
-
-function checkAndStringifyType(type: Type): string {
-  expect(isType(type)).toBe(true);
-  return `${stringify(type)}Type`;
-}
-
-class CommandHumanizer implements CommandVisitor {
-  result: any[][] = [];
-  visitText(cmd: TextCmd, context: any): any {
-    this.result.push([TEXT, cmd.value, cmd.isBound, cmd.ngContentIndex]);
-    return null;
-  }
-  visitNgContent(cmd: NgContentCmd, context: any): any {
-    this.result.push([NG_CONTENT, cmd.ngContentIndex]);
-    return null;
-  }
-  visitBeginElement(cmd: BeginElementCmd, context: any): any {
-    this.result.push([
-      BEGIN_ELEMENT,
-      cmd.name,
-      cmd.attrNameAndValues,
-      cmd.eventTargetAndNames,
-      cmd.variableNameAndValues,
-      cmd.directives.map(checkAndStringifyType),
-      cmd.isBound,
-      cmd.ngContentIndex
-    ]);
-    return null;
-  }
-  visitEndElement(context: any): any {
-    this.result.push([END_ELEMENT]);
-    return null;
-  }
-  visitBeginComponent(cmd: BeginComponentCmd, context: any): any {
-    this.result.push([
-      BEGIN_COMPONENT,
-      cmd.name,
-      cmd.attrNameAndValues,
-      cmd.eventTargetAndNames,
-      cmd.variableNameAndValues,
-      cmd.directives.map(checkAndStringifyType),
-      serializeEnum(cmd.encapsulation),
-      cmd.ngContentIndex,
-      cmd.templateId
-    ]);
-    return null;
-  }
-  visitEndComponent(context: any): any {
-    this.result.push([END_COMPONENT]);
-    return null;
-  }
-  visitEmbeddedTemplate(cmd: EmbeddedTemplateCmd, context: any): any {
-    this.result.push([
-      EMBEDDED_TEMPLATE,
-      cmd.attrNameAndValues,
-      cmd.variableNameAndValues,
-      cmd.directives.map(checkAndStringifyType),
-      cmd.isMerged,
-      cmd.ngContentIndex,
-      cmd.changeDetectorFactory(null),
-      humanize(cmd.children)
-    ]);
-    return null;
-  }
-}
-
-function createTestableModule(source: SourceExpression): SourceModule {
-  var resultExpression = `${THIS_MODULE_REF}humanize(${source.expression})`;
-  var testableSource = `${source.declarations.join('\n')}
-  ${codeGenValueFn(['_'], resultExpression, '_run')};
-  ${codeGenExportVariable('run')}_run;
-  `;
-  return new SourceModule(null, testableSource);
-}
diff --git a/modules/angular2/test/compiler/runtime_compiler_spec.ts b/modules/angular2/test/compiler/runtime_compiler_spec.ts
index 7300ddb..5d1496c 100644
--- a/modules/angular2/test/compiler/runtime_compiler_spec.ts
+++ b/modules/angular2/test/compiler/runtime_compiler_spec.ts
@@ -15,73 +15,40 @@ import {
 
 import {Component, View, provide} from 'angular2/core';
 import {PromiseWrapper} from 'angular2/src/facade/async';
-import {SpyProtoViewFactory} from '../core/spies';
-import {
-  CompiledHostTemplate,
-  CompiledComponentTemplate,
-  BeginComponentCmd
-} from 'angular2/src/core/linker/template_commands';
-import {RuntimeCompiler} from 'angular2/src/compiler/runtime_compiler';
-import {ProtoViewFactory} from 'angular2/src/core/linker/proto_view_factory';
-import {AppProtoView} from 'angular2/src/core/linker/view';
+import {SpyTemplateCompiler} from './spies';
+import {TemplateCompiler} from 'angular2/src/compiler/compiler';
+import {RuntimeCompiler, RuntimeCompiler_} from 'angular2/src/compiler/runtime_compiler';
+import {HostViewFactory} from 'angular2/src/core/linker/view';
 
 export function main() {
   describe('RuntimeCompiler', () => {
-    var compiler: RuntimeCompiler;
-
-    beforeEach(inject([RuntimeCompiler], (_compiler) => { compiler = _compiler; }));
-
-    describe('compileInHost', () => {
-      var protoViewFactorySpy;
-      var someProtoView;
-
-      beforeEachProviders(() => {
-        protoViewFactorySpy = new SpyProtoViewFactory();
-        someProtoView = new AppProtoView(null, null, null, null, null, null, null);
-        protoViewFactorySpy.spy('createHost').andReturn(someProtoView);
-        return [provide(ProtoViewFactory, {useValue: protoViewFactorySpy})];
-      });
-
-      it('should compile the template via TemplateCompiler',
-         inject([AsyncTestCompleter], (async) => {
-           var cht: CompiledHostTemplate;
-           protoViewFactorySpy.spy('createHost')
-               .andCallFake((_cht) => {
-                 cht = _cht;
-                 return someProtoView;
-               });
-           compiler.compileInHost(SomeComponent)
-               .then((_) => {
-                 var beginComponentCmd = <BeginComponentCmd>cht.template.commands[0];
-                 expect(beginComponentCmd.name).toEqual('some-comp');
-                 async.done();
-               });
-         }));
-
+    var compiler: RuntimeCompiler_;
+    var templateCompilerSpy;
+    var someHostViewFactory;
+
+    beforeEachProviders(() => {
+      templateCompilerSpy = new SpyTemplateCompiler();
+      someHostViewFactory = new HostViewFactory(null, null);
+      templateCompilerSpy.spy('compileHostComponentRuntime')
+          .andReturn(PromiseWrapper.resolve(someHostViewFactory));
+      return [provide(TemplateCompiler, {useValue: templateCompilerSpy})];
     });
 
+    beforeEach(inject([RuntimeCompiler], (_compiler) => { compiler = _compiler; }));
 
-    it('should cache the result', inject([AsyncTestCompleter], (async) => {
-         PromiseWrapper
-             .all([compiler.compileInHost(SomeComponent), compiler.compileInHost(SomeComponent)])
-             .then((protoViewRefs) => {
-               expect(protoViewRefs[0]).toBe(protoViewRefs[1]);
+    it('compileInHost should compile the template via TemplateCompiler',
+       inject([AsyncTestCompleter], (async) => {
+         compiler.compileInHost(SomeComponent)
+             .then((hostViewFactoryRef) => {
+               expect(hostViewFactoryRef.internalHostViewFactory).toBe(someHostViewFactory);
                async.done();
              });
        }));
 
-    it('should clear the cache',
-       inject([AsyncTestCompleter], (async) => {compiler.compileInHost(SomeComponent)
-                                                    .then((protoViewRef1) => {
-                                                      compiler.clearCache();
-                                                      compiler.compileInHost(SomeComponent)
-                                                          .then((protoViewRef2) => {
-                                                            expect(protoViewRef1)
-                                                                .not.toBe(protoViewRef2);
-                                                            async.done();
-                                                          });
-                                                    })}));
-
+    it('should clear the cache', () => {
+      compiler.clearCache();
+      expect(templateCompilerSpy.spy('clearCache')).toHaveBeenCalled();
+    });
   });
 }
 
diff --git a/modules/angular2/test/compiler/runtime_metadata_spec.ts b/modules/angular2/test/compiler/runtime_metadata_spec.ts
index 50ca069..ecba2a4 100644
--- a/modules/angular2/test/compiler/runtime_metadata_spec.ts
+++ b/modules/angular2/test/compiler/runtime_metadata_spec.ts
@@ -46,7 +46,7 @@ export function main() {
     describe('getMetadata', () => {
       it('should read metadata',
          inject([RuntimeMetadataResolver], (resolver: RuntimeMetadataResolver) => {
-           var meta = resolver.getMetadata(ComponentWithEverything);
+           var meta = resolver.getDirectiveMetadata(ComponentWithEverything);
            expect(meta.selector).toEqual('someSelector');
            expect(meta.exportAs).toEqual('someExportAs');
            expect(meta.isComponent).toBe(true);
@@ -70,7 +70,8 @@ export function main() {
 
       it('should use the moduleUrl from the reflector if none is given',
          inject([RuntimeMetadataResolver], (resolver: RuntimeMetadataResolver) => {
-           var value: string = resolver.getMetadata(ComponentWithoutModuleId).type.moduleUrl;
+           var value: string =
+               resolver.getDirectiveMetadata(ComponentWithoutModuleId).type.moduleUrl;
            var expectedEndValue =
                IS_DART ? 'base/dist/dart/angular2/test/compiler/runtime_metadata_spec.dart' : './';
            expect(value.endsWith(expectedEndValue)).toBe(true);
@@ -82,7 +83,7 @@ export function main() {
       it('should return the directive metadatas',
          inject([RuntimeMetadataResolver], (resolver: RuntimeMetadataResolver) => {
            expect(resolver.getViewDirectivesMetadata(ComponentWithEverything))
-               .toEqual([resolver.getMetadata(SomeDirective)]);
+               .toEqual([resolver.getDirectiveMetadata(SomeDirective)]);
          }));
 
       describe("platform directives", () => {
@@ -91,7 +92,10 @@ export function main() {
         it('should include platform directives when available',
            inject([RuntimeMetadataResolver], (resolver: RuntimeMetadataResolver) => {
              expect(resolver.getViewDirectivesMetadata(ComponentWithEverything))
-                 .toEqual([resolver.getMetadata(ADirective), resolver.getMetadata(SomeDirective)]);
+                 .toEqual([
+                   resolver.getDirectiveMetadata(ADirective),
+                   resolver.getDirectiveMetadata(SomeDirective)
+                 ]);
            }));
       });
     });
diff --git a/modules/angular2/test/compiler/spies.dart b/modules/angular2/test/compiler/spies.dart
index b40d185..e651dd8 100644
--- a/modules/angular2/test/compiler/spies.dart
+++ b/modules/angular2/test/compiler/spies.dart
@@ -1,9 +1,15 @@
-library core.spies;
+library compiler.spies;
 
 import 'package:angular2/src/compiler/xhr.dart';
 import 'package:angular2/testing_internal.dart';
+import 'package:angular2/src/compiler/template_compiler.dart';
 
 @proxy
 class SpyXHR extends SpyObject implements XHR {
   noSuchMethod(m) => super.noSuchMethod(m);
+}
+
+@proxy
+class SpyTemplateCompiler extends SpyObject implements TemplateCompiler {
+  noSuchMethod(m) => super.noSuchMethod(m);
 }
\ No newline at end of file
diff --git a/modules/angular2/test/compiler/spies.ts b/modules/angular2/test/compiler/spies.ts
index e58df9f..e1b376c 100644
--- a/modules/angular2/test/compiler/spies.ts
+++ b/modules/angular2/test/compiler/spies.ts
@@ -1,7 +1,12 @@
 import {XHR} from 'angular2/src/compiler/xhr';
+import {TemplateCompiler} from 'angular2/src/compiler/template_compiler';
 
 import {SpyObject, proxy} from 'angular2/testing_internal';
 
 export class SpyXHR extends SpyObject {
   constructor() { super(XHR); }
+}
+
+export class SpyTemplateCompiler extends SpyObject {
+  constructor() { super(TemplateCompiler); }
 }
\ No newline at end of file
diff --git a/modules/angular2/test/compiler/template_compiler_spec.ts b/modules/angular2/test/compiler/template_compiler_spec.ts
index cb5c023..aac4fdf 100644
--- a/modules/angular2/test/compiler/template_compiler_spec.ts
+++ b/modules/angular2/test/compiler/template_compiler_spec.ts
@@ -15,7 +15,12 @@ import {
 
 import {Promise, PromiseWrapper} from 'angular2/src/facade/async';
 import {Type, isPresent, isBlank, stringify, isString} from 'angular2/src/facade/lang';
-import {MapWrapper, SetWrapper, ListWrapper} from 'angular2/src/facade/collection';
+import {
+  MapWrapper,
+  SetWrapper,
+  ListWrapper,
+  StringMapWrapper
+} from 'angular2/src/facade/collection';
 import {RuntimeMetadataResolver} from 'angular2/src/compiler/runtime_metadata';
 import {
   TemplateCompiler,
@@ -26,31 +31,31 @@ import {evalModule} from './eval_module';
 import {SourceModule, moduleRef} from 'angular2/src/compiler/source_module';
 import {XHR} from 'angular2/src/compiler/xhr';
 import {MockXHR} from 'angular2/src/compiler/xhr_mock';
+import {SpyRootRenderer, SpyRenderer, SpyAppViewManager} from '../core/spies';
 import {ViewEncapsulation} from 'angular2/src/core/metadata/view';
+import {AppView, AppProtoView} from 'angular2/src/core/linker/view';
+import {AppElement} from 'angular2/src/core/linker/element';
+import {Locals, ChangeDetectorGenConfig} from 'angular2/src/core/change_detection/change_detection';
 
-import {Locals} from 'angular2/src/core/change_detection/change_detection';
+import {Component, View, Directive, provide, RenderComponentType} from 'angular2/core';
 
+import {TEST_PROVIDERS} from './test_bindings';
 import {
-  CommandVisitor,
-  TextCmd,
-  NgContentCmd,
-  BeginElementCmd,
-  BeginComponentCmd,
-  EmbeddedTemplateCmd,
-  TemplateCmd,
-  visitAllCommands,
-  CompiledComponentTemplate
-} from 'angular2/src/core/linker/template_commands';
-
-import {Component, View, Directive, provide} from 'angular2/core';
+  codeGenValueFn,
+  codeGenFnHeader,
+  codeGenExportVariable,
+  MODULE_SUFFIX
+} from 'angular2/src/compiler/util';
+import {PipeTransform, WrappedValue, Injectable, Pipe} from 'angular2/core';
 
-import {TEST_PROVIDERS} from './test_bindings';
-import {TestDispatcher, TestPipes} from './change_detector_mocks';
-import {codeGenValueFn, codeGenExportVariable, MODULE_SUFFIX} from 'angular2/src/compiler/util';
 
 // Attention: This path has to point to this test file!
 const THIS_MODULE_ID = 'angular2/test/compiler/template_compiler_spec';
 var THIS_MODULE_REF = moduleRef(`package:${THIS_MODULE_ID}${MODULE_SUFFIX}`);
+var REFLECTOR_MODULE_REF =
+    moduleRef(`package:angular2/src/core/reflection/reflection${MODULE_SUFFIX}`);
+var REFLECTION_CAPS_MODULE_REF =
+    moduleRef(`package:angular2/src/core/reflection/reflection_capabilities${MODULE_SUFFIX}`);
 
 export function main() {
   describe('TemplateCompiler', () => {
@@ -77,23 +82,24 @@ export function main() {
            }));
 
         it('should compile host components', inject([AsyncTestCompleter], (async) => {
-             compile([CompWithBindingsAndStyles])
-                 .then((humanizedTemplate) => {
-                   expect(humanizedTemplate['styles']).toEqual([]);
-                   expect(humanizedTemplate['commands'][0]).toEqual('<comp-a>');
-                   expect(humanizedTemplate['cd']).toEqual(['elementProperty(title)=someDirValue']);
-
+             compile([CompWithBindingsAndStylesAndPipes])
+                 .then((humanizedView) => {
+                   expect(humanizedView['styles']).toEqual([]);
+                   expect(humanizedView['elements']).toEqual(['<comp-a>']);
+                   expect(humanizedView['pipes']).toEqual({});
+                   expect(humanizedView['cd']).toEqual(['prop(title)=someHostValue']);
                    async.done();
                  });
            }));
 
         it('should compile nested components', inject([AsyncTestCompleter], (async) => {
-             compile([CompWithBindingsAndStyles])
-                 .then((humanizedTemplate) => {
-                   var nestedTemplate = humanizedTemplate['commands'][1];
-                   expect(nestedTemplate['styles']).toEqual(['div {color: red}']);
-                   expect(nestedTemplate['commands'][0]).toEqual('<a>');
-                   expect(nestedTemplate['cd']).toEqual(['elementProperty(href)=someCtxValue']);
+             compile([CompWithBindingsAndStylesAndPipes])
+                 .then((humanizedView) => {
+                   var componentView = humanizedView['componentViews'][0];
+                   expect(componentView['styles']).toEqual(['div {color: red}']);
+                   expect(componentView['elements']).toEqual(['<a>']);
+                   expect(componentView['pipes']).toEqual({'uppercase': stringify(UpperCasePipe)});
+                   expect(componentView['cd']).toEqual(['prop(href)=SOMECTXVALUE']);
 
                    async.done();
                  });
@@ -101,23 +107,24 @@ export function main() {
 
         it('should compile recursive components', inject([AsyncTestCompleter], (async) => {
              compile([TreeComp])
-                 .then((humanizedTemplate) => {
-                   expect(humanizedTemplate['commands'][0]).toEqual('<tree>');
-                   expect(humanizedTemplate['commands'][1]['commands'][0]).toEqual('<tree>');
-                   expect(humanizedTemplate['commands'][1]['commands'][1]['commands'][0])
-                       .toEqual('<tree>');
+                 .then((humanizedView) => {
+                   expect(humanizedView['elements']).toEqual(['<tree>']);
+                   expect(humanizedView['componentViews'][0]['embeddedViews'][0]['elements'])
+                       .toEqual(['<tree>']);
+                   expect(humanizedView['componentViews'][0]['embeddedViews'][0]['componentViews']
+                                       [0]['embeddedViews'][0]['elements'])
+                       .toEqual(['<tree>']);
 
                    async.done();
                  });
            }));
 
-        it('should pass the right change detector to embedded templates',
-           inject([AsyncTestCompleter], (async) => {
+        it('should compile embedded templates', inject([AsyncTestCompleter], (async) => {
              compile([CompWithEmbeddedTemplate])
-                 .then((humanizedTemplate) => {
-                   expect(humanizedTemplate['commands'][1]['commands'][0]).toEqual('<template>');
-                   expect(humanizedTemplate['commands'][1]['commands'][1]['cd'])
-                       .toEqual(['elementProperty(href)=someCtxValue']);
+                 .then((humanizedView) => {
+                   var embeddedView = humanizedView['componentViews'][0]['embeddedViews'][0];
+                   expect(embeddedView['elements']).toEqual(['<a>']);
+                   expect(embeddedView['cd']).toEqual(['prop(href)=someEmbeddedValue']);
 
                    async.done();
                  });
@@ -125,8 +132,8 @@ export function main() {
 
         it('should dedup directives', inject([AsyncTestCompleter], (async) => {
              compile([CompWithDupDirectives, TreeComp])
-                 .then((humanizedTemplate) => {
-                   expect(humanizedTemplate['commands'][1]['commands'][0]).toEqual("<tree>");
+                 .then((humanizedView) => {
+                   expect(humanizedView['componentViews'][0]['componentViews'].length).toBe(1);
                    async.done();
 
                  });
@@ -136,18 +143,34 @@ export function main() {
       describe('compileHostComponentRuntime', () => {
         function compile(components: Type[]): Promise<any[]> {
           return compiler.compileHostComponentRuntime(components[0])
-              .then((compiledHostTemplate) => humanizeTemplate(compiledHostTemplate.template));
+              .then((compiledHostTemplate) =>
+                        humanizeViewFactory(compiledHostTemplate.viewFactory));
         }
 
-        runTests(compile);
+        describe('no jit', () => {
+          beforeEachProviders(() => [
+            provide(ChangeDetectorGenConfig,
+                    {useValue: new ChangeDetectorGenConfig(true, false, false)})
+          ]);
+          runTests(compile);
+        });
+
+        describe('jit', () => {
+          beforeEachProviders(() => [
+            provide(ChangeDetectorGenConfig,
+                    {useValue: new ChangeDetectorGenConfig(true, false, true)})
+          ]);
+          runTests(compile);
+        });
 
         it('should cache components for parallel requests',
            inject([AsyncTestCompleter, XHR], (async, xhr: MockXHR) => {
-             xhr.expect('package:angular2/test/compiler/compUrl.html', 'a');
+             // Expecting only one xhr...
+             xhr.expect('package:angular2/test/compiler/compUrl.html', '<a></a>');
              PromiseWrapper.all([compile([CompWithTemplateUrl]), compile([CompWithTemplateUrl])])
-                 .then((humanizedTemplates) => {
-                   expect(humanizedTemplates[0]['commands'][1]['commands']).toEqual(['#text(a)']);
-                   expect(humanizedTemplates[1]['commands'][1]['commands']).toEqual(['#text(a)']);
+                 .then((humanizedViews) => {
+                   expect(humanizedViews[0]['componentViews'][0]['elements']).toEqual(['<a>']);
+                   expect(humanizedViews[1]['componentViews'][0]['elements']).toEqual(['<a>']);
 
                    async.done();
                  });
@@ -156,15 +179,14 @@ export function main() {
 
         it('should cache components for sequential requests',
            inject([AsyncTestCompleter, XHR], (async, xhr: MockXHR) => {
-             xhr.expect('package:angular2/test/compiler/compUrl.html', 'a');
+             // Expecting only one xhr...
+             xhr.expect('package:angular2/test/compiler/compUrl.html', '<a>');
              compile([CompWithTemplateUrl])
-                 .then((humanizedTemplate0) => {
+                 .then((humanizedView0) => {
                    return compile([CompWithTemplateUrl])
-                       .then((humanizedTemplate1) => {
-                         expect(humanizedTemplate0['commands'][1]['commands'])
-                             .toEqual(['#text(a)']);
-                         expect(humanizedTemplate1['commands'][1]['commands'])
-                             .toEqual(['#text(a)']);
+                       .then((humanizedView1) => {
+                         expect(humanizedView0['componentViews'][0]['elements']).toEqual(['<a>']);
+                         expect(humanizedView1['componentViews'][0]['elements']).toEqual(['<a>']);
                          async.done();
                        });
                  });
@@ -173,17 +195,17 @@ export function main() {
 
         it('should allow to clear the cache',
            inject([AsyncTestCompleter, XHR], (async, xhr: MockXHR) => {
-             xhr.expect('package:angular2/test/compiler/compUrl.html', 'a');
+             xhr.expect('package:angular2/test/compiler/compUrl.html', '<a>');
              compile([CompWithTemplateUrl])
-                 .then((humanizedTemplate) => {
+                 .then((humanizedView) => {
                    compiler.clearCache();
-                   xhr.expect('package:angular2/test/compiler/compUrl.html', 'b');
+                   xhr.expect('package:angular2/test/compiler/compUrl.html', '<b>');
                    var result = compile([CompWithTemplateUrl]);
                    xhr.flush();
                    return result;
                  })
-                 .then((humanizedTemplate) => {
-                   expect(humanizedTemplate['commands'][1]['commands']).toEqual(['#text(b)']);
+                 .then((humanizedView) => {
+                   expect(humanizedView['componentViews'][0]['elements']).toEqual(['<b>']);
                    async.done();
                  });
              xhr.flush();
@@ -193,14 +215,17 @@ export function main() {
       describe('compileTemplatesCodeGen', () => {
         function normalizeComponent(
             component: Type): Promise<NormalizedComponentWithViewDirectives> {
-          var compAndViewDirMetas = [runtimeMetadataResolver.getMetadata(component)].concat(
-              runtimeMetadataResolver.getViewDirectivesMetadata(component));
+          var compAndViewDirMetas =
+              [runtimeMetadataResolver.getDirectiveMetadata(component)].concat(
+                  runtimeMetadataResolver.getViewDirectivesMetadata(component));
+          var upperCasePipeMeta = runtimeMetadataResolver.getPipeMetadata(UpperCasePipe);
+          upperCasePipeMeta.type.moduleUrl = `package:${THIS_MODULE_ID}${MODULE_SUFFIX}`;
           return PromiseWrapper.all(compAndViewDirMetas.map(
                                         meta => compiler.normalizeDirectiveMetadata(meta)))
               .then((normalizedCompAndViewDirMetas: CompileDirectiveMetadata[]) =>
                         new NormalizedComponentWithViewDirectives(
                             normalizedCompAndViewDirMetas[0],
-                            normalizedCompAndViewDirMetas.slice(1)));
+                            normalizedCompAndViewDirMetas.slice(1), [upperCasePipeMeta]));
         }
 
         function compile(components: Type[]): Promise<any[]> {
@@ -223,7 +248,7 @@ export function main() {
     describe('normalizeDirectiveMetadata', () => {
       it('should return the given DirectiveMetadata for non components',
          inject([AsyncTestCompleter], (async) => {
-           var meta = runtimeMetadataResolver.getMetadata(NonComponent);
+           var meta = runtimeMetadataResolver.getDirectiveMetadata(NonComponent);
            compiler.normalizeDirectiveMetadata(meta).then(normMeta => {
              expect(normMeta).toBe(meta);
              async.done();
@@ -234,7 +259,7 @@ export function main() {
          inject([AsyncTestCompleter, XHR], (async, xhr: MockXHR) => {
            xhr.expect('package:angular2/test/compiler/compUrl.html', 'loadedTemplate');
            compiler.normalizeDirectiveMetadata(
-                       runtimeMetadataResolver.getMetadata(CompWithTemplateUrl))
+                       runtimeMetadataResolver.getDirectiveMetadata(CompWithTemplateUrl))
                .then((meta: CompileDirectiveMetadata) => {
                  expect(meta.template.template).toEqual('loadedTemplate');
                  async.done();
@@ -243,7 +268,8 @@ export function main() {
          }));
 
       it('should copy all the other fields', inject([AsyncTestCompleter], (async) => {
-           var meta = runtimeMetadataResolver.getMetadata(CompWithBindingsAndStyles);
+           var meta =
+               runtimeMetadataResolver.getDirectiveMetadata(CompWithBindingsAndStylesAndPipes);
            compiler.normalizeDirectiveMetadata(meta).then((normMeta: CompileDirectiveMetadata) => {
              expect(normMeta.type).toEqual(meta.type);
              expect(normMeta.isComponent).toEqual(meta.isComponent);
@@ -279,23 +305,35 @@ export function main() {
   });
 }
 
+
+@Pipe({name: 'uppercase'})
+@Injectable()
+export class UpperCasePipe implements PipeTransform {
+  transform(value: string, args: any[] = null): string { return value.toUpperCase(); }
+}
+
 @Component({
   selector: 'comp-a',
-  host: {'[title]': 'someProp'},
+  host: {'[title]': '\'someHostValue\''},
   moduleId: THIS_MODULE_ID,
   exportAs: 'someExportAs'
 })
 @View({
-  template: '<a [href]="someProp"></a>',
+  template: '<a [href]="\'someCtxValue\' | uppercase"></a>',
   styles: ['div {color: red}'],
-  encapsulation: ViewEncapsulation.None
+  encapsulation: ViewEncapsulation.None,
+  pipes: [UpperCasePipe]
 })
-class CompWithBindingsAndStyles {
+export class CompWithBindingsAndStylesAndPipes {
 }
 
 @Component({selector: 'tree', moduleId: THIS_MODULE_ID})
-@View({template: '<tree></tree>', directives: [TreeComp], encapsulation: ViewEncapsulation.None})
-class TreeComp {
+@View({
+  template: '<template><tree></tree></template>',
+  directives: [TreeComp],
+  encapsulation: ViewEncapsulation.None
+})
+export class TreeComp {
 }
 
 @Component({selector: 'comp-wit-dup-tpl', moduleId: THIS_MODULE_ID})
@@ -304,34 +342,37 @@ class TreeComp {
   directives: [TreeComp, TreeComp],
   encapsulation: ViewEncapsulation.None
 })
-class CompWithDupDirectives {
+export class CompWithDupDirectives {
 }
 
 @Component({selector: 'comp-url', moduleId: THIS_MODULE_ID})
 @View({templateUrl: 'compUrl.html', encapsulation: ViewEncapsulation.None})
-class CompWithTemplateUrl {
+export class CompWithTemplateUrl {
 }
 
 @Component({selector: 'comp-tpl', moduleId: THIS_MODULE_ID})
 @View({
-  template: '<template><a [href]="someProp"></a></template>',
+  template: '<template><a [href]="\'someEmbeddedValue\'"></a></template>',
   encapsulation: ViewEncapsulation.None
 })
-class CompWithEmbeddedTemplate {
+export class CompWithEmbeddedTemplate {
 }
 
 
 @Directive({selector: 'plain'})
 @View({template: ''})
-class NonComponent {
+export class NonComponent {
 }
 
+
 function testableTemplateModule(sourceModule: SourceModule,
                                 normComp: CompileDirectiveMetadata): SourceModule {
-  var resultExpression =
-      `${THIS_MODULE_REF}humanizeTemplate(Host${normComp.type.name}Template.template)`;
-  var testableSource = `${sourceModule.sourceWithModuleRefs}
-  ${codeGenValueFn(['_'], resultExpression, '_run')};
+  var testableSource = `
+  ${sourceModule.sourceWithModuleRefs}
+  ${codeGenFnHeader(['_'], '_run')}{
+    ${REFLECTOR_MODULE_REF}reflector.reflectionCapabilities = new ${REFLECTION_CAPS_MODULE_REF}ReflectionCapabilities();
+    return ${THIS_MODULE_REF}humanizeViewFactory(hostViewFactory_${normComp.type.name}.viewFactory);
+  }
   ${codeGenExportVariable('run')}_run;`;
   return new SourceModule(sourceModule.moduleUrl, testableSource);
 }
@@ -343,75 +384,71 @@ function testableStylesModule(sourceModule: SourceModule): SourceModule {
   return new SourceModule(sourceModule.moduleUrl, testableSource);
 }
 
-// Attention: read by eval!
-export function humanizeTemplate(
-    template: CompiledComponentTemplate,
-    humanizedTemplates: Map<string, {[key: string]: any}> = null): {[key: string]: any} {
-  if (isBlank(humanizedTemplates)) {
-    humanizedTemplates = new Map<string, {[key: string]: any}>();
-  }
-  var result = humanizedTemplates.get(template.id);
+function humanizeView(view: AppView, cachedResults: Map<AppProtoView, any>): {[key: string]: any} {
+  var result = cachedResults.get(view.proto);
   if (isPresent(result)) {
     return result;
   }
-  var commands = [];
-  result = {
-    'styles': template.styles,
-    'commands': commands,
-    'cd': testChangeDetector(template.changeDetectorFactory)
-  };
-  humanizedTemplates.set(template.id, result);
-  visitAllCommands(new CommandHumanizer(commands, humanizedTemplates), template.commands);
-  return result;
-}
-
-class TestContext implements CompWithBindingsAndStyles, TreeComp, CompWithTemplateUrl,
-    CompWithEmbeddedTemplate, CompWithDupDirectives {
-  someProp: string;
-}
-
+  result = {};
+  // fill the cache early to break cycles.
+  cachedResults.set(view.proto, result);
 
-function testChangeDetector(changeDetectorFactory: Function): string[] {
-  var ctx = new TestContext();
-  ctx.someProp = 'someCtxValue';
-  var dir1 = new TestContext();
-  dir1.someProp = 'someDirValue';
+  view.changeDetector.detectChanges();
 
-  var dispatcher = new TestDispatcher([dir1], []);
-  var cd = changeDetectorFactory(dispatcher);
-  var locals = new Locals(null, MapWrapper.createFromStringMap({'someVar': null}));
-  cd.hydrate(ctx, locals, dispatcher, new TestPipes());
-  cd.detectChanges();
-  return dispatcher.log;
+  var pipes = {};
+  if (isPresent(view.proto.protoPipes)) {
+    StringMapWrapper.forEach(view.proto.protoPipes.config, (pipeProvider, pipeName) => {
+      pipes[pipeName] = stringify(pipeProvider.key.token);
+    });
+  }
+  var componentViews = [];
+  var embeddedViews = [];
+
+  view.appElements.forEach((appElement) => {
+    if (isPresent(appElement.componentView)) {
+      componentViews.push(humanizeView(appElement.componentView, cachedResults));
+    } else if (isPresent(appElement.embeddedViewFactory)) {
+      embeddedViews.push(
+          humanizeViewFactory(appElement.embeddedViewFactory, appElement, cachedResults));
+    }
+  });
+  result['styles'] = (<any>view.renderer).styles;
+  result['elements'] = (<any>view.renderer).elements;
+  result['pipes'] = pipes;
+  result['cd'] = (<any>view.renderer).props;
+  result['componentViews'] = componentViews;
+  result['embeddedViews'] = embeddedViews;
+  return result;
 }
 
-
-class CommandHumanizer implements CommandVisitor {
-  constructor(private result: any[],
-              private humanizedTemplates: Map<string, {[key: string]: any}>) {}
-  visitText(cmd: TextCmd, context: any): any {
-    this.result.push(`#text(${cmd.value})`);
-    return null;
-  }
-  visitNgContent(cmd: NgContentCmd, context: any): any { return null; }
-  visitBeginElement(cmd: BeginElementCmd, context: any): any {
-    this.result.push(`<${cmd.name}>`);
-    return null;
-  }
-  visitEndElement(context: any): any {
-    this.result.push('</>');
-    return null;
-  }
-  visitBeginComponent(cmd: BeginComponentCmd, context: any): any {
-    this.result.push(`<${cmd.name}>`);
-    this.result.push(humanizeTemplate(cmd.templateGetter(), this.humanizedTemplates));
-    return null;
+// Attention: read by eval!
+export function humanizeViewFactory(
+    viewFactory: Function, containerAppElement: AppElement = null,
+    cachedResults: Map<AppProtoView, any> = null): {[key: string]: any} {
+  if (isBlank(cachedResults)) {
+    cachedResults = new Map<AppProtoView, any>();
   }
-  visitEndComponent(context: any): any { return this.visitEndElement(context); }
-  visitEmbeddedTemplate(cmd: EmbeddedTemplateCmd, context: any): any {
-    this.result.push(`<template>`);
-    this.result.push({'cd': testChangeDetector(cmd.changeDetectorFactory)});
-    this.result.push(`</template>`);
-    return null;
+  var viewManager = new SpyAppViewManager();
+  viewManager.spy('createRenderComponentType')
+      .andCallFake((encapsulation: ViewEncapsulation, styles: Array<string | any[]>) => {
+        return new RenderComponentType('someId', encapsulation, styles);
+      });
+  var view: AppView = viewFactory(new RecordingRenderer([]), viewManager, containerAppElement, [],
+                                  null, null, null);
+  return humanizeView(view, cachedResults);
+}
+
+class RecordingRenderer extends SpyRenderer {
+  props: string[] = [];
+  elements: string[] = [];
+
+  constructor(public styles: string[]) {
+    super();
+    this.spy('renderComponent')
+        .andCallFake((componentProto) => new RecordingRenderer(componentProto.styles));
+    this.spy('setElementProperty')
+        .andCallFake((el, prop, value) => { this.props.push(`prop(${prop})=${value}`); });
+    this.spy('createElement')
+        .andCallFake((parent, elName) => { this.elements.push(`<${elName}>`); });
   }
 }
diff --git a/modules/angular2/test/compiler/template_parser_spec.ts b/modules/angular2/test/compiler/template_parser_spec.ts
index 1fe21da..55a42d6 100644
--- a/modules/angular2/test/compiler/template_parser_spec.ts
+++ b/modules/angular2/test/compiler/template_parser_spec.ts
@@ -21,6 +21,7 @@ import {
 } from 'angular2/src/compiler/template_parser';
 import {
   CompileDirectiveMetadata,
+  CompilePipeMetadata,
   CompileTypeMetadata,
   CompileTemplateMetadata
 } from 'angular2/src/compiler/directive_metadata';
@@ -69,8 +70,12 @@ export function main() {
           {selector: '[ngIf]', type: new CompileTypeMetadata({name: 'NgIf'}), inputs: ['ngIf']});
     }));
 
-    function parse(template: string, directives: CompileDirectiveMetadata[]): TemplateAst[] {
-      return parser.parse(template, directives, 'TestComp');
+    function parse(template: string, directives: CompileDirectiveMetadata[],
+                   pipes: CompilePipeMetadata[] = null): TemplateAst[] {
+      if (pipes === null) {
+        pipes = [];
+      }
+      return parser.parse(template, directives, pipes, 'TestComp');
     }
 
     describe('template transform', () => {
@@ -938,15 +943,29 @@ Property binding a not used by any directive on an embedded template ("[ERROR ->
       it('should support directive property', () => {
         var dirA = CompileDirectiveMetadata.create(
             {selector: 'div', type: new CompileTypeMetadata({name: 'DirA'}), inputs: ['aProp']});
-        expect(humanizeTplAstSourceSpans(parse('<div [aProp]="foo | bar"></div>', [dirA])))
+        expect(humanizeTplAstSourceSpans(parse('<div [aProp]="foo"></div>', [dirA])))
             .toEqual([
-              [ElementAst, 'div', '<div [aProp]="foo | bar">'],
-              [DirectiveAst, dirA, '<div [aProp]="foo | bar">'],
-              [BoundDirectivePropertyAst, 'aProp', '(foo | bar)', '[aProp]="foo | bar"']
+              [ElementAst, 'div', '<div [aProp]="foo">'],
+              [DirectiveAst, dirA, '<div [aProp]="foo">'],
+              [BoundDirectivePropertyAst, 'aProp', 'foo', '[aProp]="foo"']
             ]);
       });
 
     });
+
+    describe('pipes', () => {
+      it('should allow pipes that have been defined as dependencies', () => {
+        var testPipe =
+            new CompilePipeMetadata({name: 'test', type: new CompileTypeMetadata({name: 'DirA'})});
+        expect(() => parse('{{a | test}}', [], [testPipe])).not.toThrow();
+      });
+
+      it('should report pipes as error that have not been defined as dependencies', () => {
+        expect(() => parse('{{a | test}}', [])).toThrowError(`Template parse errors:
+The pipe 'test' could not be found ("[ERROR ->]{{a | test}}"): TestComp@0:0`);
+      });
+
+    });
   });
 }
 
diff --git a/modules/angular2/test/core/change_detection/change_detector_config.ts b/modules/angular2/test/core/change_detection/change_detector_config.ts
index ed74933..20260ed 100644
--- a/modules/angular2/test/core/change_detection/change_detector_config.ts
+++ b/modules/angular2/test/core/change_detection/change_detector_config.ts
@@ -101,8 +101,9 @@ export function getDefinition(id: string): TestDefinition {
 
   } else if (ListWrapper.indexOf(_availableHostEventDefinitions, id) >= 0) {
     var eventRecords = _createHostEventRecords(id, _DirectiveUpdating.basicRecords[0]);
-    let cdDef = new ChangeDetectorDefinition(id, null, [], [], eventRecords,
-                                             [_DirectiveUpdating.basicRecords[0]], genConfig);
+    let cdDef = new ChangeDetectorDefinition(
+        id, null, [], [], eventRecords,
+        [_DirectiveUpdating.basicRecords[0], _DirectiveUpdating.basicRecords[1]], genConfig);
     testDef = new TestDefinition(id, cdDef, null);
 
   } else if (id == "onPushObserveBinding") {
@@ -286,7 +287,9 @@ class _DirectiveUpdating {
       callAfterContentInit: true,
       callAfterContentChecked: true,
       callAfterViewInit: true,
-      callAfterViewChecked: true
+      callAfterViewChecked: true,
+      callOnDestroy: true,
+      outputs: [['eventEmitter', 'host-event']]
     }),
     new DirectiveRecord({
       directiveIndex: new DirectiveIndex(0, 1),
@@ -296,7 +299,9 @@ class _DirectiveUpdating {
       callAfterContentInit: true,
       callAfterContentChecked: true,
       callAfterViewInit: true,
-      callAfterViewChecked: true
+      callAfterViewChecked: true,
+      callOnDestroy: true,
+      outputs: [['eventEmitter', 'host-event']]
     })
   ];
 
diff --git a/modules/angular2/test/core/change_detection/change_detector_ref_spec.ts b/modules/angular2/test/core/change_detection/change_detector_ref_spec.ts
index 0941e59..0da57ec 100644
--- a/modules/angular2/test/core/change_detection/change_detector_ref_spec.ts
+++ b/modules/angular2/test/core/change_detection/change_detector_ref_spec.ts
@@ -28,4 +28,4 @@ export function main() {
       expect(changeDetector.spy('detectChanges')).toHaveBeenCalled();
     });
   });
-}
+}
\ No newline at end of file
diff --git a/modules/angular2/test/core/change_detection/change_detector_spec.ts b/modules/angular2/test/core/change_detection/change_detector_spec.ts
index 80a9cb3..4253fd1 100644
--- a/modules/angular2/test/core/change_detection/change_detector_spec.ts
+++ b/modules/angular2/test/core/change_detection/change_detector_spec.ts
@@ -25,6 +25,7 @@ import {
 } from 'angular2/src/facade/lang';
 import {BaseException, WrappedException} from 'angular2/src/facade/exceptions';
 import {MapWrapper, StringMapWrapper} from 'angular2/src/facade/collection';
+import {DOM} from 'angular2/src/platform/dom/dom_adapter';
 
 import {
   ChangeDispatcher,
@@ -53,6 +54,7 @@ import {getDefinition} from './change_detector_config';
 import {createObservableModel} from './change_detector_spec_util';
 import {getFactoryById} from './generated/change_detector_classes';
 import {IS_DART} from 'angular2/src/facade/lang';
+import {EventEmitter, ObservableWrapper} from 'angular2/src/facade/async';
 
 const _DEFAULT_CONTEXT = CONST_EXPR(new Object());
 
@@ -79,10 +81,10 @@ export function main() {
         switch (cdType) {
           case 'dynamic':
             var dynProto = new DynamicProtoChangeDetector(def);
-            return (dispatcher) => dynProto.instantiate(dispatcher);
+            return () => dynProto.instantiate();
           case 'JIT':
             var jitProto = new JitProtoChangeDetector(def);
-            return (dispatcher) => jitProto.instantiate(dispatcher);
+            return () => jitProto.instantiate();
           case 'Pregen':
             return getFactoryById(def.id);
           default:
@@ -92,7 +94,7 @@ export function main() {
 
       function _createWithoutHydrate(expression: string) {
         var dispatcher = new TestDispatcher();
-        var cd = _getChangeDetectorFactory(getDefinition(expression).cdDef)(dispatcher);
+        var cd = _getChangeDetectorFactory(getDefinition(expression).cdDef)();
         return new _ChangeDetectorAndDispatcher(cd, dispatcher);
       }
 
@@ -101,8 +103,8 @@ export function main() {
                                      registry = null, dispatcher = null) {
         if (isBlank(dispatcher)) dispatcher = new TestDispatcher();
         var testDef = getDefinition(expression);
-        var cd = _getChangeDetectorFactory(testDef.cdDef)(dispatcher);
-        cd.hydrate(context, testDef.locals, null, registry);
+        var cd = _getChangeDetectorFactory(testDef.cdDef)();
+        cd.hydrate(context, testDef.locals, dispatcher, registry);
         return new _ChangeDetectorAndDispatcher(cd, dispatcher);
       }
 
@@ -361,7 +363,6 @@ export function main() {
 
       it('should support interpolation', () => {
         var val = _createChangeDetector('interpolation', new TestData('value'));
-        val.changeDetector.hydrate(new TestData('value'), null, null, null);
 
         val.changeDetector.detectChanges();
 
@@ -369,8 +370,7 @@ export function main() {
       });
 
       it('should output empty strings for null values in interpolation', () => {
-        var val = _createChangeDetector('interpolation', new TestData('value'));
-        val.changeDetector.hydrate(new TestData(null), null, null, null);
+        var val = _createChangeDetector('interpolation', new TestData(null));
 
         val.changeDetector.detectChanges();
 
@@ -490,7 +490,7 @@ export function main() {
 
           it('should happen directly, without invoking the dispatcher', () => {
             var val = _createWithoutHydrate('directNoDispatcher');
-            val.changeDetector.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1], []),
+            val.changeDetector.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1], []),
                                        null);
             val.changeDetector.detectChanges();
             expect(val.dispatcher.loggedValues).toEqual([]);
@@ -501,7 +501,7 @@ export function main() {
             describe('ngOnChanges', () => {
               it('should notify the directive when a group of records changes', () => {
                 var cd = _createWithoutHydrate('groupChanges').changeDetector;
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1, directive2], []),
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1, directive2], []),
                            null);
                 cd.detectChanges();
                 expect(directive1.changes).toEqual({'a': 1, 'b': 2});
@@ -513,7 +513,7 @@ export function main() {
               it('should notify the directive when it is checked', () => {
                 var cd = _createWithoutHydrate('directiveDoCheck').changeDetector;
 
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1], []), null);
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1], []), null);
                 cd.detectChanges();
 
                 expect(directive1.ngDoCheckCalled).toBe(true);
@@ -526,7 +526,7 @@ export function main() {
               it('should not call ngDoCheck in detectNoChanges', () => {
                 var cd = _createWithoutHydrate('directiveDoCheck').changeDetector;
 
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1], []), null);
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1], []), null);
 
                 cd.checkNoChanges();
 
@@ -538,7 +538,7 @@ export function main() {
               it('should notify the directive after it has been checked the first time', () => {
                 var cd = _createWithoutHydrate('directiveOnInit').changeDetector;
 
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1, directive2], []),
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1, directive2], []),
                            null);
 
                 cd.detectChanges();
@@ -555,7 +555,7 @@ export function main() {
               it('should not call ngOnInit in detectNoChanges', () => {
                 var cd = _createWithoutHydrate('directiveOnInit').changeDetector;
 
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1], []), null);
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1], []), null);
 
                 cd.checkNoChanges();
 
@@ -565,7 +565,7 @@ export function main() {
               it('should not call ngOnInit again if it throws', () => {
                 var cd = _createWithoutHydrate('directiveOnInit').changeDetector;
 
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive3], []), null);
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive3], []), null);
                 var errored = false;
                 // First pass fails, but ngOnInit should be called.
                 try {
@@ -590,7 +590,7 @@ export function main() {
             describe('ngAfterContentInit', () => {
               it('should be called after processing the content children', () => {
                 var cd = _createWithoutHydrate('emptyWithDirectiveRecords').changeDetector;
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1, directive2], []),
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1, directive2], []),
                            null);
 
                 cd.detectChanges();
@@ -618,7 +618,7 @@ export function main() {
               it('should not be called when ngAfterContentInit is false', () => {
                 var cd = _createWithoutHydrate('noCallbacks').changeDetector;
 
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1], []), null);
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1], []), null);
 
                 cd.detectChanges();
 
@@ -629,7 +629,7 @@ export function main() {
             describe('ngAfterContentChecked', () => {
               it('should be called after processing all the children', () => {
                 var cd = _createWithoutHydrate('emptyWithDirectiveRecords').changeDetector;
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1, directive2], []),
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1, directive2], []),
                            null);
 
                 cd.detectChanges();
@@ -657,7 +657,7 @@ export function main() {
               it('should not be called when ngAfterContentChecked is false', () => {
                 var cd = _createWithoutHydrate('noCallbacks').changeDetector;
 
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1], []), null);
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1], []), null);
 
                 cd.detectChanges();
 
@@ -673,7 +673,7 @@ export function main() {
                    td1 = new TestDirective(() => ngOnChangesDoneCalls.push(td1));
                    var td2;
                    td2 = new TestDirective(() => ngOnChangesDoneCalls.push(td2));
-                   cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([td1, td2], []), null);
+                   cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([td1, td2], []), null);
 
                    cd.detectChanges();
 
@@ -694,10 +694,10 @@ export function main() {
                 parentDirective =
                     new TestDirective(() => { orderOfOperations.push(parentDirective); });
 
-                parent.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([parentDirective], []),
+                parent.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([parentDirective], []),
                                null);
                 child.hydrate(_DEFAULT_CONTEXT, null,
-                              new FakeDirectives([directiveInShadowDom], []), null);
+                              new TestDispatcher([directiveInShadowDom], []), null);
 
                 parent.detectChanges();
                 expect(orderOfOperations).toEqual([parentDirective, directiveInShadowDom]);
@@ -708,7 +708,7 @@ export function main() {
             describe('ngAfterViewInit', () => {
               it('should be called after processing the view children', () => {
                 var cd = _createWithoutHydrate('emptyWithDirectiveRecords').changeDetector;
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1, directive2], []),
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1, directive2], []),
                            null);
 
                 cd.detectChanges();
@@ -737,7 +737,7 @@ export function main() {
               it('should not be called when ngAfterViewInit is false', () => {
                 var cd = _createWithoutHydrate('noCallbacks').changeDetector;
 
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1], []), null);
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1], []), null);
 
                 cd.detectChanges();
 
@@ -748,7 +748,7 @@ export function main() {
             describe('ngAfterViewChecked', () => {
               it('should be called after processing the view children', () => {
                 var cd = _createWithoutHydrate('emptyWithDirectiveRecords').changeDetector;
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1, directive2], []),
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1, directive2], []),
                            null);
 
                 cd.detectChanges();
@@ -776,7 +776,7 @@ export function main() {
               it('should not be called when ngAfterViewChecked is false', () => {
                 var cd = _createWithoutHydrate('noCallbacks').changeDetector;
 
-                cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive1], []), null);
+                cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([directive1], []), null);
 
                 cd.detectChanges();
 
@@ -792,7 +792,7 @@ export function main() {
                    td1 = new TestDirective(null, () => ngOnChangesDoneCalls.push(td1));
                    var td2;
                    td2 = new TestDirective(null, () => ngOnChangesDoneCalls.push(td2));
-                   cd.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([td1, td2], []), null);
+                   cd.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([td1, td2], []), null);
 
                    cd.detectChanges();
 
@@ -813,15 +813,29 @@ export function main() {
                 parentDirective =
                     new TestDirective(null, () => { orderOfOperations.push(parentDirective); });
 
-                parent.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([parentDirective], []),
+                parent.hydrate(_DEFAULT_CONTEXT, null, new TestDispatcher([parentDirective], []),
                                null);
                 child.hydrate(_DEFAULT_CONTEXT, null,
-                              new FakeDirectives([directiveInShadowDom], []), null);
+                              new TestDispatcher([directiveInShadowDom], []), null);
 
                 parent.detectChanges();
                 expect(orderOfOperations).toEqual([directiveInShadowDom, parentDirective]);
               });
             });
+
+            describe('ngOnDestroy', () => {
+              it('should be called on dehydration', () => {
+                var cd = _createChangeDetector('emptyWithDirectiveRecords', _DEFAULT_CONTEXT, null,
+                                               new TestDispatcher([directive1, directive2], []))
+                             .changeDetector;
+
+                cd.dehydrate();
+
+                expect(directive1.destroyCalled).toBe(true);
+                expect(directive2.destroyCalled).toBe(true);
+              });
+            });
+
           });
 
         });
@@ -836,9 +850,8 @@ export function main() {
         });
 
         it('should be called for directive updates in the dev mode', () => {
-          var val = _createWithoutHydrate('directNoDispatcher');
-          val.changeDetector.hydrate(_DEFAULT_CONTEXT, null,
-                                     new FakeDirectives([new TestDirective()], []), null);
+          var val = _createChangeDetector('directNoDispatcher', _DEFAULT_CONTEXT, null,
+                                          new TestDispatcher([new TestDirective()], []));
           val.changeDetector.detectChanges();
           expect(val.dispatcher.debugLog).toEqual(["a=42"]);
         });
@@ -857,9 +870,8 @@ export function main() {
           var directive = new TestDirective();
           directive.a = 'aaa';
 
-          var val = _createWithoutHydrate('readingDirectives');
-          val.changeDetector.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([directive], []),
-                                     null);
+          var val = _createChangeDetector('readingDirectives', _DEFAULT_CONTEXT, null,
+                                          new TestDispatcher([directive], []));
 
           val.changeDetector.detectChanges();
 
@@ -997,7 +1009,7 @@ export function main() {
         });
 
         it('should not check a detached change detector', () => {
-          var val = _createChangeDetector('a', new TestData('value'));
+          var val = _createChangeDetector('a', _DEFAULT_CONTEXT);
 
           val.changeDetector.hydrate(_DEFAULT_CONTEXT, null, null, null);
           val.changeDetector.mode = ChangeDetectionStrategy.Detached;
@@ -1017,8 +1029,7 @@ export function main() {
         });
 
         it('should change CheckOnce to Checked', () => {
-          var cd = _createChangeDetector('10').changeDetector;
-          cd.hydrate(_DEFAULT_CONTEXT, null, null, null);
+          var cd = _createChangeDetector('10', _DEFAULT_CONTEXT).changeDetector;
           cd.mode = ChangeDetectionStrategy.CheckOnce;
 
           cd.detectChanges();
@@ -1027,8 +1038,7 @@ export function main() {
         });
 
         it('should not change the CheckAlways', () => {
-          var cd = _createChangeDetector('10').changeDetector;
-          cd.hydrate(_DEFAULT_CONTEXT, null, null, null);
+          var cd = _createChangeDetector('10', _DEFAULT_CONTEXT).changeDetector;
           cd.mode = ChangeDetectionStrategy.CheckAlways;
 
           cd.detectChanges();
@@ -1052,7 +1062,7 @@ export function main() {
             childDirectiveDetectorOnPush.mode = ChangeDetectionStrategy.Checked;
 
             directives =
-                new FakeDirectives([new TestData(null), new TestData(null)],
+                new TestDispatcher([new TestData(null), new TestData(null)],
                                    [childDirectiveDetectorRegular, childDirectiveDetectorOnPush]);
           });
 
@@ -1126,7 +1136,7 @@ export function main() {
               it('should mark OnPushObserve detectors as CheckOnce when an observable directive fires an event',
                  fakeAsync(() => {
                    var dir = createObservableModel();
-                   var directives = new FakeDirectives([dir], []);
+                   var directives = new TestDispatcher([dir], []);
 
                    var cd = _createWithoutHydrate('onPushObserveDirective').changeDetector;
                    cd.hydrate(_DEFAULT_CONTEXT, null, directives, null);
@@ -1290,30 +1300,31 @@ export function main() {
       });
 
       describe('handleEvent', () => {
-        var locals;
+        var event;
         var d: TestDirective;
 
         beforeEach(() => {
-          locals = new Locals(null, MapWrapper.createFromStringMap({"$event": "EVENT"}));
+          event = "EVENT";
           d = new TestDirective();
         });
 
         it('should execute events', () => {
           var val = _createChangeDetector('(event)="onEvent($event)"', d, null);
-          val.changeDetector.handleEvent("event", 0, locals);
+          val.changeDetector.handleEvent("event", 0, event);
           expect(d.event).toEqual("EVENT");
         });
 
         it('should execute host events', () => {
           var val = _createWithoutHydrate('(host-event)="onEvent($event)"');
-          val.changeDetector.hydrate(_DEFAULT_CONTEXT, null, new FakeDirectives([d], []), null);
-          val.changeDetector.handleEvent("host-event", 0, locals);
+          val.changeDetector.hydrate(_DEFAULT_CONTEXT, null,
+                                     new TestDispatcher([d, new TestDirective()], []), null);
+          val.changeDetector.handleEvent("host-event", 0, event);
           expect(d.event).toEqual("EVENT");
         });
 
         it('should support field assignments', () => {
           var val = _createChangeDetector('(event)="b=a=$event"', d, null);
-          val.changeDetector.handleEvent("event", 0, locals);
+          val.changeDetector.handleEvent("event", 0, event);
           expect(d.a).toEqual("EVENT");
           expect(d.b).toEqual("EVENT");
         });
@@ -1321,14 +1332,14 @@ export function main() {
         it('should support keyed assignments', () => {
           d.a = ["OLD"];
           var val = _createChangeDetector('(event)="a[0]=$event"', d, null);
-          val.changeDetector.handleEvent("event", 0, locals);
+          val.changeDetector.handleEvent("event", 0, event);
           expect(d.a).toEqual(["EVENT"]);
         });
 
         it('should support chains', () => {
           d.a = 0;
           var val = _createChangeDetector('(event)="a=a+1; a=a+1;"', d, null);
-          val.changeDetector.handleEvent("event", 0, locals);
+          val.changeDetector.handleEvent("event", 0, event);
           expect(d.a).toEqual(2);
         });
 
@@ -1339,23 +1350,83 @@ export function main() {
         //   }).toThrowError(new RegExp("Cannot reassign a variable binding"));
         // });
 
-        it('should return the prevent default value', () => {
+        it('should return false if the event handler returned false', () => {
           var val = _createChangeDetector('(event)="false"', d, null);
-          var res = val.changeDetector.handleEvent("event", 0, locals);
-          expect(res).toBe(true);
+          var res = val.changeDetector.handleEvent("event", 0, event);
+          expect(res).toBe(false);
 
           val = _createChangeDetector('(event)="true"', d, null);
-          res = val.changeDetector.handleEvent("event", 0, locals);
-          expect(res).toBe(false);
+          res = val.changeDetector.handleEvent("event", 0, event);
+          expect(res).toBe(true);
         });
 
         it('should support short-circuiting', () => {
           d.a = 0;
           var val = _createChangeDetector('(event)="true ? a = a + 1 : a = a + 1"', d, null);
-          val.changeDetector.handleEvent("event", 0, locals);
+          val.changeDetector.handleEvent("event", 0, event);
           expect(d.a).toEqual(1);
         });
       });
+
+      if (DOM.supportsDOMEvents()) {
+        describe('subscribe to EventEmitters', () => {
+          it('should call handleEvent when an output of a directive fires', fakeAsync(() => {
+               var directive1 = new TestDirective();
+               var directive2 = new TestDirective();
+               _createChangeDetector('(host-event)="onEvent(\$event)"', new Object(), null,
+                                     new TestDispatcher([directive1, directive2]));
+               ObservableWrapper.callEmit(directive2.eventEmitter, 'EVENT');
+
+               tick();
+
+               expect(directive1.event).toEqual('EVENT');
+             }));
+
+          it('should ignore events when dehydrated', fakeAsync(() => {
+               var directive1 = new TestDirective();
+               var directive2 = new TestDirective();
+               var cd = _createChangeDetector('(host-event)="onEvent(\$event)"', new Object(), null,
+                                              new TestDispatcher([directive1, directive2]))
+                            .changeDetector;
+               cd.dehydrate();
+               ObservableWrapper.callEmit(directive2.eventEmitter, 'EVENT');
+
+               tick();
+
+               expect(directive1.event).toBeFalsy();
+             }));
+        });
+      }
+
+      describe('destroyRecursive', () => {
+        var parent, child;
+        var parentDispatcher, childDispatcher;
+
+        beforeEach(() => {
+          parentDispatcher = new TestDispatcher();
+          parent = _createChangeDetector('10', null, null, parentDispatcher).changeDetector;
+          childDispatcher = new TestDispatcher();
+          child = _createChangeDetector('"str"', null, null, childDispatcher).changeDetector;
+          parent.addContentChild(child);
+        });
+
+        it('should notify the dispatcher', () => {
+          child.destroyRecursive();
+          expect(childDispatcher.ngOnDestroyCalled).toBe(true);
+        });
+
+        it('should dehydrate the change detector', () => {
+          child.destroyRecursive();
+          expect(child.hydrated()).toBe(false);
+        });
+
+        it('should destroy children', () => {
+          parent.destroyRecursive();
+          expect(parentDispatcher.ngOnDestroyCalled).toBe(true);
+          expect(childDispatcher.ngOnDestroyCalled).toBe(true);
+        });
+
+      });
     });
   });
 }
@@ -1416,7 +1487,9 @@ class TestDirective {
 
   ngAfterViewInitCalled = false;
   ngAfterViewCheckedCalled = false;
+  destroyCalled: boolean = false;
   event;
+  eventEmitter: EventEmitter<string> = new EventEmitter<string>();
 
   constructor(public ngAfterContentCheckedSpy = null, public ngAfterViewCheckedSpy = null,
               public throwOnInit = false) {}
@@ -1455,6 +1528,8 @@ class TestDirective {
       this.ngAfterViewCheckedSpy();
     }
   }
+
+  ngOnDestroy() { this.destroyCalled = true; }
 }
 
 class Person {
@@ -1518,23 +1593,24 @@ class TestData {
   constructor(public a: any) {}
 }
 
-class FakeDirectives {
-  constructor(public directives: Array<TestData | TestDirective>,
-              public detectors: ProtoChangeDetector[]) {}
-
-  getDirectiveFor(di: DirectiveIndex) { return this.directives[di.directiveIndex]; }
-
-  getDetectorFor(di: DirectiveIndex) { return this.detectors[di.directiveIndex]; }
-}
-
 class TestDispatcher implements ChangeDispatcher {
   log: string[];
   debugLog: string[];
   loggedValues: any[];
   ngAfterContentCheckedCalled: boolean = false;
   ngAfterViewCheckedCalled: boolean = false;
+  ngOnDestroyCalled: boolean = false;
 
-  constructor() { this.clear(); }
+  constructor(public directives: Array<TestData | TestDirective> = null,
+              public detectors: any[] = null) {
+    if (isBlank(this.directives)) {
+      this.directives = [];
+    }
+    if (isBlank(this.detectors)) {
+      this.detectors = [];
+    }
+    this.clear();
+  }
 
   clear() {
     this.log = [];
@@ -1543,6 +1619,10 @@ class TestDispatcher implements ChangeDispatcher {
     this.ngAfterContentCheckedCalled = true;
   }
 
+  getDirectiveFor(di: DirectiveIndex) { return this.directives[di.directiveIndex]; }
+
+  getDetectorFor(di: DirectiveIndex) { return this.detectors[di.directiveIndex]; }
+
   notifyOnBinding(target, value) {
     this.log.push(`${target.name}=${this._asString(value)}`);
     this.loggedValues.push(value);
@@ -1553,7 +1633,9 @@ class TestDispatcher implements ChangeDispatcher {
   notifyAfterContentChecked() { this.ngAfterContentCheckedCalled = true; }
   notifyAfterViewChecked() { this.ngAfterViewCheckedCalled = true; }
 
-  getDebugContext(a, b) { return null; }
+  notifyOnDestroy() { this.ngOnDestroyCalled = true; }
+
+  getDebugContext(a, b, c) { return null; }
 
   _asString(value) {
     if (isNumber(value) && NumberWrapper.isNaN(value)) {
diff --git a/modules/angular2/test/core/change_detection/parser/locals_spec.ts b/modules/angular2/test/core/change_detection/parser/locals_spec.ts
index 603b660..4c21cf2 100644
--- a/modules/angular2/test/core/change_detection/parser/locals_spec.ts
+++ b/modules/angular2/test/core/change_detection/parser/locals_spec.ts
@@ -31,7 +31,7 @@ export function main() {
        () => { expect(() => locals.set('notPresent', 'bar')).toThrowError(); });
 
     it('should clearValues', () => {
-      locals.clearValues();
+      locals.clearLocalValues();
       expect(locals.get('key')).toBe(null);
     });
   })
diff --git a/modules/angular2/test/core/di/injector_spec.ts b/modules/angular2/test/core/di/injector_spec.ts
index 41bc809..e6f9c5d 100644
--- a/modules/angular2/test/core/di/injector_spec.ts
+++ b/modules/angular2/test/core/di/injector_spec.ts
@@ -111,8 +111,10 @@ export function main() {
      providers: dynamicProviders,
      strategyClass: InjectorDynamicStrategy
    }].forEach((context) => {
-    function createInjector(providers: any[]) {
-      return Injector.resolveAndCreate(providers.concat(context['providers']));
+    function createInjector(providers: any[], parent: Injector = null, isHost: boolean = false) {
+      return new Injector(ProtoInjector.fromResolvedProviders(
+                              Injector.resolve(providers.concat(context['providers']))),
+                          parent, isHost);
     }
 
     describe(`injector ${context['strategy']}`, () => {
@@ -317,7 +319,7 @@ export function main() {
           new ProviderWithVisibility(providers[0], Visibility.Public),
           new ProviderWithVisibility(providers[1], Visibility.Public)
         ]);
-        var injector = new Injector(proto, null, null);
+        var injector = new Injector(proto);
 
         try {
           injector.get(Car);
@@ -339,8 +341,8 @@ export function main() {
         var protoChild =
             new ProtoInjector([new ProviderWithVisibility(carProvider, Visibility.Public)]);
 
-        var parent = new Injector(protoParent, null, null, () => "parentContext");
-        var child = new Injector(protoChild, parent, null, () => "childContext");
+        var parent = new Injector(protoParent, null, false, null, () => "parentContext");
+        var child = new Injector(protoChild, parent, false, null, () => "childContext");
 
         try {
           child.get(Car);
@@ -379,7 +381,7 @@ export function main() {
         var providers = Injector.resolve([Car]);
         var proto =
             new ProtoInjector([new ProviderWithVisibility(providers[0], Visibility.Public)]);
-        var injector = new Injector(proto, null, depProvider);
+        var injector = new Injector(proto, null, false, depProvider);
 
         expect(injector.get(Car).engine).toEqual(e);
         expect(depProvider.spy("getDependency"))
@@ -489,11 +491,9 @@ export function main() {
               new ProtoInjector([new ProviderWithVisibility(engine, Visibility.Private)]);
           var parent = new Injector(protoParent);
 
-          var child = Injector.resolveAndCreate([
-            provide(Car, {useFactory: (e) => new Car(e), deps: [[Engine, new HostMetadata()]]})
-          ]);
-
-          child.internalStrategy.attach(parent, true);  // host
+          var child = createInjector(
+              [provide(Car, {useFactory: (e) => new Car(e), deps: [[Engine, new HostMetadata()]]})],
+              parent, true);  // host
 
           expect(child.get(Car)).toBeAnInstanceOf(Car);
         });
@@ -504,11 +504,9 @@ export function main() {
               new ProtoInjector([new ProviderWithVisibility(engine, Visibility.Public)]);
           var parent = new Injector(protoParent);
 
-          var child = Injector.resolveAndCreate([
-            provide(Car, {useFactory: (e) => new Car(e), deps: [[Engine, new HostMetadata()]]})
-          ]);
-
-          child.internalStrategy.attach(parent, true);  // host
+          var child = createInjector(
+              [provide(Car, {useFactory: (e) => new Car(e), deps: [[Engine, new HostMetadata()]]})],
+              parent, true);  // host
 
           expect(() => child.get(Car))
               .toThrowError(`No provider for Engine! (${stringify(Car)} -> ${stringify(Engine)})`);
@@ -532,12 +530,13 @@ export function main() {
               new ProtoInjector([new ProviderWithVisibility(engine, Visibility.Private)]);
           var parent = new Injector(protoParent);
 
-          var child = Injector.resolveAndCreate([
-            provide(Engine, {useClass: BrokenEngine}),
-            provide(Car,
-                    {useFactory: (e) => new Car(e), deps: [[Engine, new SkipSelfMetadata()]]})
-          ]);
-          child.internalStrategy.attach(parent, true);  // boundary
+          var child = createInjector(
+              [
+                provide(Engine, {useClass: BrokenEngine}),
+                provide(Car,
+                        {useFactory: (e) => new Car(e), deps: [[Engine, new SkipSelfMetadata()]]})
+              ],
+              parent, true);  // boundary
 
           expect(child.get(Car)).toBeAnInstanceOf(Car);
         });
@@ -548,12 +547,13 @@ export function main() {
               new ProtoInjector([new ProviderWithVisibility(engine, Visibility.Public)]);
           var parent = new Injector(protoParent);
 
-          var child = Injector.resolveAndCreate([
-            provide(Engine, {useClass: BrokenEngine}),
-            provide(Car,
-                    {useFactory: (e) => new Car(e), deps: [[Engine, new SkipSelfMetadata()]]})
-          ]);
-          child.internalStrategy.attach(parent, true);  // boundary
+          var child = createInjector(
+              [
+                provide(Engine, {useClass: BrokenEngine}),
+                provide(Car,
+                        {useFactory: (e) => new Car(e), deps: [[Engine, new SkipSelfMetadata()]]})
+              ],
+              parent, true);  // boundary
 
           expect(child.get(Car)).toBeAnInstanceOf(Car);
         });
@@ -564,12 +564,13 @@ export function main() {
               new ProtoInjector([new ProviderWithVisibility(engine, Visibility.Private)]);
           var parent = new Injector(protoParent);
 
-          var child = Injector.resolveAndCreate([
-            provide(Engine, {useClass: BrokenEngine}),
-            provide(Car,
-                    {useFactory: (e) => new Car(e), deps: [[Engine, new SkipSelfMetadata()]]})
-          ]);
-          child.internalStrategy.attach(parent, false);
+          var child = createInjector(
+              [
+                provide(Engine, {useClass: BrokenEngine}),
+                provide(Car,
+                        {useFactory: (e) => new Car(e), deps: [[Engine, new SkipSelfMetadata()]]})
+              ],
+              parent, false);
 
           expect(() => child.get(Car))
               .toThrowError(`No provider for Engine! (${stringify(Car)} -> ${stringify(Engine)})`);
diff --git a/modules/angular2/test/core/linker/compiler_spec.ts b/modules/angular2/test/core/linker/compiler_spec.ts
index d6f3c31..480c0bd 100644
--- a/modules/angular2/test/core/linker/compiler_spec.ts
+++ b/modules/angular2/test/core/linker/compiler_spec.ts
@@ -13,54 +13,36 @@ import {
   beforeEachProviders
 } from 'angular2/testing_internal';
 
-import {Component, View, provide} from 'angular2/core';
-import {SpyProtoViewFactory} from '../spies';
-import {
-  CompiledHostTemplate,
-  CompiledComponentTemplate,
-  BeginComponentCmd
-} from 'angular2/src/core/linker/template_commands';
+import {provide} from 'angular2/core';
 import {Compiler} from 'angular2/src/core/linker/compiler';
-import {ProtoViewFactory} from 'angular2/src/core/linker/proto_view_factory';
 import {reflector, ReflectionInfo} from 'angular2/src/core/reflection/reflection';
-import {AppProtoView} from 'angular2/src/core/linker/view';
 import {Compiler_} from "angular2/src/core/linker/compiler";
+import {HostViewFactory} from 'angular2/src/core/linker/view';
 
 export function main() {
   describe('Compiler', () => {
-    var compiler: Compiler;
-    var protoViewFactorySpy;
-    var someProtoView;
-    var cht: CompiledHostTemplate;
+    var someHostViewFactory;
 
-    beforeEachProviders(() => {
-      protoViewFactorySpy = new SpyProtoViewFactory();
-      someProtoView = new AppProtoView(null, null, null, null, null, null, null);
-      protoViewFactorySpy.spy('createHost').andReturn(someProtoView);
-      var factory = provide(ProtoViewFactory, {useValue: protoViewFactorySpy});
-      var classProvider = provide(Compiler, {useClass: Compiler_});
-      var providers = [factory, classProvider];
-      return providers;
-    });
+    beforeEachProviders(() => [provide(Compiler, {useClass: Compiler_})]);
 
     beforeEach(inject([Compiler], (_compiler) => {
-      compiler = _compiler;
-      cht = new CompiledHostTemplate(new CompiledComponentTemplate('aCompId', null, null, null));
-      reflector.registerType(SomeComponent, new ReflectionInfo([cht]));
+      someHostViewFactory = new HostViewFactory(null, null);
+      reflector.registerType(SomeComponent, new ReflectionInfo([someHostViewFactory]));
     }));
 
-    it('should read the template from an annotation', inject([AsyncTestCompleter], (async) => {
+    it('should read the template from an annotation',
+       inject([AsyncTestCompleter, Compiler], (async, compiler) => {
          compiler.compileInHost(SomeComponent)
-             .then((_) => {
-               expect(protoViewFactorySpy.spy('createHost')).toHaveBeenCalledWith(cht);
+             .then((hostViewFactoryRef) => {
+               expect(hostViewFactoryRef.internalHostViewFactory).toBe(someHostViewFactory);
                async.done();
              });
        }));
 
-    it('should clear the cache', () => {
-      compiler.clearCache();
-      expect(protoViewFactorySpy.spy('clearCache')).toHaveBeenCalled();
-    });
+    it('should clear the cache', inject([Compiler], (compiler) => {
+         // Nothing to assert for now...
+         compiler.clearCache();
+       }));
   });
 }
 
diff --git a/modules/angular2/test/core/linker/dynamic_component_loader_spec.ts b/modules/angular2/test/core/linker/dynamic_component_loader_spec.ts
index 8d90860..7b1c272 100644
--- a/modules/angular2/test/core/linker/dynamic_component_loader_spec.ts
+++ b/modules/angular2/test/core/linker/dynamic_component_loader_spec.ts
@@ -28,6 +28,7 @@ import {DOM} from 'angular2/src/platform/dom/dom_adapter';
 import {ComponentFixture_} from "angular2/src/testing/test_component_builder";
 import {BaseException} from 'angular2/src/facade/exceptions';
 import {PromiseWrapper} from 'angular2/src/facade/promise';
+import {stringify} from 'angular2/src/facade/lang';
 
 export function main() {
   describe('DynamicComponentLoader', function() {
@@ -164,6 +165,44 @@ export function main() {
                         async.done();
                       });
                 }));
+
+      it('should allow to pass projectable nodes',
+         inject([DynamicComponentLoader, TestComponentBuilder, AsyncTestCompleter],
+                (loader, tcb: TestComponentBuilder, async) => {
+                  tcb.overrideView(MyComp,
+                                   new ViewMetadata({template: '<div #loc></div>', directives: []}))
+                      .createAsync(MyComp)
+                      .then((tc) => {
+                        loader.loadIntoLocation(DynamicallyLoadedWithNgContent,
+                                                tc.debugElement.elementRef, 'loc', null,
+                                                [[DOM.createTextNode('hello')]])
+                            .then(ref => {
+                              tc.detectChanges();
+                              expect(tc.nativeElement).toHaveText('dynamic(hello)');
+                              async.done();
+                            });
+                      });
+                }));
+
+      it('should throw if not enough projectable nodes are passed in',
+         inject(
+             [DynamicComponentLoader, TestComponentBuilder, AsyncTestCompleter],
+             (loader, tcb: TestComponentBuilder, async) => {
+               tcb.overrideView(MyComp,
+                                new ViewMetadata({template: '<div #loc></div>', directives: []}))
+                   .createAsync(MyComp)
+                   .then((tc) => {
+                     PromiseWrapper.catchError(
+                         loader.loadIntoLocation(DynamicallyLoadedWithNgContent,
+                                                 tc.debugElement.elementRef, 'loc', null, []),
+                         (e) => {
+                           expect(e.message).toContain(
+                               `The component ${stringify(DynamicallyLoadedWithNgContent)} has 1 <ng-content> elements, but only 0 slots were provided`);
+                           async.done();
+                         });
+                   });
+             }));
+
     });
 
     describe("loading next to a location", () => {
@@ -248,17 +287,37 @@ export function main() {
                       });
                 }));
 
+      it('should allow to pass projectable nodes',
+         inject([DynamicComponentLoader, TestComponentBuilder, AsyncTestCompleter],
+                (loader, tcb: TestComponentBuilder, async) => {
+                  tcb.overrideView(MyComp, new ViewMetadata({template: '', directives: [Location]}))
+                      .createAsync(MyComp)
+                      .then((tc) => {
+                        loader.loadNextToLocation(DynamicallyLoadedWithNgContent,
+                                                  tc.debugElement.elementRef, null,
+                                                  [[DOM.createTextNode('hello')]])
+                            .then(ref => {
+                              tc.detectChanges();
+                              var newlyInsertedElement =
+                                  DOM.nextSibling(tc.debugElement.nativeElement);
+                              expect(newlyInsertedElement).toHaveText('dynamic(hello)');
+                              async.done();
+                            });
+                      });
+                }));
+
     });
 
     describe('loadAsRoot', () => {
       it('should allow to create, update and destroy components',
          inject([AsyncTestCompleter, DynamicComponentLoader, DOCUMENT, Injector],
                 (async, loader, doc, injector) => {
-                  var rootEl = el('<child-cmp></child-cmp>');
+                  var rootEl = createRootElement(doc, 'child-cmp');
                   DOM.appendChild(doc.body, rootEl);
                   loader.loadAsRoot(ChildComp, null, injector)
                       .then((componentRef) => {
                         var el = new ComponentFixture_(componentRef);
+
                         expect(rootEl.parentNode).toBe(doc.body);
 
                         el.detectChanges();
@@ -279,11 +338,35 @@ export function main() {
                       });
                 }));
 
+      it('should allow to pass projectable nodes',
+         inject([AsyncTestCompleter, DynamicComponentLoader, DOCUMENT, Injector],
+                (async, loader, doc, injector) => {
+                  var rootEl = createRootElement(doc, 'dummy');
+                  DOM.appendChild(doc.body, rootEl);
+                  loader.loadAsRoot(DynamicallyLoadedWithNgContent, null, injector, null,
+                                    [[DOM.createTextNode('hello')]])
+                      .then((_) => {
+                        expect(rootEl).toHaveText('dynamic(hello)');
+
+                        async.done();
+                      });
+                }));
+
     });
 
   });
 }
 
+function createRootElement(doc: any, name: string): any {
+  var nodes = DOM.querySelectorAll(doc, name);
+  for (var i = 0; i < nodes.length; i++) {
+    DOM.remove(nodes[i]);
+  }
+  var rootEl = el(`<${name}></${name}>`);
+  DOM.appendChild(doc.body, rootEl);
+  return rootEl;
+}
+
 @Component({
   selector: 'child-cmp',
 })
@@ -335,6 +418,14 @@ class DynamicallyLoadedWithHostProps {
   constructor() { this.id = "default"; }
 }
 
+@Component({selector: 'dummy'})
+@View({template: "dynamic(<ng-content></ng-content>)"})
+class DynamicallyLoadedWithNgContent {
+  id: string;
+
+  constructor() { this.id = "default"; }
+}
+
 @Component({selector: 'location'})
 @View({template: "Location;"})
 class Location {
diff --git a/modules/angular2/test/core/linker/element_injector_spec.ts b/modules/angular2/test/core/linker/element_injector_spec.ts
deleted file mode 100644
index d6ae754..0000000
--- a/modules/angular2/test/core/linker/element_injector_spec.ts
+++ /dev/null
@@ -1,1038 +0,0 @@
-// TODO(tbosch): clang-format screws this up, see https://github.com/angular/clang-format/issues/11.
-// Enable clang-format here again when this is fixed.
-// clang-format off
-import {
-  describe,
-  ddescribe,
-  it,
-  iit,
-  xit,
-  xdescribe,
-  expect,
-  beforeEach,
-  inject,
-  AsyncTestCompleter,
-  el,
-  containsRegexp
-} from 'angular2/testing_internal';
-import {SpyView, SpyElementRef} from '../spies';
-import {isBlank, isPresent, stringify} from 'angular2/src/facade/lang';
-import {
-  ListWrapper,
-  MapWrapper,
-  StringMapWrapper,
-  iterateListLike
-} from 'angular2/src/facade/collection';
-import {
-  ProtoElementInjector,
-  ElementInjector,
-  PreBuiltObjects,
-  DirectiveProvider,
-  TreeNode
-} from 'angular2/src/core/linker/element_injector';
-import {
-  Attribute,
-  Query,
-  ViewQuery,
-  ComponentMetadata,
-  DirectiveMetadata
-} from 'angular2/src/core/metadata';
-import {OnDestroy} from 'angular2/core';
-import {provide, Injector, Provider, Optional, Inject, Injectable, Self, SkipSelf, InjectMetadata, Host, HostMetadata, SkipSelfMetadata} from 'angular2/core';
-import {ViewContainerRef, ViewContainerRef_} from 'angular2/src/core/linker/view_container_ref';
-import {TemplateRef, TemplateRef_} from 'angular2/src/core/linker/template_ref';
-import {ElementRef} from 'angular2/src/core/linker/element_ref';
-import {DynamicChangeDetector, ChangeDetectorRef, Parser, Lexer} from 'angular2/src/core/change_detection/change_detection';
-import {QueryList} from 'angular2/src/core/linker/query_list';
-import {AppView, AppViewContainer} from "angular2/src/core/linker/view";
-
-function createDummyView(detector = null): AppView {
-  var res = new SpyView();
-  res.prop("changeDetector", detector);
-  res.prop("elementOffset", 0);
-  res.prop("elementInjectors", []);
-  res.prop("viewContainers", []);
-  res.prop("ownBindersCount", 0);
-  return <any> res;
-}
-
-function addInj(view, inj) {
-  var injs: ElementInjector[] = view.elementInjectors;
-  injs.push(inj);
-  var containers: AppViewContainer[] = view.viewContainers;
-  containers.push(null);
-  view.prop("ownBindersCount", view.ownBindersCount + 1);
-}
-
-@Injectable()
-class SimpleDirective {}
-
-class SimpleService {}
-
-@Injectable()
-class SomeOtherDirective {}
-
-var _constructionCount = 0;
-@Injectable()
-class CountingDirective {
-  count: number;
-  constructor() {
-    this.count = _constructionCount;
-    _constructionCount += 1;
-  }
-}
-
-@Injectable()
-class FancyCountingDirective extends CountingDirective {
-  constructor() { super(); }
-}
-
-@Injectable()
-class NeedsDirective {
-  dependency: SimpleDirective;
-  constructor(@Self() dependency: SimpleDirective) { this.dependency = dependency; }
-}
-
-@Injectable()
-class OptionallyNeedsDirective {
-  dependency: SimpleDirective;
-  constructor(@Self() @Optional() dependency: SimpleDirective) { this.dependency = dependency; }
-}
-
-@Injectable()
-class NeeedsDirectiveFromHost {
-  dependency: SimpleDirective;
-  constructor(@Host() dependency: SimpleDirective) { this.dependency = dependency; }
-}
-
-@Injectable()
-class NeedsDirectiveFromHostShadowDom {
-  dependency: SimpleDirective;
-  constructor(dependency: SimpleDirective) { this.dependency = dependency; }
-}
-
-@Injectable()
-class NeedsService {
-  service: any;
-  constructor(@Inject("service") service) { this.service = service; }
-}
-
-@Injectable()
-class NeedsServiceFromHost {
-  service: any;
-  constructor(@Host() @Inject("service") service) { this.service = service; }
-}
-
-class HasEventEmitter {
-  emitter;
-  constructor() { this.emitter = "emitter"; }
-}
-
-class NeedsAttribute {
-  typeAttribute;
-  titleAttribute;
-  fooAttribute;
-  constructor(@Attribute('type') typeAttribute: String, @Attribute('title') titleAttribute: String,
-              @Attribute('foo') fooAttribute: String) {
-    this.typeAttribute = typeAttribute;
-    this.titleAttribute = titleAttribute;
-    this.fooAttribute = fooAttribute;
-  }
-}
-
-@Injectable()
-class NeedsAttributeNoType {
-  fooAttribute;
-  constructor(@Attribute('foo') fooAttribute) { this.fooAttribute = fooAttribute; }
-}
-
-@Injectable()
-class NeedsQuery {
-  query: QueryList<CountingDirective>;
-  constructor(@Query(CountingDirective) query: QueryList<CountingDirective>) { this.query = query; }
-}
-
-@Injectable()
-class NeedsViewQuery {
-  query: QueryList<CountingDirective>;
-  constructor(@ViewQuery(CountingDirective) query: QueryList<CountingDirective>) { this.query = query; }
-}
-
-@Injectable()
-class NeedsQueryByVarBindings {
-  query: QueryList<any>;
-  constructor(@Query("one,two") query: QueryList<any>) { this.query = query; }
-}
-
-@Injectable()
-class NeedsTemplateRefQuery {
-  query: QueryList<TemplateRef>;
-  constructor(@Query(TemplateRef) query: QueryList<TemplateRef>) { this.query = query; }
-}
-
-@Injectable()
-class NeedsElementRef {
-  elementRef;
-  constructor(ref: ElementRef) { this.elementRef = ref; }
-}
-
-@Injectable()
-class NeedsViewContainer {
-  viewContainer;
-  constructor(vc: ViewContainerRef) { this.viewContainer = vc; }
-}
-
-@Injectable()
-class NeedsTemplateRef {
-  templateRef;
-  constructor(ref: TemplateRef) { this.templateRef = ref; }
-}
-
-@Injectable()
-class OptionallyInjectsTemplateRef {
-  templateRef;
-  constructor(@Optional() ref: TemplateRef) { this.templateRef = ref; }
-}
-
-@Injectable()
-class DirectiveNeedsChangeDetectorRef {
-  constructor(public changeDetectorRef: ChangeDetectorRef) {}
-}
-
-@Injectable()
-class ComponentNeedsChangeDetectorRef {
-  constructor(public changeDetectorRef: ChangeDetectorRef) {}
-}
-
-@Injectable()
-class PipeNeedsChangeDetectorRef {
-  constructor(public changeDetectorRef: ChangeDetectorRef) {}
-}
-
-class A_Needs_B {
-  constructor(dep) {}
-}
-
-class B_Needs_A {
-  constructor(dep) {}
-}
-
-class DirectiveWithDestroy implements OnDestroy {
-  ngOnDestroyCounter: number;
-
-  constructor() { this.ngOnDestroyCounter = 0; }
-
-  ngOnDestroy() { this.ngOnDestroyCounter++; }
-}
-
-export function main() {
-  var defaultPreBuiltObjects = new PreBuiltObjects(null, createDummyView(), <any>new SpyElementRef(), null);
-
-  // An injector with more than 10 providers will switch to the dynamic strategy
-  var dynamicProviders = [];
-
-  for (var i = 0; i < 20; i++) {
-    dynamicProviders.push(provide(i, {useValue: i}));
-  }
-
-  function createPei(parent, index, providers: any[], distance = 1, hasShadowRoot = false, dirVariableBindings = null) {
-    var directiveProvider = providers.map(b => {
-      if (b instanceof DirectiveProvider) return b;
-      if (b instanceof Provider) return DirectiveProvider.createFromProvider(b, null);
-      return DirectiveProvider.createFromType(b, null);
-    });
-    return ProtoElementInjector.create(parent, index, directiveProvider, hasShadowRoot, distance, dirVariableBindings);
-  }
-
-  function injector(providers, imperativelyCreatedInjector = null, isComponent: boolean = false,
-                    preBuiltObjects = null, attributes = null, dirVariableBindings = null) {
-    var proto = createPei(null, 0, providers, 0, isComponent, dirVariableBindings);
-    proto.attributes = attributes;
-
-    var inj = proto.instantiate(null);
-    var preBuilt = isPresent(preBuiltObjects) ? preBuiltObjects : defaultPreBuiltObjects;
-    inj.hydrate(imperativelyCreatedInjector, null, preBuilt);
-    return inj;
-  }
-
-  function parentChildInjectors(parentProviders, childProviders, parentPreBuildObjects = null, imperativelyCreatedInjector = null) {
-    if (isBlank(parentPreBuildObjects)) parentPreBuildObjects = defaultPreBuiltObjects;
-
-    var protoParent = createPei(null, 0, parentProviders);
-    var parent = protoParent.instantiate(null);
-
-    parent.hydrate(null, null, parentPreBuildObjects);
-
-    var protoChild = createPei(protoParent, 1, childProviders, 1, false);
-    var child = protoChild.instantiate(parent);
-    child.hydrate(imperativelyCreatedInjector, null, defaultPreBuiltObjects);
-
-    return child;
-  }
-
-  function hostShadowInjectors(hostProviders: any[],
-                               shadowProviders: any[], imperativelyCreatedInjector = null): ElementInjector {
-    var protoHost = createPei(null, 0, hostProviders, 0, true);
-    var host = protoHost.instantiate(null);
-    host.hydrate(null, null, defaultPreBuiltObjects);
-
-    var protoShadow = createPei(null, 0, shadowProviders, 0, false);
-    var shadow = protoShadow.instantiate(null);
-    shadow.hydrate(imperativelyCreatedInjector, host, null);
-
-    return shadow;
-  }
-
-  describe('TreeNodes', () => {
-    var root, child;
-
-    beforeEach(() => {
-      root = new TreeNode(null);
-      child = new TreeNode(root);
-    });
-
-    it('should support removing and adding the parent', () => {
-      expect(child.parent).toEqual(root);
-      child.remove();
-      expect(child.parent).toEqual(null);
-      root.addChild(child);
-      expect(child.parent).toEqual(root);
-    });
-  });
-
-  describe("ProtoElementInjector", () => {
-    describe("direct parent", () => {
-      it("should return parent proto injector when distance is 1", () => {
-        var distance = 1;
-        var protoParent = createPei(null, 0, []);
-        var protoChild = createPei(protoParent, 0, [], distance, false);
-
-        expect(protoChild.directParent()).toEqual(protoParent);
-      });
-
-      it("should return null otherwise", () => {
-        var distance = 2;
-        var protoParent = createPei(null, 0, []);
-        var protoChild = createPei(protoParent, 0, [], distance, false);
-
-        expect(protoChild.directParent()).toEqual(null);
-      });
-
-    });
-
-    describe('inline strategy', () => {
-      it("should allow for direct access using getProviderAtIndex", () => {
-        var proto = createPei(null, 0, [provide(SimpleDirective, {useClass: SimpleDirective})]);
-
-        expect(proto.getProviderAtIndex(0)).toBeAnInstanceOf(DirectiveProvider);
-        expect(() => proto.getProviderAtIndex(-1)).toThrowError('Index -1 is out-of-bounds.');
-        expect(() => proto.getProviderAtIndex(10)).toThrowError('Index 10 is out-of-bounds.');
-      });
-    });
-
-    describe('dynamic strategy', () => {
-      it("should allow for direct access using getProviderAtIndex", () => {
-        var proto = createPei(null, 0, dynamicProviders);
-
-        expect(proto.getProviderAtIndex(0)).toBeAnInstanceOf(DirectiveProvider);
-        expect(() => proto.getProviderAtIndex(-1)).toThrowError('Index -1 is out-of-bounds.');
-        expect(() => proto.getProviderAtIndex(dynamicProviders.length - 1)).not.toThrow();
-        expect(() => proto.getProviderAtIndex(dynamicProviders.length))
-            .toThrowError(`Index ${dynamicProviders.length} is out-of-bounds.`);
-      });
-    });
-
-    describe('event emitters', () => {
-      it('should return a list of event accessors', () => {
-        var provider = DirectiveProvider.createFromType(HasEventEmitter,
-                                                      new DirectiveMetadata({outputs: ['emitter']}));
-
-        var inj = createPei(null, 0, [provider]);
-        expect(inj.eventEmitterAccessors.length).toEqual(1);
-
-        var accessor = inj.eventEmitterAccessors[0][0];
-        expect(accessor.eventName).toEqual('emitter');
-        expect(accessor.getter(new HasEventEmitter())).toEqual('emitter');
-      });
-
-      it('should allow a different event vs field name', () => {
-        var provider = DirectiveProvider.createFromType(HasEventEmitter,
-            new DirectiveMetadata({outputs: ['emitter: publicEmitter']}));
-
-        var inj = createPei(null, 0, [provider]);
-        expect(inj.eventEmitterAccessors.length).toEqual(1);
-
-        var accessor = inj.eventEmitterAccessors[0][0];
-        expect(accessor.eventName).toEqual('publicEmitter');
-        expect(accessor.getter(new HasEventEmitter())).toEqual('emitter');
-      });
-    });
-
-    describe(".create", () => {
-      it("should collect providers from all directives", () => {
-        var pei = createPei(null, 0, [
-          DirectiveProvider.createFromType(
-              SimpleDirective,
-              new ComponentMetadata({providers: [provide('injectable1', {useValue: 'injectable1'})]})),
-          DirectiveProvider.createFromType(SomeOtherDirective, new ComponentMetadata({
-            providers: [provide('injectable2', {useValue: 'injectable2'})]
-          }))
-        ]);
-
-        expect(pei.getProviderAtIndex(0).key.token).toBe(SimpleDirective);
-        expect(pei.getProviderAtIndex(1).key.token).toBe(SomeOtherDirective);
-        expect(pei.getProviderAtIndex(2).key.token).toEqual("injectable1");
-        expect(pei.getProviderAtIndex(3).key.token).toEqual("injectable2");
-      });
-
-      it("should collect view providers from the component", () => {
-        var pei = createPei(null, 0,
-                            [DirectiveProvider.createFromType(SimpleDirective, new ComponentMetadata({
-                              viewProviders: [provide('injectable1', {useValue: 'injectable1'})]
-                            }))],
-                            0, true);
-
-        expect(pei.getProviderAtIndex(0).key.token).toBe(SimpleDirective);
-        expect(pei.getProviderAtIndex(1).key.token).toEqual("injectable1");
-      });
-
-      it("should flatten nested arrays", () => {
-        var pei = createPei(null, 0, [
-          DirectiveProvider.createFromType(
-              SimpleDirective,
-              new ComponentMetadata({
-                viewProviders: [[[provide('view', {useValue: 'view'})]]],
-                providers: [[[provide('host', {useValue: 'host'})]]]
-              }))
-        ], 0, true);
-
-        expect(pei.getProviderAtIndex(0).key.token).toBe(SimpleDirective);
-        expect(pei.getProviderAtIndex(1).key.token).toEqual("view");
-        expect(pei.getProviderAtIndex(2).key.token).toEqual("host");
-      });
-
-      it('should support an arbitrary number of providers', () => {
-        var pei = createPei(null, 0, dynamicProviders);
-
-        for (var i = 0; i < dynamicProviders.length; i++) {
-          expect(pei.getProviderAtIndex(i).key.token).toBe(i);
-        }
-      });
-    });
-  });
-
-  describe("ElementInjector", () => {
-    describe("instantiate", () => {
-      it("should create an element injector", () => {
-        var protoParent = createPei(null, 0, []);
-        var protoChild1 = createPei(protoParent, 1, []);
-        var protoChild2 = createPei(protoParent, 2, []);
-
-        var p = protoParent.instantiate(null);
-        var c1 = protoChild1.instantiate(p);
-        var c2 = protoChild2.instantiate(p);
-
-        expect(c1.parent).toEqual(p);
-        expect(c2.parent).toEqual(p);
-        expect(isBlank(p.parent)).toBeTruthy();
-      });
-
-      describe("direct parent", () => {
-        it("should return parent injector when distance is 1", () => {
-          var distance = 1;
-          var protoParent = createPei(null, 0, []);
-          var protoChild = createPei(protoParent, 1, [], distance);
-
-          var p = protoParent.instantiate(null);
-          var c = protoChild.instantiate(p);
-
-          expect(c.directParent()).toEqual(p);
-        });
-
-        it("should return null otherwise", () => {
-          var distance = 2;
-          var protoParent = createPei(null, 0, []);
-          var protoChild = createPei(protoParent, 1, [], distance);
-
-          var p = protoParent.instantiate(null);
-          var c = protoChild.instantiate(p);
-
-          expect(c.directParent()).toEqual(null);
-        });
-      });
-    });
-
-    describe("hasBindings", () => {
-      it("should be true when there are providers", () => {
-        var p = createPei(null, 0, [SimpleDirective]);
-        expect(p.hasBindings).toBeTruthy();
-      });
-
-      it("should be false otherwise", () => {
-        var p = createPei(null, 0, []);
-        expect(p.hasBindings).toBeFalsy();
-      });
-    });
-
-    describe("hasInstances", () => {
-      it("should be false when no directives are instantiated",
-         () => { expect(injector([]).hasInstances()).toBe(false); });
-
-      it("should be true when directives are instantiated",
-         () => { expect(injector([SimpleDirective]).hasInstances()).toBe(true); });
-    });
-
-    [{ strategy: 'inline', providers: [] }, { strategy: 'dynamic',
-      providers: dynamicProviders }].forEach((context) => {
-
-      var extraProviders = context['providers'];
-      describe(`${context['strategy']} strategy`, () => {
-
-        describe("hydrate", () => {
-          it("should instantiate directives that have no dependencies", () => {
-            var providers = ListWrapper.concat([SimpleDirective], extraProviders);
-            var inj = injector(providers);
-            expect(inj.get(SimpleDirective)).toBeAnInstanceOf(SimpleDirective);
-          });
-
-          it("should instantiate directives that depend on an arbitrary number of directives", () => {
-            var providers = ListWrapper.concat([SimpleDirective, NeedsDirective], extraProviders);
-            var inj = injector(providers);
-
-            var d = inj.get(NeedsDirective);
-
-            expect(d).toBeAnInstanceOf(NeedsDirective);
-            expect(d.dependency).toBeAnInstanceOf(SimpleDirective);
-          });
-
-          it("should instantiate providers that have dependencies with set visibility",
-             function() {
-               var childInj = parentChildInjectors(
-                   ListWrapper.concat(
-                       [DirectiveProvider.createFromType(SimpleDirective, new ComponentMetadata({
-                         providers: [provide('injectable1', {useValue: 'injectable1'})]
-                       }))],
-                       extraProviders),
-                   [DirectiveProvider.createFromType(SimpleDirective, new ComponentMetadata({
-                     providers: [
-                       provide('injectable1', {useValue:'new-injectable1'}),
-                       provide('injectable2', {useFactory:
-                               (val) => `${val}-injectable2`,
-                               deps: [[new InjectMetadata('injectable1'), new SkipSelfMetadata()]]})
-                     ]
-                   }))]);
-               expect(childInj.get('injectable2')).toEqual('injectable1-injectable2');
-             });
-
-          it("should instantiate providers that have dependencies", () => {
-            var providers = [
-                    provide('injectable1', {useValue: 'injectable1'}),
-                    provide('injectable2', {useFactory:
-                            (val) => `${val}-injectable2`,
-                            deps: ['injectable1']})
-                  ];
-
-            var inj = injector(ListWrapper.concat(
-                [DirectiveProvider.createFromType(SimpleDirective,
-                  new DirectiveMetadata({providers: providers}))],
-                extraProviders));
-
-            expect(inj.get('injectable2')).toEqual('injectable1-injectable2');
-          });
-
-          it("should instantiate viewProviders that have dependencies", () => {
-            var viewProviders = [
-                    provide('injectable1', {useValue: 'injectable1'}),
-                    provide('injectable2', {useFactory:
-                      (val) => `${val}-injectable2`,
-                            deps: ['injectable1']})
-                  ];
-
-
-            var inj = injector(ListWrapper.concat(
-                [DirectiveProvider.createFromType(SimpleDirective, new ComponentMetadata({
-                  viewProviders: viewProviders}))], extraProviders),
-                null, true);
-            expect(inj.get('injectable2')).toEqual('injectable1-injectable2');
-          });
-
-          it("should instantiate components that depend on viewProviders providers", () => {
-            var inj = injector(
-                ListWrapper.concat([DirectiveProvider.createFromType(NeedsService, new ComponentMetadata({
-                                     viewProviders: [provide('service', {useValue: 'service'})]
-                                   }))],
-                                   extraProviders),
-                null, true);
-            expect(inj.get(NeedsService).service).toEqual('service');
-          });
-
-          it("should instantiate providers lazily", () => {
-            var created = false;
-            var inj = injector(
-                ListWrapper.concat([DirectiveProvider.createFromType(SimpleDirective, new ComponentMetadata({
-                                     providers: [provide('service', {useFactory: () => created = true})]
-                                   }))],
-                                   extraProviders),
-                null, true);
-
-            expect(created).toBe(false);
-
-            inj.get('service');
-
-            expect(created).toBe(true);
-          });
-
-          it("should instantiate view providers lazily", () => {
-            var created = false;
-            var inj = injector(
-                ListWrapper.concat([DirectiveProvider.createFromType(SimpleDirective, new ComponentMetadata({
-                                     viewProviders: [provide('service', {useFactory: () => created = true})]
-                                   }))],
-                                   extraProviders),
-                null, true);
-
-            expect(created).toBe(false);
-
-            inj.get('service');
-
-            expect(created).toBe(true);
-          });
-
-          it("should not instantiate other directives that depend on viewProviders providers",
-             () => {
-               var directiveAnnotation = new ComponentMetadata({
-                 viewProviders: ListWrapper.concat([provide("service", {useValue: "service"})], extraProviders)
-               });
-               var componentDirective =
-                   DirectiveProvider.createFromType(SimpleDirective, directiveAnnotation);
-               expect(() => { injector([componentDirective, NeedsService], null); })
-                   .toThrowError(containsRegexp(
-                       `No provider for service! (${stringify(NeedsService) } -> service)`));
-             });
-
-          it("should instantiate directives that depend on providers of other directives", () => {
-            var shadowInj = hostShadowInjectors(
-                ListWrapper.concat([DirectiveProvider.createFromType(SimpleDirective, new ComponentMetadata({
-                      providers: [provide('service', {useValue: 'hostService'})]})
-                    )], extraProviders),
-                ListWrapper.concat([NeedsService], extraProviders)
-            );
-            expect(shadowInj.get(NeedsService).service).toEqual('hostService');
-          });
-
-          it("should instantiate directives that depend on imperatively created injector providers (bootstrap)", () => {
-            var imperativelyCreatedInjector = Injector.resolveAndCreate([
-            provide("service", {useValue: 'appService'})
-            ]);
-            var inj = injector([NeedsService], imperativelyCreatedInjector);
-            expect(inj.get(NeedsService).service).toEqual('appService');
-
-            expect(() => injector([NeedsServiceFromHost], imperativelyCreatedInjector)).toThrowError();
-          });
-
-          it("should instantiate directives that depend on imperatively created injector providers (root injector)", () => {
-            var imperativelyCreatedInjector = Injector.resolveAndCreate([
-            provide("service", {useValue: 'appService'})
-            ]);
-            var inj = hostShadowInjectors([SimpleDirective], [NeedsService, NeedsServiceFromHost], imperativelyCreatedInjector);
-            expect(inj.get(NeedsService).service).toEqual('appService');
-            expect(inj.get(NeedsServiceFromHost).service).toEqual('appService');
-          });
-
-          it("should instantiate directives that depend on imperatively created injector providers (child injector)", () => {
-            var imperativelyCreatedInjector = Injector.resolveAndCreate([
-            provide("service", {useValue: 'appService'})
-            ]);
-            var inj = parentChildInjectors([], [NeedsService, NeedsServiceFromHost], null, imperativelyCreatedInjector);
-            expect(inj.get(NeedsService).service).toEqual('appService');
-            expect(inj.get(NeedsServiceFromHost).service).toEqual('appService');
-          });
-
-          it("should prioritize viewProviders over providers for the same provider", () => {
-            var inj = injector(
-                ListWrapper.concat([DirectiveProvider.createFromType(NeedsService, new ComponentMetadata({
-                      providers: [provide('service', {useValue: 'hostService'})],
-                      viewProviders: [provide('service', {useValue: 'viewService'})]})
-                    )], extraProviders), null, true);
-            expect(inj.get(NeedsService).service).toEqual('viewService');
-          });
-
-          it("should prioritize directive providers over component providers", () => {
-            var component = DirectiveProvider.createFromType(NeedsService, new ComponentMetadata({
-                      providers: [provide('service', {useValue: 'compService'})]}));
-            var directive = DirectiveProvider.createFromType(SomeOtherDirective, new DirectiveMetadata({
-                      providers: [provide('service', {useValue: 'dirService'})]}));
-            var inj = injector(ListWrapper.concat([component, directive], extraProviders), null, true);
-            expect(inj.get(NeedsService).service).toEqual('dirService');
-          });
-
-          it("should not instantiate a directive in a view that has a host dependency on providers"+
-            " of the component", () => {
-            expect(() => {
-              hostShadowInjectors(
-                ListWrapper.concat([
-                  DirectiveProvider.createFromType(SomeOtherDirective, new DirectiveMetadata({
-                      providers: [provide('service', {useValue: 'hostService'})]})
-                  )], extraProviders),
-                ListWrapper.concat([NeedsServiceFromHost], extraProviders)
-              );
-            }).toThrowError(new RegExp("No provider for service!"));
-          });
-
-          it("should not instantiate a directive in a view that has a host dependency on providers"+
-            " of a decorator directive", () => {
-            expect(() => {
-              hostShadowInjectors(
-                ListWrapper.concat([
-                  SimpleDirective,
-                  DirectiveProvider.createFromType(SomeOtherDirective, new DirectiveMetadata({
-                      providers: [provide('service', {useValue: 'hostService'})]})
-                  )], extraProviders),
-
-                ListWrapper.concat([NeedsServiceFromHost], extraProviders)
-              );
-            }).toThrowError(new RegExp("No provider for service!"));
-          });
-
-          it("should instantiate directives that depend on pre built objects", () => {
-            var templateRef = new TemplateRef_(<any>new SpyElementRef());
-            var providers = ListWrapper.concat([NeedsTemplateRef], extraProviders);
-            var inj = injector(providers, null, false, new PreBuiltObjects(null, null, null, templateRef));
-
-            expect(inj.get(NeedsTemplateRef).templateRef).toEqual(templateRef);
-          });
-
-          it("should get directives", () => {
-            var child = hostShadowInjectors(
-                ListWrapper.concat([SomeOtherDirective, SimpleDirective], extraProviders),
-                [NeedsDirectiveFromHostShadowDom]);
-
-            var d = child.get(NeedsDirectiveFromHostShadowDom);
-
-            expect(d).toBeAnInstanceOf(NeedsDirectiveFromHostShadowDom);
-            expect(d.dependency).toBeAnInstanceOf(SimpleDirective);
-          });
-
-          it("should get directives from the host", () => {
-            var child = parentChildInjectors(ListWrapper.concat([SimpleDirective], extraProviders),
-                                             [NeeedsDirectiveFromHost]);
-
-            var d = child.get(NeeedsDirectiveFromHost);
-
-            expect(d).toBeAnInstanceOf(NeeedsDirectiveFromHost);
-            expect(d.dependency).toBeAnInstanceOf(SimpleDirective);
-          });
-
-          it("should throw when a dependency cannot be resolved", () => {
-            expect(() => injector(ListWrapper.concat([NeeedsDirectiveFromHost], extraProviders)))
-                .toThrowError(containsRegexp(
-                    `No provider for ${stringify(SimpleDirective) }! (${stringify(NeeedsDirectiveFromHost) } -> ${stringify(SimpleDirective) })`));
-          });
-
-          it("should inject null when an optional dependency cannot be resolved", () => {
-            var inj = injector(ListWrapper.concat([OptionallyNeedsDirective], extraProviders));
-            var d = inj.get(OptionallyNeedsDirective);
-            expect(d.dependency).toEqual(null);
-          });
-
-          it("should accept providers instead of types", () => {
-            var inj = injector(
-                ListWrapper.concat([provide(SimpleDirective, {useClass: SimpleDirective})], extraProviders));
-            expect(inj.get(SimpleDirective)).toBeAnInstanceOf(SimpleDirective);
-          });
-
-          it("should allow for direct access using getDirectiveAtIndex", () => {
-            var providers =
-                ListWrapper.concat([provide(SimpleDirective, {useClass: SimpleDirective})], extraProviders);
-
-            var inj = injector(providers);
-
-            var firsIndexOut = providers.length > 10 ? providers.length : 10;
-
-            expect(inj.getDirectiveAtIndex(0)).toBeAnInstanceOf(SimpleDirective);
-            expect(() => inj.getDirectiveAtIndex(-1)).toThrowError('Index -1 is out-of-bounds.');
-            expect(() => inj.getDirectiveAtIndex(firsIndexOut))
-                .toThrowError(`Index ${firsIndexOut} is out-of-bounds.`);
-          });
-
-          it("should instantiate directives that depend on the containing component", () => {
-            var directiveProvider =
-                DirectiveProvider.createFromType(SimpleDirective, new ComponentMetadata());
-            var shadow = hostShadowInjectors(ListWrapper.concat([directiveProvider], extraProviders),
-                                             [NeeedsDirectiveFromHost]);
-
-            var d = shadow.get(NeeedsDirectiveFromHost);
-            expect(d).toBeAnInstanceOf(NeeedsDirectiveFromHost);
-            expect(d.dependency).toBeAnInstanceOf(SimpleDirective);
-          });
-
-          it("should not instantiate directives that depend on other directives in the containing component's ElementInjector",
-             () => {
-               var directiveProvider =
-                   DirectiveProvider.createFromType(SomeOtherDirective, new ComponentMetadata());
-               expect(() =>
-                      {
-                        hostShadowInjectors(
-                            ListWrapper.concat([directiveProvider, SimpleDirective], extraProviders),
-                            [NeedsDirective]);
-                      })
-                   .toThrowError(containsRegexp(
-                       `No provider for ${stringify(SimpleDirective) }! (${stringify(NeedsDirective) } -> ${stringify(SimpleDirective) })`));
-             });
-        });
-
-        describe("getRootViewInjectors", () => {
-          it("should return an empty array if there is no nested view", () => {
-            var inj = injector(extraProviders);
-            expect(inj.getRootViewInjectors()).toEqual([]);
-          });
-
-          it("should return an empty array on a dehydrated view", () => {
-            var inj = injector(extraProviders);
-            inj.dehydrate();
-            expect(inj.getRootViewInjectors()).toEqual([]);
-          });
-        });
-
-        describe("dehydrate", () => {
-          function cycleHydrate(inj: ElementInjector, host=null): void {
-            // Each injection supports 3 query slots, so we cycle 4 times.
-            for (var i = 0; i < 4; i++) {
-              inj.dehydrate();
-              inj.hydrate(null, host, defaultPreBuiltObjects);
-            }
-          }
-
-          it("should handle repeated hydration / dehydration", () => {
-            var inj = injector(extraProviders);
-            cycleHydrate(inj);
-          });
-
-          it("should handle repeated hydration / dehydration with query present", () => {
-            var inj = injector(ListWrapper.concat([NeedsQuery], extraProviders));
-            cycleHydrate(inj);
-          });
-
-
-          it("should handle repeated hydration / dehydration with view query present", () => {
-            var inj = injector(extraProviders);
-            var host = injector(ListWrapper.concat([NeedsViewQuery], extraProviders));
-
-            cycleHydrate(inj, host);
-          });
-        });
-
-        describe("lifecycle", () => {
-          it("should call ngOnDestroy on directives subscribed to this event", () => {
-            var inj = injector(ListWrapper.concat(
-                [DirectiveProvider.createFromType(DirectiveWithDestroy,
-                                                 new DirectiveMetadata())],
-                extraProviders));
-            var destroy = inj.get(DirectiveWithDestroy);
-            inj.dehydrate();
-            expect(destroy.ngOnDestroyCounter).toBe(1);
-          });
-
-          it("should work with services", () => {
-            var inj = injector(ListWrapper.concat(
-                [DirectiveProvider.createFromType(
-                    SimpleDirective, new DirectiveMetadata({providers: [SimpleService]}))],
-                extraProviders));
-            inj.dehydrate();
-          });
-        });
-
-        describe('static attributes', () => {
-          it('should be injectable', () => {
-            var attributes = new Map();
-            attributes.set( 'type', 'text');
-            attributes.set( 'title', '');
-
-            var inj = injector(ListWrapper.concat([NeedsAttribute], extraProviders), null, false, null,
-                               attributes);
-            var needsAttribute = inj.get(NeedsAttribute);
-
-            expect(needsAttribute.typeAttribute).toEqual('text');
-            expect(needsAttribute.titleAttribute).toEqual('');
-            expect(needsAttribute.fooAttribute).toEqual(null);
-          });
-
-          it('should be injectable without type annotation', () => {
-            var attributes = new Map();
-            attributes.set( 'foo', 'bar');
-
-            var inj = injector(ListWrapper.concat([NeedsAttributeNoType], extraProviders), null, false,
-                               null, attributes);
-            var needsAttribute = inj.get(NeedsAttributeNoType);
-
-            expect(needsAttribute.fooAttribute).toEqual('bar');
-          });
-        });
-
-        describe("refs", () => {
-          it("should inject ElementRef", () => {
-            var inj = injector(ListWrapper.concat([NeedsElementRef], extraProviders));
-            expect(inj.get(NeedsElementRef).elementRef).toBe(defaultPreBuiltObjects.elementRef);
-          });
-
-          it("should inject ChangeDetectorRef of the component's view into the component", () => {
-            var cd = new DynamicChangeDetector(null, null, 0, [], [], null, [], [], [], null);
-            var view = <any>createDummyView();
-            var childView = createDummyView(cd);
-            view.spy('getNestedView').andReturn(childView);
-            var provider = DirectiveProvider.createFromType(ComponentNeedsChangeDetectorRef, new ComponentMetadata());
-            var inj = injector(ListWrapper.concat([provider], extraProviders), null, true,
-                               new PreBuiltObjects(null, view, <any>new SpyElementRef(), null));
-
-            expect(inj.get(ComponentNeedsChangeDetectorRef).changeDetectorRef).toBe(cd.ref);
-          });
-
-          it("should inject ChangeDetectorRef of the containing component into directives", () => {
-            var cd = new DynamicChangeDetector(null, null, 0, [], [], null, [], [], [], null);
-            var view = createDummyView(cd);
-            var provider = DirectiveProvider.createFromType(DirectiveNeedsChangeDetectorRef, new DirectiveMetadata());
-            var inj = injector(ListWrapper.concat([provider], extraProviders), null, false,
-                               new PreBuiltObjects(null, view, <any>new SpyElementRef(), null));
-
-            expect(inj.get(DirectiveNeedsChangeDetectorRef).changeDetectorRef).toBe(cd.ref);
-          });
-
-          it('should inject ViewContainerRef', () => {
-            var inj = injector(ListWrapper.concat([NeedsViewContainer], extraProviders));
-            expect(inj.get(NeedsViewContainer).viewContainer).toBeAnInstanceOf(ViewContainerRef_);
-          });
-
-          it("should inject TemplateRef", () => {
-            var templateRef = new TemplateRef_(<any>new SpyElementRef());
-            var inj = injector(ListWrapper.concat([NeedsTemplateRef], extraProviders), null, false,
-                               new PreBuiltObjects(null, null, null, templateRef));
-
-            expect(inj.get(NeedsTemplateRef).templateRef).toEqual(templateRef);
-          });
-
-          it("should throw if there is no TemplateRef", () => {
-            expect(() => injector(ListWrapper.concat([NeedsTemplateRef], extraProviders)))
-                .toThrowError(
-                    `No provider for TemplateRef! (${stringify(NeedsTemplateRef) } -> TemplateRef)`);
-          });
-
-          it('should inject null if there is no TemplateRef when the dependency is optional', () => {
-            var inj = injector(ListWrapper.concat([OptionallyInjectsTemplateRef], extraProviders));
-            var instance = inj.get(OptionallyInjectsTemplateRef);
-            expect(instance.templateRef).toBeNull();
-          });
-        });
-
-        describe('queries', () => {
-          var dummyView;
-          var preBuildObjects;
-
-          beforeEach(() => { _constructionCount = 0;
-            dummyView = createDummyView();
-            preBuildObjects = new PreBuiltObjects(null, dummyView, <any>new SpyElementRef(), null);
-          });
-
-          function expectDirectives(query: QueryList<any>, type, expectedIndex) {
-            var currentCount = 0;
-            expect(query.length).toEqual(expectedIndex.length);
-            iterateListLike(query, (i) => {
-              expect(i).toBeAnInstanceOf(type);
-              expect(i.count).toBe(expectedIndex[currentCount]);
-              currentCount += 1;
-            });
-          }
-
-          it('should be injectable', () => {
-            var inj =
-                injector(ListWrapper.concat([NeedsQuery], extraProviders), null, false, preBuildObjects);
-            expect(inj.get(NeedsQuery).query).toBeAnInstanceOf(QueryList);
-          });
-
-          it('should contain directives on the same injector', () => {
-            var inj = injector(ListWrapper.concat([
-                NeedsQuery,
-                CountingDirective
-              ], extraProviders), null,
-              false, preBuildObjects);
-
-            addInj(dummyView, inj);
-            inj.ngAfterContentChecked();
-
-            expectDirectives(inj.get(NeedsQuery).query, CountingDirective, [0]);
-          });
-
-          it('should contain PreBuiltObjects on the same injector', () => {
-            var preBuiltObjects = new PreBuiltObjects(null, dummyView, null, new TemplateRef_(<any>new SpyElementRef()));
-            var inj = injector(ListWrapper.concat([
-                NeedsTemplateRefQuery
-              ], extraProviders), null,
-              false, preBuiltObjects);
-            addInj(dummyView, inj);
-
-            inj.ngAfterContentChecked();
-
-            expect(inj.get(NeedsTemplateRefQuery).query.first).toBe(preBuiltObjects.templateRef);
-          });
-
-          it('should contain the element when no directives are bound to the var provider', () => {
-            var dirs = [NeedsQueryByVarBindings];
-
-            var dirVariableBindings = MapWrapper.createFromStringMap({
-              "one": null // element
-            });
-
-            var inj = injector(dirs.concat(extraProviders), null,
-                               false, preBuildObjects, null, dirVariableBindings);
-
-            addInj(dummyView, inj);
-            inj.ngAfterContentChecked();
-
-            expect(inj.get(NeedsQueryByVarBindings).query.first).toBe(preBuildObjects.elementRef);
-          });
-
-          it('should contain directives on the same injector when querying by variable providers' +
-            'in the order of var providers specified in the query', () => {
-            var dirs = [NeedsQueryByVarBindings, NeedsDirective, SimpleDirective];
-
-            var dirVariableBindings = MapWrapper.createFromStringMap({
-              "one": 2, // 2 is the index of SimpleDirective
-              "two": 1 // 1 is the index of NeedsDirective
-            });
-
-            var inj = injector(dirs.concat(extraProviders), null,
-                               false, preBuildObjects, null, dirVariableBindings);
-
-            addInj(dummyView, inj);
-            inj.ngAfterContentChecked();
-
-            // NeedsQueryByVarBindings queries "one,two", so SimpleDirective should be before NeedsDirective
-            expect(inj.get(NeedsQueryByVarBindings).query.first).toBeAnInstanceOf(SimpleDirective);
-            expect(inj.get(NeedsQueryByVarBindings).query.last).toBeAnInstanceOf(NeedsDirective);
-          });
-
-          it('should contain directives on the same and a child injector in construction order', () => {
-            var protoParent = createPei(null, 0, [NeedsQuery, CountingDirective]);
-            var protoChild =
-                createPei(protoParent, 1, ListWrapper.concat([CountingDirective], extraProviders));
-
-            var parent = protoParent.instantiate(null);
-            var child = protoChild.instantiate(parent);
-            parent.hydrate(null, null, preBuildObjects);
-            child.hydrate(null, null, preBuildObjects);
-
-            addInj(dummyView, parent);
-            addInj(dummyView, child);
-            parent.ngAfterContentChecked();
-
-            expectDirectives(parent.get(NeedsQuery).query, CountingDirective, [0, 1]);
-          });
-        });
-      });
-    });
-  });
-}
-
-class ContextWithHandler {
-  handler;
-  constructor(handler) { this.handler = handler; }
-}
diff --git a/modules/angular2/test/core/linker/element_spec.ts b/modules/angular2/test/core/linker/element_spec.ts
new file mode 100644
index 0000000..7265b3c
--- /dev/null
+++ b/modules/angular2/test/core/linker/element_spec.ts
@@ -0,0 +1,843 @@
+// TODO(tbosch): clang-format screws this up, see https://github.com/angular/clang-format/issues/11.
+// Enable clang-format here again when this is fixed.
+// clang-format off
+import {
+  describe,
+  ddescribe,
+  it,
+  iit,
+  xit,
+  xdescribe,
+  expect,
+  beforeEach,
+  beforeEachBindings,
+  inject,
+  AsyncTestCompleter,
+  el,
+  containsRegexp
+} from 'angular2/testing_internal';
+import {SpyView, SpyElementRef, SpyDirectiveResolver, SpyProtoView, SpyChangeDetector, SpyAppViewManager} from '../spies';
+import {isBlank, isPresent, stringify, Type} from 'angular2/src/facade/lang';
+import {ResolvedProvider} from 'angular2/src/core/di';
+import {
+  ListWrapper,
+  MapWrapper,
+  StringMapWrapper,
+  iterateListLike
+} from 'angular2/src/facade/collection';
+import {
+  AppProtoElement,
+  AppElement,
+  DirectiveProvider
+} from 'angular2/src/core/linker/element';
+import {ResolvedMetadataCache} from 'angular2/src/core/linker/resolved_metadata_cache';
+import {DirectiveResolver} from 'angular2/src/core/linker/directive_resolver';
+import {
+  Attribute,
+  Query,
+  ViewQuery,
+  ComponentMetadata,
+  DirectiveMetadata,
+  ViewEncapsulation
+} from 'angular2/src/core/metadata';
+import {OnDestroy, Directive} from 'angular2/core';
+import {provide, Injector, Provider, Optional, Inject, Injectable, Self, SkipSelf, InjectMetadata, Host, HostMetadata, SkipSelfMetadata} from 'angular2/core';
+import {ViewContainerRef, ViewContainerRef_} from 'angular2/src/core/linker/view_container_ref';
+import {TemplateRef, TemplateRef_} from 'angular2/src/core/linker/template_ref';
+import {ElementRef} from 'angular2/src/core/linker/element_ref';
+import {DynamicChangeDetector, ChangeDetectorRef, Parser, Lexer} from 'angular2/src/core/change_detection/change_detection';
+import {ChangeDetectorRef_} from 'angular2/src/core/change_detection/change_detector_ref';
+import {QueryList} from 'angular2/src/core/linker/query_list';
+import {AppView, AppProtoView} from "angular2/src/core/linker/view";
+import {ViewType} from "angular2/src/core/linker/view_type";
+
+@Directive({selector: ''})
+class SimpleDirective {}
+
+class SimpleService {}
+
+@Directive({selector: ''})
+class SomeOtherDirective {}
+
+var _constructionCount;
+@Directive({selector: ''})
+class CountingDirective {
+  count: number;
+  constructor() {
+    this.count = _constructionCount;
+    _constructionCount += 1;
+  }
+}
+
+@Directive({selector: ''})
+class FancyCountingDirective extends CountingDirective {
+  constructor() { super(); }
+}
+
+@Directive({selector: ''})
+class NeedsDirective {
+  dependency: SimpleDirective;
+  constructor(@Self() dependency: SimpleDirective) { this.dependency = dependency; }
+}
+
+@Directive({selector: ''})
+class OptionallyNeedsDirective {
+  dependency: SimpleDirective;
+  constructor(@Self() @Optional() dependency: SimpleDirective) { this.dependency = dependency; }
+}
+
+@Directive({selector: ''})
+class NeeedsDirectiveFromHost {
+  dependency: SimpleDirective;
+  constructor(@Host() dependency: SimpleDirective) { this.dependency = dependency; }
+}
+
+@Directive({selector: ''})
+class NeedsDirectiveFromHostShadowDom {
+  dependency: SimpleDirective;
+  constructor(dependency: SimpleDirective) { this.dependency = dependency; }
+}
+
+@Directive({selector: ''})
+class NeedsService {
+  service: any;
+  constructor(@Inject("service") service) { this.service = service; }
+}
+
+@Directive({selector: ''})
+class NeedsServiceFromHost {
+  service: any;
+  constructor(@Host() @Inject("service") service) { this.service = service; }
+}
+
+class HasEventEmitter {
+  emitter;
+  constructor() { this.emitter = "emitter"; }
+}
+
+@Directive({selector: ''})
+class NeedsAttribute {
+  typeAttribute;
+  titleAttribute;
+  fooAttribute;
+  constructor(@Attribute('type') typeAttribute: String, @Attribute('title') titleAttribute: String,
+              @Attribute('foo') fooAttribute: String) {
+    this.typeAttribute = typeAttribute;
+    this.titleAttribute = titleAttribute;
+    this.fooAttribute = fooAttribute;
+  }
+}
+
+@Directive({selector: ''})
+class NeedsAttributeNoType {
+  fooAttribute;
+  constructor(@Attribute('foo') fooAttribute) { this.fooAttribute = fooAttribute; }
+}
+
+@Directive({selector: ''})
+class NeedsQuery {
+  query: QueryList<CountingDirective>;
+  constructor(@Query(CountingDirective) query: QueryList<CountingDirective>) { this.query = query; }
+}
+
+@Directive({selector: ''})
+class NeedsViewQuery {
+  query: QueryList<CountingDirective>;
+  constructor(@ViewQuery(CountingDirective) query: QueryList<CountingDirective>) { this.query = query; }
+}
+
+@Directive({selector: ''})
+class NeedsQueryByVarBindings {
+  query: QueryList<any>;
+  constructor(@Query("one,two") query: QueryList<any>) { this.query = query; }
+}
+
+@Directive({selector: ''})
+class NeedsTemplateRefQuery {
+  query: QueryList<TemplateRef>;
+  constructor(@Query(TemplateRef) query: QueryList<TemplateRef>) { this.query = query; }
+}
+
+@Directive({selector: ''})
+class NeedsElementRef {
+  elementRef;
+  constructor(ref: ElementRef) { this.elementRef = ref; }
+}
+
+@Directive({selector: ''})
+class NeedsViewContainer {
+  viewContainer;
+  constructor(vc: ViewContainerRef) { this.viewContainer = vc; }
+}
+
+@Directive({selector: ''})
+class NeedsTemplateRef {
+  templateRef;
+  constructor(ref: TemplateRef) { this.templateRef = ref; }
+}
+
+@Directive({selector: ''})
+class OptionallyInjectsTemplateRef {
+  templateRef;
+  constructor(@Optional() ref: TemplateRef) { this.templateRef = ref; }
+}
+
+@Directive({selector: ''})
+class DirectiveNeedsChangeDetectorRef {
+  constructor(public changeDetectorRef: ChangeDetectorRef) {}
+}
+
+@Directive({selector: ''})
+class ComponentNeedsChangeDetectorRef {
+  constructor(public changeDetectorRef: ChangeDetectorRef) {}
+}
+
+@Injectable()
+class PipeNeedsChangeDetectorRef {
+  constructor(public changeDetectorRef: ChangeDetectorRef) {}
+}
+
+class A_Needs_B {
+  constructor(dep) {}
+}
+
+class B_Needs_A {
+  constructor(dep) {}
+}
+
+class DirectiveWithDestroy implements OnDestroy {
+  ngOnDestroyCounter: number;
+
+  constructor() { this.ngOnDestroyCounter = 0; }
+
+  ngOnDestroy() { this.ngOnDestroyCounter++; }
+}
+
+@Directive({selector: ''})
+class D0 {}
+@Directive({selector: ''})
+class D1 {}
+@Directive({selector: ''})
+class D2 {}
+@Directive({selector: ''})
+class D3 {}
+@Directive({selector: ''})
+class D4 {}
+@Directive({selector: ''})
+class D5 {}
+@Directive({selector: ''})
+class D6 {}
+@Directive({selector: ''})
+class D7 {}
+@Directive({selector: ''})
+class D8 {}
+@Directive({selector: ''})
+class D9 {}
+@Directive({selector: ''})
+class D10 {}
+@Directive({selector: ''})
+class D11 {}
+@Directive({selector: ''})
+class D12 {}
+@Directive({selector: ''})
+class D13 {}
+@Directive({selector: ''})
+class D14 {}
+@Directive({selector: ''})
+class D15 {}
+@Directive({selector: ''})
+class D16 {}
+@Directive({selector: ''})
+class D17 {}
+@Directive({selector: ''})
+class D18 {}
+@Directive({selector: ''})
+class D19 {}
+
+export function main() {
+  // An injector with more than 10 providers will switch to the dynamic strategy
+  var dynamicStrategyDirectives = [D0, D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, D11, D12, D13, D14, D15, D16, D17, D18, D19];
+  var resolvedMetadataCache:ResolvedMetadataCache;
+  var mockDirectiveMeta:Map<Type, DirectiveMetadata>;
+  var directiveResolver:SpyDirectiveResolver;
+  var dummyView:AppView;
+  var dummyViewFactory:Function;
+
+  function createView(type: ViewType, containerAppElement:AppElement = null, imperativelyCreatedProviders: ResolvedProvider[] = null, rootInjector: Injector = null, pipes: Type[] = null):AppView {
+    if (isBlank(pipes)) {
+      pipes = [];
+    }
+    var proto = AppProtoView.create(resolvedMetadataCache, type, pipes, {});
+    var cd = new SpyChangeDetector();
+    cd.prop('ref', new ChangeDetectorRef_(<any>cd));
+
+    var view = new AppView(proto, null, <any>new SpyAppViewManager(), [], containerAppElement, imperativelyCreatedProviders, rootInjector, <any> cd);
+    view.init([], [], [], []);
+    return view;
+  }
+
+  function protoAppElement(index, directives: Type[], attributes: {[key:string]:string} = null, dirVariableBindings:{[key:string]:number} = null) {
+    return AppProtoElement.create(resolvedMetadataCache, index, attributes, directives, dirVariableBindings);
+  }
+
+  function appElement(parent: AppElement, directives: Type[],
+                    view: AppView = null, embeddedViewFactory: Function = null, attributes: {[key:string]:string} = null, dirVariableBindings:{[key:string]:number} = null) {
+    if (isBlank(view)) {
+      view = dummyView;
+    }
+    var proto = protoAppElement(0, directives, attributes, dirVariableBindings);
+    var el = new AppElement(proto, view, parent, null, embeddedViewFactory);
+    view.appElements.push(el);
+    return el;
+  }
+
+  function parentChildElements(parentDirectives: Type[], childDirectives:Type[], view: AppView = null) {
+    if (isBlank(view)) {
+      view = dummyView;
+    }
+    var parent = appElement(null, parentDirectives, view);
+    var child = appElement(parent, childDirectives, view);
+
+    return child;
+  }
+
+  function hostShadowElement(hostDirectives: Type[],
+                               viewDirectives: Type[]): AppElement {
+    var host = appElement(null, hostDirectives);
+    var view = createView(ViewType.COMPONENT, host);
+    host.attachComponentView(view);
+
+    return appElement(null, viewDirectives, view);
+  }
+
+  function init() {
+    beforeEachBindings(() => {
+      var delegateDirectiveResolver = new DirectiveResolver();
+      directiveResolver = new SpyDirectiveResolver();
+      directiveResolver.spy('resolve').andCallFake( (directiveType) => {
+        var result = mockDirectiveMeta.get(directiveType);
+        if (isBlank(result)) {
+          result = delegateDirectiveResolver.resolve(directiveType);
+        }
+        return result;
+      });
+      return [
+        provide(DirectiveResolver, {useValue: directiveResolver})
+      ];
+    });
+    beforeEach(inject([ResolvedMetadataCache], (_metadataCache) => {
+      mockDirectiveMeta = new Map<Type, DirectiveMetadata>();
+      resolvedMetadataCache = _metadataCache;
+      dummyView = createView(ViewType.HOST);
+      dummyViewFactory = () => {};
+      _constructionCount = 0;
+    }));
+  }
+
+  describe("ProtoAppElement", () => {
+    init();
+
+    describe('inline strategy', () => {
+      it("should allow for direct access using getProviderAtIndex", () => {
+        var proto = protoAppElement(0, [SimpleDirective]);
+
+        expect(proto.getProviderAtIndex(0)).toBeAnInstanceOf(DirectiveProvider);
+        expect(() => proto.getProviderAtIndex(-1)).toThrowError('Index -1 is out-of-bounds.');
+        expect(() => proto.getProviderAtIndex(10)).toThrowError('Index 10 is out-of-bounds.');
+      });
+    });
+
+    describe('dynamic strategy', () => {
+      it("should allow for direct access using getProviderAtIndex", () => {
+        var proto = protoAppElement(0, dynamicStrategyDirectives);
+
+        expect(proto.getProviderAtIndex(0)).toBeAnInstanceOf(DirectiveProvider);
+        expect(() => proto.getProviderAtIndex(-1)).toThrowError('Index -1 is out-of-bounds.');
+        expect(() => proto.getProviderAtIndex(dynamicStrategyDirectives.length - 1)).not.toThrow();
+        expect(() => proto.getProviderAtIndex(dynamicStrategyDirectives.length))
+            .toThrowError(`Index ${dynamicStrategyDirectives.length} is out-of-bounds.`);
+      });
+    });
+
+    describe(".create", () => {
+      it("should collect providers from all directives", () => {
+        mockDirectiveMeta.set(SimpleDirective, new DirectiveMetadata({providers: [provide('injectable1', {useValue: 'injectable1'})]}));
+        mockDirectiveMeta.set(SomeOtherDirective, new DirectiveMetadata({
+            providers: [provide('injectable2', {useValue: 'injectable2'})]
+          }));
+        var pel = protoAppElement( 0, [
+          SimpleDirective,
+          SomeOtherDirective
+        ]);
+
+        expect(pel.getProviderAtIndex(0).key.token).toBe(SimpleDirective);
+        expect(pel.getProviderAtIndex(1).key.token).toBe(SomeOtherDirective);
+        expect(pel.getProviderAtIndex(2).key.token).toEqual("injectable1");
+        expect(pel.getProviderAtIndex(3).key.token).toEqual("injectable2");
+      });
+
+      it("should collect view providers from the component", () => {
+        mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata({
+                              viewProviders: [provide('injectable1', {useValue: 'injectable1'})]
+                            }));
+        var pel = protoAppElement(0, [SimpleDirective]);
+
+        expect(pel.getProviderAtIndex(0).key.token).toBe(SimpleDirective);
+        expect(pel.getProviderAtIndex(1).key.token).toEqual("injectable1");
+      });
+
+      it("should flatten nested arrays in viewProviders and providers", () => {
+        mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata({
+                viewProviders: [[[provide('view', {useValue: 'view'})]]],
+                providers: [[[provide('host', {useValue: 'host'})]]]
+              }));
+        var pel = protoAppElement(0, [SimpleDirective]);
+
+        expect(pel.getProviderAtIndex(0).key.token).toBe(SimpleDirective);
+        expect(pel.getProviderAtIndex(1).key.token).toEqual("view");
+        expect(pel.getProviderAtIndex(2).key.token).toEqual("host");
+      });
+
+      it('should support an arbitrary number of providers', () => {
+        var pel = protoAppElement(0, dynamicStrategyDirectives);
+        expect(pel.getProviderAtIndex(0).key.token).toBe(D0);
+        expect(pel.getProviderAtIndex(19).key.token).toBe(D19);
+      });
+    });
+  });
+
+  describe("AppElement", () => {
+    init();
+
+    [{ strategy: 'inline', directives: [] }, { strategy: 'dynamic',
+      directives: dynamicStrategyDirectives }].forEach((context) => {
+
+      var extraDirectives = context['directives'];
+      describe(`${context['strategy']} strategy`, () => {
+
+        describe("injection", () => {
+          it("should instantiate directives that have no dependencies", () => {
+            var directives = ListWrapper.concat([SimpleDirective], extraDirectives);
+            var el = appElement(null, directives);
+            expect(el.get(SimpleDirective)).toBeAnInstanceOf(SimpleDirective);
+          });
+
+          it("should instantiate directives that depend on an arbitrary number of directives", () => {
+            var directives = ListWrapper.concat([SimpleDirective, NeedsDirective], extraDirectives);
+            var el = appElement(null, directives);
+
+            var d = el.get(NeedsDirective);
+
+            expect(d).toBeAnInstanceOf(NeedsDirective);
+            expect(d.dependency).toBeAnInstanceOf(SimpleDirective);
+          });
+
+          it("should instantiate providers that have dependencies with set visibility",
+             function() {
+               mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata({
+                  providers: [provide('injectable1', {useValue: 'injectable1'})]
+                }));
+               mockDirectiveMeta.set(SomeOtherDirective, new ComponentMetadata({
+                  providers: [
+                    provide('injectable1', {useValue:'new-injectable1'}),
+                    provide('injectable2', {useFactory:
+                               (val) => `${val}-injectable2`,
+                               deps: [[new InjectMetadata('injectable1'), new SkipSelfMetadata()]]})
+                  ]
+                }));
+               var childInj = parentChildElements(
+                   ListWrapper.concat([SimpleDirective], extraDirectives),
+                   [SomeOtherDirective]
+               );
+               expect(childInj.get('injectable2')).toEqual('injectable1-injectable2');
+             });
+
+          it("should instantiate providers that have dependencies", () => {
+            var providers = [
+                    provide('injectable1', {useValue: 'injectable1'}),
+                    provide('injectable2', {useFactory:
+                            (val) => `${val}-injectable2`,
+                            deps: ['injectable1']})
+                  ];
+            mockDirectiveMeta.set(SimpleDirective, new DirectiveMetadata({providers: providers}));
+            var el = appElement(null, ListWrapper.concat(
+                [SimpleDirective], extraDirectives));
+
+            expect(el.get('injectable2')).toEqual('injectable1-injectable2');
+          });
+
+          it("should instantiate viewProviders that have dependencies", () => {
+            var viewProviders = [
+                    provide('injectable1', {useValue: 'injectable1'}),
+                    provide('injectable2', {useFactory:
+                      (val) => `${val}-injectable2`,
+                            deps: ['injectable1']})
+                  ];
+
+            mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata({
+                  viewProviders: viewProviders}));
+            var el = appElement(null, ListWrapper.concat(
+                [SimpleDirective], extraDirectives));
+            expect(el.get('injectable2')).toEqual('injectable1-injectable2');
+          });
+
+          it("should instantiate components that depend on viewProviders providers", () => {
+            mockDirectiveMeta.set(NeedsService, new ComponentMetadata({
+              viewProviders: [provide('service', {useValue: 'service'})]
+            }));
+            var el = appElement(null,
+                ListWrapper.concat([NeedsService], extraDirectives));
+            expect(el.get(NeedsService).service).toEqual('service');
+          });
+
+          it("should instantiate providers lazily", () => {
+            var created = false;
+            mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata({
+              providers: [provide('service', {useFactory: () => created = true})]
+            }));
+            var el = appElement(null,
+                ListWrapper.concat([SimpleDirective],
+                                   extraDirectives));
+
+            expect(created).toBe(false);
+
+            el.get('service');
+
+            expect(created).toBe(true);
+          });
+
+          it("should instantiate view providers lazily", () => {
+            var created = false;
+            mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata({
+                                     viewProviders: [provide('service', {useFactory: () => created = true})]
+                                   }));
+            var el = appElement(null,
+                ListWrapper.concat([SimpleDirective],
+                                   extraDirectives));
+
+            expect(created).toBe(false);
+
+            el.get('service');
+
+            expect(created).toBe(true);
+          });
+
+          it("should not instantiate other directives that depend on viewProviders providers",
+             () => {
+               mockDirectiveMeta.set(SimpleDirective,
+               new ComponentMetadata({
+                 viewProviders: [provide("service", {useValue: "service"})]
+               }));
+               expect(() => { appElement(null, ListWrapper.concat([SimpleDirective, NeedsService], extraDirectives)); })
+                   .toThrowError(containsRegexp(
+                       `No provider for service! (${stringify(NeedsService) } -> service)`));
+             });
+
+          it("should instantiate directives that depend on providers of other directives", () => {
+            mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata({
+                      providers: [provide('service', {useValue: 'hostService'})]})
+                    );
+            var shadowInj = hostShadowElement(
+                ListWrapper.concat([SimpleDirective], extraDirectives),
+                ListWrapper.concat([NeedsService], extraDirectives)
+            );
+            expect(shadowInj.get(NeedsService).service).toEqual('hostService');
+          });
+
+          it("should instantiate directives that depend on view providers of a component", () => {
+            mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata({
+                      viewProviders: [provide('service', {useValue: 'hostService'})]})
+                    );
+            var shadowInj = hostShadowElement(
+                ListWrapper.concat([SimpleDirective], extraDirectives),
+                ListWrapper.concat([NeedsService], extraDirectives)
+            );
+            expect(shadowInj.get(NeedsService).service).toEqual('hostService');
+          });
+
+          it("should instantiate directives in a root embedded view that depend on view providers of a component", () => {
+            mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata({
+                      viewProviders: [provide('service', {useValue: 'hostService'})]})
+                    );
+            var host = appElement(null, ListWrapper.concat([SimpleDirective], extraDirectives));
+            var componenetView = createView(ViewType.COMPONENT, host);
+            host.attachComponentView(componenetView);
+
+            var anchor = appElement(null, [], componenetView);
+            var embeddedView = createView(ViewType.EMBEDDED, anchor);
+
+            var rootEmbeddedEl = appElement(null, ListWrapper.concat([NeedsService], extraDirectives), embeddedView);
+            expect(rootEmbeddedEl.get(NeedsService).service).toEqual('hostService');
+          });
+
+          it("should instantiate directives that depend on imperatively created injector (bootstrap)", () => {
+            var rootInjector = Injector.resolveAndCreate([
+              provide("service", {useValue: 'appService'})
+            ]);
+            var view = createView(ViewType.HOST, null, null, rootInjector);
+            expect(appElement(null, [NeedsService], view).get(NeedsService).service).toEqual('appService');
+
+            expect(() => appElement(null, [NeedsServiceFromHost], view)).toThrowError();
+          });
+
+          it("should instantiate directives that depend on imperatively created providers (root injector)", () => {
+            var imperativelyCreatedProviders = Injector.resolve([
+              provide("service", {useValue: 'appService'})
+            ]);
+            var containerAppElement = appElement(null, []);
+            var view = createView(ViewType.HOST, containerAppElement, imperativelyCreatedProviders, null);
+            expect(appElement(null, [NeedsService], view).get(NeedsService).service).toEqual('appService');
+            expect(appElement(null, [NeedsServiceFromHost], view).get(NeedsServiceFromHost).service).toEqual('appService');
+          });
+
+          it("should not instantiate a directive in a view that has a host dependency on providers"+
+            " of the component", () => {
+            mockDirectiveMeta.set(SomeOtherDirective, new DirectiveMetadata({
+                    providers: [provide('service', {useValue: 'hostService'})]})
+                );
+            expect(() => {
+              hostShadowElement(
+                ListWrapper.concat([SomeOtherDirective], extraDirectives),
+                ListWrapper.concat([NeedsServiceFromHost], extraDirectives)
+              );
+            }).toThrowError(new RegExp("No provider for service!"));
+          });
+
+          it("should not instantiate a directive in a view that has a host dependency on providers"+
+            " of a decorator directive", () => {
+            mockDirectiveMeta.set(SomeOtherDirective, new DirectiveMetadata({
+                      providers: [provide('service', {useValue: 'hostService'})]}));
+            expect(() => {
+              hostShadowElement(
+                ListWrapper.concat([SimpleDirective, SomeOtherDirective], extraDirectives),
+                ListWrapper.concat([NeedsServiceFromHost], extraDirectives)
+              );
+            }).toThrowError(new RegExp("No provider for service!"));
+          });
+
+          it("should get directives", () => {
+            var child = hostShadowElement(
+                ListWrapper.concat([SomeOtherDirective, SimpleDirective], extraDirectives),
+                [NeedsDirectiveFromHostShadowDom]);
+
+            var d = child.get(NeedsDirectiveFromHostShadowDom);
+
+            expect(d).toBeAnInstanceOf(NeedsDirectiveFromHostShadowDom);
+            expect(d.dependency).toBeAnInstanceOf(SimpleDirective);
+          });
+
+          it("should get directives from the host", () => {
+            var child = parentChildElements(ListWrapper.concat([SimpleDirective], extraDirectives),
+                                             [NeeedsDirectiveFromHost]);
+
+            var d = child.get(NeeedsDirectiveFromHost);
+
+            expect(d).toBeAnInstanceOf(NeeedsDirectiveFromHost);
+            expect(d.dependency).toBeAnInstanceOf(SimpleDirective);
+          });
+
+          it("should throw when a dependency cannot be resolved", () => {
+            expect(() => appElement(null, ListWrapper.concat([NeeedsDirectiveFromHost], extraDirectives)))
+                .toThrowError(containsRegexp(
+                    `No provider for ${stringify(SimpleDirective) }! (${stringify(NeeedsDirectiveFromHost) } -> ${stringify(SimpleDirective) })`));
+          });
+
+          it("should inject null when an optional dependency cannot be resolved", () => {
+            var el = appElement(null, ListWrapper.concat([OptionallyNeedsDirective], extraDirectives));
+            var d = el.get(OptionallyNeedsDirective);
+            expect(d.dependency).toEqual(null);
+          });
+
+          it("should allow for direct access using getDirectiveAtIndex", () => {
+            var providers =
+                ListWrapper.concat([SimpleDirective], extraDirectives);
+
+            var el = appElement(null, providers);
+
+            var firsIndexOut = providers.length > 10 ? providers.length : 10;
+
+            expect(el.getDirectiveAtIndex(0)).toBeAnInstanceOf(SimpleDirective);
+            expect(() => el.getDirectiveAtIndex(-1)).toThrowError('Index -1 is out-of-bounds.');
+            expect(() => el.getDirectiveAtIndex(firsIndexOut))
+                .toThrowError(`Index ${firsIndexOut} is out-of-bounds.`);
+          });
+
+          it("should instantiate directives that depend on the containing component", () => {
+            mockDirectiveMeta.set(SimpleDirective, new ComponentMetadata());
+            var shadow = hostShadowElement(ListWrapper.concat([SimpleDirective], extraDirectives),
+                                             [NeeedsDirectiveFromHost]);
+
+            var d = shadow.get(NeeedsDirectiveFromHost);
+            expect(d).toBeAnInstanceOf(NeeedsDirectiveFromHost);
+            expect(d.dependency).toBeAnInstanceOf(SimpleDirective);
+          });
+
+          it("should not instantiate directives that depend on other directives in the containing component's ElementInjector",
+             () => {
+               mockDirectiveMeta.set(SomeOtherDirective, new ComponentMetadata());
+               expect(() =>
+                      {
+                        hostShadowElement(
+                            ListWrapper.concat([SomeOtherDirective, SimpleDirective], extraDirectives),
+                            [NeedsDirective]);
+                      })
+                   .toThrowError(containsRegexp(
+                       `No provider for ${stringify(SimpleDirective) }! (${stringify(NeedsDirective) } -> ${stringify(SimpleDirective) })`));
+             });
+        });
+
+        describe('static attributes', () => {
+          it('should be injectable', () => {
+            var el = appElement(null, ListWrapper.concat([NeedsAttribute], extraDirectives), null, null, {
+              'type': 'text',
+              'title': ''
+            });
+            var needsAttribute = el.get(NeedsAttribute);
+
+            expect(needsAttribute.typeAttribute).toEqual('text');
+            expect(needsAttribute.titleAttribute).toEqual('');
+            expect(needsAttribute.fooAttribute).toEqual(null);
+          });
+
+          it('should be injectable without type annotation', () => {
+            var el = appElement(null, ListWrapper.concat([NeedsAttributeNoType], extraDirectives), null,
+                               null, {'foo': 'bar'});
+            var needsAttribute = el.get(NeedsAttributeNoType);
+
+            expect(needsAttribute.fooAttribute).toEqual('bar');
+          });
+        });
+
+        describe("refs", () => {
+          it("should inject ElementRef", () => {
+            var el = appElement(null, ListWrapper.concat([NeedsElementRef], extraDirectives));
+            expect(el.get(NeedsElementRef).elementRef).toBe(el.ref);
+          });
+
+          it("should inject ChangeDetectorRef of the component's view into the component via a proxy", () => {
+            mockDirectiveMeta.set(ComponentNeedsChangeDetectorRef, new ComponentMetadata());
+            var host = appElement(null, ListWrapper.concat([ComponentNeedsChangeDetectorRef], extraDirectives));
+            var view = createView(ViewType.COMPONENT, host);
+            host.attachComponentView(view);
+            host.get(ComponentNeedsChangeDetectorRef).changeDetectorRef.markForCheck();
+            expect((<any>view.changeDetector).spy('markPathToRootAsCheckOnce')).toHaveBeenCalled();
+          });
+
+          it("should inject ChangeDetectorRef of the containing component into directives", () => {
+            mockDirectiveMeta.set(DirectiveNeedsChangeDetectorRef, new DirectiveMetadata());
+            var view = createView(ViewType.HOST);
+            var el = appElement(null, ListWrapper.concat([DirectiveNeedsChangeDetectorRef], extraDirectives), view);
+            expect(el.get(DirectiveNeedsChangeDetectorRef).changeDetectorRef).toBe(view.changeDetector.ref);
+          });
+
+          it('should inject ViewContainerRef', () => {
+            var el = appElement(null, ListWrapper.concat([NeedsViewContainer], extraDirectives));
+            expect(el.get(NeedsViewContainer).viewContainer).toBeAnInstanceOf(ViewContainerRef_);
+          });
+
+          it("should inject TemplateRef", () => {
+            var el = appElement(null, ListWrapper.concat([NeedsTemplateRef], extraDirectives), null, dummyViewFactory);
+            expect(el.get(NeedsTemplateRef).templateRef.elementRef).toBe(el.ref);
+          });
+
+          it("should throw if there is no TemplateRef", () => {
+            expect(() => appElement(null, ListWrapper.concat([NeedsTemplateRef], extraDirectives)))
+                .toThrowError(
+                    `No provider for TemplateRef! (${stringify(NeedsTemplateRef) } -> TemplateRef)`);
+          });
+
+          it('should inject null if there is no TemplateRef when the dependency is optional', () => {
+            var el = appElement(null, ListWrapper.concat([OptionallyInjectsTemplateRef], extraDirectives));
+            var instance = el.get(OptionallyInjectsTemplateRef);
+            expect(instance.templateRef).toBeNull();
+          });
+        });
+
+        describe('queries', () => {
+          function expectDirectives(query: QueryList<any>, type, expectedIndex) {
+            var currentCount = 0;
+            expect(query.length).toEqual(expectedIndex.length);
+            iterateListLike(query, (i) => {
+              expect(i).toBeAnInstanceOf(type);
+              expect(i.count).toBe(expectedIndex[currentCount]);
+              currentCount += 1;
+            });
+          }
+
+          it('should be injectable', () => {
+            var el =
+                appElement(null, ListWrapper.concat([NeedsQuery], extraDirectives));
+            expect(el.get(NeedsQuery).query).toBeAnInstanceOf(QueryList);
+          });
+
+          it('should contain directives on the same injector', () => {
+            var el = appElement(null, ListWrapper.concat([
+                NeedsQuery,
+                CountingDirective
+              ], extraDirectives));
+
+            el.ngAfterContentChecked();
+
+            expectDirectives(el.get(NeedsQuery).query, CountingDirective, [0]);
+          });
+
+          it('should contain TemplateRefs on the same injector', () => {
+            var el = appElement(null, ListWrapper.concat([
+                NeedsTemplateRefQuery
+              ], extraDirectives), null, dummyViewFactory);
+
+            el.ngAfterContentChecked();
+
+            expect(el.get(NeedsTemplateRefQuery).query.first).toBeAnInstanceOf(TemplateRef_);
+          });
+
+          it('should contain the element when no directives are bound to the var provider', () => {
+            var dirs:Type[] = [NeedsQueryByVarBindings];
+
+            var dirVariableBindings:{[key:string]:number} = {
+              "one": null // element
+            };
+
+            var el = appElement(null, dirs.concat(extraDirectives), null, null, null, dirVariableBindings);
+
+            el.ngAfterContentChecked();
+
+            expect(el.get(NeedsQueryByVarBindings).query.first).toBe(el.ref);
+          });
+
+          it('should contain directives on the same injector when querying by variable providers' +
+            'in the order of var providers specified in the query', () => {
+            var dirs:Type[] = [NeedsQueryByVarBindings, NeedsDirective, SimpleDirective];
+
+            var dirVariableBindings:{[key:string]:number} = {
+              "one": 2, // 2 is the index of SimpleDirective
+              "two": 1 // 1 is the index of NeedsDirective
+            };
+
+            var el = appElement(null, dirs.concat(extraDirectives), null, null, null, dirVariableBindings);
+
+            el.ngAfterContentChecked();
+
+            // NeedsQueryByVarBindings queries "one,two", so SimpleDirective should be before NeedsDirective
+            expect(el.get(NeedsQueryByVarBindings).query.first).toBeAnInstanceOf(SimpleDirective);
+            expect(el.get(NeedsQueryByVarBindings).query.last).toBeAnInstanceOf(NeedsDirective);
+          });
+
+          it('should contain directives on the same and a child injector in construction order', () => {
+            var parent = appElement(null, [NeedsQuery, CountingDirective]);
+            appElement(parent, ListWrapper.concat([CountingDirective], extraDirectives));
+
+            parent.ngAfterContentChecked();
+
+            expectDirectives(parent.get(NeedsQuery).query, CountingDirective, [0, 1]);
+          });
+        });
+      });
+    });
+  });
+}
+
+class ContextWithHandler {
+  handler;
+  constructor(handler) { this.handler = handler; }
+}
\ No newline at end of file
diff --git a/modules/angular2/test/core/linker/event_config_spec.ts b/modules/angular2/test/core/linker/event_config_spec.ts
deleted file mode 100644
index 0e6992e..0000000
--- a/modules/angular2/test/core/linker/event_config_spec.ts
+++ /dev/null
@@ -1,31 +0,0 @@
-import {EventConfig} from 'angular2/src/core/linker/event_config';
-import {ddescribe, describe, expect, it} from 'angular2/testing_internal';
-
-export function main() {
-  describe('EventConfig', () => {
-    describe('parse', () => {
-      it('should handle short form events', () => {
-        var eventConfig = EventConfig.parse('shortForm');
-        expect(eventConfig.fieldName).toEqual('shortForm');
-        expect(eventConfig.eventName).toEqual('shortForm');
-        expect(eventConfig.isLongForm).toEqual(false);
-      });
-      it('should handle long form events', () => {
-        var eventConfig = EventConfig.parse('fieldName: eventName');
-        expect(eventConfig.fieldName).toEqual('fieldName');
-        expect(eventConfig.eventName).toEqual('eventName');
-        expect(eventConfig.isLongForm).toEqual(true);
-      });
-    });
-    describe('getFullName', () => {
-      it('should handle short form events', () => {
-        var eventConfig = new EventConfig('shortForm', 'shortForm', false);
-        expect(eventConfig.getFullName()).toEqual('shortForm');
-      });
-      it('should handle long form events', () => {
-        var eventConfig = new EventConfig('fieldName', 'eventName', true);
-        expect(eventConfig.getFullName()).toEqual('fieldName:eventName');
-      });
-    });
-  });
-}
diff --git a/modules/angular2/test/core/linker/integration_spec.ts b/modules/angular2/test/core/linker/integration_spec.ts
index 92c3545..353fb06 100644
--- a/modules/angular2/test/core/linker/integration_spec.ts
+++ b/modules/angular2/test/core/linker/integration_spec.ts
@@ -86,18 +86,40 @@ import {
 import {QueryList} from 'angular2/src/core/linker/query_list';
 
 import {ViewContainerRef} from 'angular2/src/core/linker/view_container_ref';
-import {ViewRef, ViewRef_} from 'angular2/src/core/linker/view_ref';
+import {EmbeddedViewRef} from 'angular2/src/core/linker/view_ref';
 
 import {Compiler} from 'angular2/src/core/linker/compiler';
-import {ElementRef, ElementRef_} from 'angular2/src/core/linker/element_ref';
+import {ElementRef} from 'angular2/src/core/linker/element_ref';
 import {TemplateRef} from 'angular2/src/core/linker/template_ref';
 
-import {DomRenderer} from 'angular2/src/platform/dom/dom_renderer';
+import {Renderer} from 'angular2/src/core/render';
 import {IS_DART} from 'angular2/src/facade/lang';
 
 const ANCHOR_ELEMENT = CONST_EXPR(new OpaqueToken('AnchorElement'));
 
 export function main() {
+  if (IS_DART) {
+    declareTests();
+  } else {
+    describe('no jit', () => {
+      beforeEachProviders(() => [
+        provide(ChangeDetectorGenConfig,
+                {useValue: new ChangeDetectorGenConfig(true, false, false)})
+      ]);
+      declareTests();
+    });
+
+    describe('jit', () => {
+      beforeEachProviders(() => [
+        provide(ChangeDetectorGenConfig,
+                {useValue: new ChangeDetectorGenConfig(true, false, true)})
+      ]);
+      declareTests();
+    });
+  }
+}
+
+function declareTests() {
   describe('integration tests', function() {
 
     beforeEachProviders(() => [provide(ANCHOR_ELEMENT, {useValue: el('<div></div>')})]);
@@ -151,7 +173,6 @@ export function main() {
 
                .createAsync(MyComp)
                .then((fixture) => {
-
                  fixture.debugElement.componentInstance.ctxProp = 'Initial aria label';
                  fixture.detectChanges();
                  expect(
@@ -306,17 +327,16 @@ export function main() {
 
       it('should consume directive watch expression change.',
          inject([TestComponentBuilder, AsyncTestCompleter], (tcb: TestComponentBuilder, async) => {
-           var tpl = '<div>' +
+           var tpl = '<span>' +
                      '<div my-dir [elprop]="ctxProp"></div>' +
                      '<div my-dir elprop="Hi there!"></div>' +
                      '<div my-dir elprop="Hi {{\'there!\'}}"></div>' +
                      '<div my-dir elprop="One more {{ctxProp}}"></div>' +
-                     '</div>';
+                     '</span>';
            tcb.overrideView(MyComp, new ViewMetadata({template: tpl, directives: [MyDir]}))
 
                .createAsync(MyComp)
                .then((fixture) => {
-
                  fixture.debugElement.componentInstance.ctxProp = 'Hello World!';
                  fixture.detectChanges();
 
@@ -677,7 +697,6 @@ export function main() {
                  .createAsync(MyComp)
                  .then((fixture) => {
                    fixture.detectChanges();
-
                    // Get the element at index 2, since index 0 is the <template>.
                    expect(DOM.childNodes(fixture.debugElement.nativeElement)[2])
                        .toHaveText("1-hello");
@@ -1085,6 +1104,9 @@ export function main() {
                  dispatchEvent(DOM.getGlobalEventTarget("window"), 'domEvent');
                  expect(globalCounter).toEqual(2);
 
+                 // need to destroy to release all remaining global event listeners
+                 fixture.destroy();
+
                  async.done();
                });
          }));
@@ -1850,8 +1872,8 @@ class MyService {
 class SimpleImperativeViewComponent {
   done;
 
-  constructor(self: ElementRef, renderer: DomRenderer) {
-    var hostElement = renderer.getNativeElementSync(self);
+  constructor(self: ElementRef, renderer: Renderer) {
+    var hostElement = self.nativeElement;
     DOM.appendChild(hostElement, el('hello imp view'));
   }
 }
@@ -2332,10 +2354,10 @@ class ChildConsumingEventBus {
 @Directive({selector: '[someImpvp]', inputs: ['someImpvp']})
 @Injectable()
 class SomeImperativeViewport {
-  view: ViewRef;
+  view: EmbeddedViewRef;
   anchor;
   constructor(public vc: ViewContainerRef, public templateRef: TemplateRef,
-              public renderer: DomRenderer, @Inject(ANCHOR_ELEMENT) anchor) {
+              @Inject(ANCHOR_ELEMENT) anchor) {
     this.view = null;
     this.anchor = anchor;
   }
@@ -2347,7 +2369,7 @@ class SomeImperativeViewport {
     }
     if (value) {
       this.view = this.vc.createEmbeddedView(this.templateRef);
-      var nodes = this.renderer.getRootNodes((<ViewRef_>this.view).renderFragment);
+      var nodes = this.view.rootNodes;
       for (var i = 0; i < nodes.length; i++) {
         DOM.appendChild(this.anchor, nodes[i]);
       }
diff --git a/modules/angular2/test/core/linker/projection_integration_spec.ts b/modules/angular2/test/core/linker/projection_integration_spec.ts
index 5cd4df8..d41e3f8 100644
--- a/modules/angular2/test/core/linker/projection_integration_spec.ts
+++ b/modules/angular2/test/core/linker/projection_integration_spec.ts
@@ -34,9 +34,12 @@ import {
   View,
   ViewContainerRef,
   ViewEncapsulation,
-  ViewMetadata
+  ViewMetadata,
+  Scope
 } from 'angular2/core';
-import {By} from 'angular2/platform/common_dom';
+import {
+  By,
+} from 'angular2/platform/common_dom';
 
 export function main() {
   describe('projection', () => {
@@ -439,6 +442,7 @@ export function main() {
                  var childNodes = DOM.childNodes(main.debugElement.nativeElement);
                  expect(childNodes[0]).toHaveText('div {color: red}SIMPLE1(A)');
                  expect(childNodes[1]).toHaveText('div {color: blue}SIMPLE2(B)');
+                 main.destroy();
                  async.done();
                });
          }));
@@ -521,6 +525,47 @@ export function main() {
              });
        }));
 
+    it('should project filled view containers into a view container',
+       inject([TestComponentBuilder, AsyncTestCompleter], (tcb: TestComponentBuilder, async) => {
+         tcb.overrideView(MainComp, new ViewMetadata({
+                            template: '<conditional-content>' +
+                                          '<div class="left">A</div>' +
+                                          '<template manual class="left">B</template>' +
+                                          '<div class="left">C</div>' +
+                                          '<div>D</div>' +
+                                          '</conditional-content>',
+                            directives: [ConditionalContentComponent, ManualViewportDirective]
+                          }))
+             .createAsync(MainComp)
+             .then((main) => {
+               var conditionalComp =
+                   main.debugElement.query(By.directive(ConditionalContentComponent));
+               var viewViewportDir =
+                   conditionalComp.query(By.directive(ManualViewportDirective), Scope.view)
+                       .inject(ManualViewportDirective);
+
+               var contentViewportDir =
+                   conditionalComp.query(By.directive(ManualViewportDirective), Scope.light)
+                       .inject(ManualViewportDirective);
+
+               expect(main.debugElement.nativeElement).toHaveText('(, D)');
+               expect(main.debugElement.nativeElement).toHaveText('(, D)');
+               // first show content viewport, then the view viewport,
+               // i.e. projection needs to take create of already
+               // created views
+               contentViewportDir.show();
+               viewViewportDir.show();
+               expect(main.debugElement.nativeElement).toHaveText('(ABC, D)');
+
+               // hide view viewport, and test that it also hides
+               // the content viewport's views
+               viewViewportDir.hide();
+               expect(main.debugElement.nativeElement).toHaveText('(, D)');
+
+               async.done();
+             });
+       }));
+
   });
 }
 
diff --git a/modules/angular2/test/core/linker/proto_view_factory_spec.ts b/modules/angular2/test/core/linker/proto_view_factory_spec.ts
deleted file mode 100644
index 8050cf4..0000000
--- a/modules/angular2/test/core/linker/proto_view_factory_spec.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-import {
-  AsyncTestCompleter,
-  beforeEach,
-  xdescribe,
-  ddescribe,
-  describe,
-  el,
-  expect,
-  iit,
-  inject,
-  it
-} from 'angular2/testing_internal';
-
-export function main() {
-  describe('ProtoViewFactory', () => {
-                                   // TODO
-
-                               });
-}
diff --git a/modules/angular2/test/core/linker/query_integration_spec.ts b/modules/angular2/test/core/linker/query_integration_spec.ts
index c887688..33f6499 100644
--- a/modules/angular2/test/core/linker/query_integration_spec.ts
+++ b/modules/angular2/test/core/linker/query_integration_spec.ts
@@ -35,7 +35,7 @@ import {
   AfterViewChecked
 } from 'angular2/core';
 import {NgIf, NgFor} from 'angular2/common';
-import {asNativeElements} from 'angular2/core';
+import {asNativeElements, ViewContainerRef} from 'angular2/core';
 
 export function main() {
   describe('Query API', () => {
@@ -99,6 +99,8 @@ export function main() {
                  view.debugElement.componentInstance.shouldShow = false;
                  view.detectChanges();
 
+                 // TODO: this fails right now!
+                 // -> queries are not dirtied!
                  expect(q.log).toEqual([
                    ["setter", "foo"],
                    ["init", "foo"],
@@ -250,8 +252,11 @@ export function main() {
                  view.detectChanges();
                  var needsTpl: NeedsTpl =
                      view.debugElement.componentViewChildren[0].inject(NeedsTpl);
-                 expect(needsTpl.query.first.hasLocal('light')).toBe(true);
-                 expect(needsTpl.viewQuery.first.hasLocal('shadow')).toBe(true);
+
+                 expect(needsTpl.vc.createEmbeddedView(needsTpl.query.first).hasLocal('light'))
+                     .toBe(true);
+                 expect(needsTpl.vc.createEmbeddedView(needsTpl.viewQuery.first).hasLocal('shadow'))
+                     .toBe(true);
 
                  async.done();
                });
@@ -892,7 +897,7 @@ class NeedsTpl {
   viewQuery: QueryList<TemplateRef>;
   query: QueryList<TemplateRef>;
   constructor(@ViewQuery(TemplateRef) viewQuery: QueryList<TemplateRef>,
-              @Query(TemplateRef) query: QueryList<TemplateRef>) {
+              @Query(TemplateRef) query: QueryList<TemplateRef>, public vc: ViewContainerRef) {
     this.viewQuery = viewQuery;
     this.query = query;
   }
diff --git a/modules/angular2/test/core/linker/view_container_ref_spec.ts b/modules/angular2/test/core/linker/view_container_ref_spec.ts
deleted file mode 100644
index afe0245..0000000
--- a/modules/angular2/test/core/linker/view_container_ref_spec.ts
+++ /dev/null
@@ -1,60 +0,0 @@
-import {
-  AsyncTestCompleter,
-  beforeEach,
-  ddescribe,
-  xdescribe,
-  describe,
-  el,
-  dispatchEvent,
-  expect,
-  iit,
-  inject,
-  beforeEachProviders,
-  it,
-  xit
-} from 'angular2/testing_internal';
-
-import {SpyView, SpyAppViewManager} from '../spies';
-import {AppView, AppViewContainer} from 'angular2/src/core/linker/view';
-import {ViewContainerRef, ViewContainerRef_} from 'angular2/src/core/linker/view_container_ref';
-import {ElementRef, ElementRef_} from 'angular2/src/core/linker/element_ref';
-import {ViewRef, ViewRef_} from 'angular2/src/core/linker/view_ref';
-
-export function main() {
-  // TODO(tbosch): add missing tests
-
-  describe('ViewContainerRef', () => {
-    var location;
-    var view;
-    var viewManager;
-
-    function createViewContainer() { return new ViewContainerRef_(viewManager, location); }
-
-    beforeEach(() => {
-      viewManager = new SpyAppViewManager();
-      view = new SpyView();
-      view.prop("viewContainers", [null]);
-      location = new ElementRef_(new ViewRef_(view), 0, null);
-    });
-
-    describe('length', () => {
-
-      it('should return a 0 length if there is no underlying AppViewContainer', () => {
-        var vc = createViewContainer();
-        expect(vc.length).toBe(0);
-      });
-
-      it('should return the size of the underlying AppViewContainer', () => {
-        var vc = createViewContainer();
-        var appVc = new AppViewContainer();
-        view.prop("viewContainers", [appVc]);
-        appVc.views = [<any>new SpyView()];
-        expect(vc.length).toBe(1);
-      });
-
-    });
-
-    // TODO: add missing tests here!
-
-  });
-}
diff --git a/modules/angular2/test/core/linker/view_manager_spec.ts b/modules/angular2/test/core/linker/view_manager_spec.ts
deleted file mode 100644
index b00701a..0000000
--- a/modules/angular2/test/core/linker/view_manager_spec.ts
+++ /dev/null
@@ -1,520 +0,0 @@
-import {
-  AsyncTestCompleter,
-  beforeEach,
-  ddescribe,
-  xdescribe,
-  describe,
-  el,
-  dispatchEvent,
-  expect,
-  iit,
-  inject,
-  beforeEachProviders,
-  it,
-  xit
-} from 'angular2/testing_internal';
-import {SpyRenderer, SpyAppViewPool, SpyAppViewListener, SpyProtoViewFactory} from '../spies';
-import {Injector, provide} from 'angular2/core';
-
-import {AppProtoView, AppView, AppViewContainer, ViewType} from 'angular2/src/core/linker/view';
-import {
-  ProtoViewRef,
-  ProtoViewRef_,
-  ViewRef,
-  ViewRef_,
-  internalView
-} from 'angular2/src/core/linker/view_ref';
-import {ElementRef} from 'angular2/src/core/linker/element_ref';
-import {TemplateRef, TemplateRef_} from 'angular2/src/core/linker/template_ref';
-import {
-  Renderer,
-  RenderViewRef,
-  RenderProtoViewRef,
-  RenderFragmentRef,
-  RenderViewWithFragments
-} from 'angular2/src/core/render/api';
-import {AppViewManager, AppViewManager_} from 'angular2/src/core/linker/view_manager';
-import {AppViewManagerUtils} from 'angular2/src/core/linker/view_manager_utils';
-
-import {
-  createHostPv,
-  createComponentPv,
-  createEmbeddedPv,
-  createEmptyElBinder,
-  createNestedElBinder,
-  createProtoElInjector
-} from './view_manager_utils_spec';
-
-export function main() {
-  // TODO(tbosch): add missing tests
-
-  describe('AppViewManager', () => {
-    var renderer;
-    var utils: AppViewManagerUtils;
-    var viewListener;
-    var viewPool;
-    var linker;
-    var manager: AppViewManager;
-    var createdRenderViews: RenderViewWithFragments[];
-
-    function wrapPv(protoView: AppProtoView): ProtoViewRef { return new ProtoViewRef_(protoView); }
-
-    function wrapView(view: AppView): ViewRef { return new ViewRef_(view); }
-
-    function resetSpies() {
-      viewListener.spy('onViewCreated').reset();
-      viewListener.spy('onViewDestroyed').reset();
-      renderer.spy('createView').reset();
-      renderer.spy('destroyView').reset();
-      renderer.spy('createRootHostView').reset();
-      renderer.spy('setEventDispatcher').reset();
-      renderer.spy('hydrateView').reset();
-      renderer.spy('dehydrateView').reset();
-      viewPool.spy('returnView').reset();
-    }
-
-    beforeEach(() => {
-      renderer = new SpyRenderer();
-      utils = new AppViewManagerUtils();
-      viewListener = new SpyAppViewListener();
-      viewPool = new SpyAppViewPool();
-      linker = new SpyProtoViewFactory();
-      manager = new AppViewManager_(viewPool, viewListener, utils, renderer, linker);
-      createdRenderViews = [];
-
-      renderer.spy('createRootHostView')
-          .andCallFake((_a, renderFragmentCount, _b) => {
-            var fragments = [];
-            for (var i = 0; i < renderFragmentCount; i++) {
-              fragments.push(new RenderFragmentRef());
-            }
-            var rv = new RenderViewWithFragments(new RenderViewRef(), fragments);
-            createdRenderViews.push(rv);
-            return rv;
-          });
-      renderer.spy('createView')
-          .andCallFake((_a, renderFragmentCount) => {
-            var fragments = [];
-            for (var i = 0; i < renderFragmentCount; i++) {
-              fragments.push(new RenderFragmentRef());
-            }
-            var rv = new RenderViewWithFragments(new RenderViewRef(), fragments);
-            createdRenderViews.push(rv);
-            return rv;
-          });
-      viewPool.spy('returnView').andReturn(true);
-    });
-
-    describe('createRootHostView', () => {
-
-      var hostProtoView: AppProtoView;
-      beforeEach(
-          () => { hostProtoView = createHostPv([createNestedElBinder(createComponentPv())]); });
-
-      it('should initialize the ProtoView', () => {
-        manager.createRootHostView(wrapPv(hostProtoView), null, null);
-        expect(linker.spy('initializeProtoViewIfNeeded')).toHaveBeenCalledWith(hostProtoView);
-      });
-
-      it('should create the view', () => {
-        var rootView =
-            internalView(<ViewRef>manager.createRootHostView(wrapPv(hostProtoView), null, null));
-        expect(rootView.proto).toBe(hostProtoView);
-        expect(viewListener.spy('onViewCreated')).toHaveBeenCalledWith(rootView);
-      });
-
-      it('should hydrate the view', () => {
-        var injector = Injector.resolveAndCreate([]);
-        var rootView = internalView(
-            <ViewRef>manager.createRootHostView(wrapPv(hostProtoView), null, injector));
-        expect(rootView.hydrated()).toBe(true);
-        expect(renderer.spy('hydrateView')).toHaveBeenCalledWith(rootView.render);
-      });
-
-      it('should create and set the render view using the component selector', () => {
-        var rootView =
-            internalView(<ViewRef>manager.createRootHostView(wrapPv(hostProtoView), null, null));
-        expect(renderer.spy('createRootHostView'))
-            .toHaveBeenCalledWith(hostProtoView.render,
-                                  hostProtoView.mergeInfo.embeddedViewCount + 1, 'someComponent');
-        expect(rootView.render).toBe(createdRenderViews[0].viewRef);
-        expect(rootView.renderFragment).toBe(createdRenderViews[0].fragmentRefs[0]);
-      });
-
-      it('should allow to override the selector', () => {
-        var selector = 'someOtherSelector';
-        internalView(<ViewRef>manager.createRootHostView(wrapPv(hostProtoView), selector, null));
-        expect(renderer.spy('createRootHostView'))
-            .toHaveBeenCalledWith(hostProtoView.render,
-                                  hostProtoView.mergeInfo.embeddedViewCount + 1, selector);
-      });
-
-      it('should set the event dispatcher', () => {
-        var rootView =
-            internalView(<ViewRef>manager.createRootHostView(wrapPv(hostProtoView), null, null));
-        expect(renderer.spy('setEventDispatcher')).toHaveBeenCalledWith(rootView.render, rootView);
-      });
-
-    });
-
-
-    describe('destroyRootHostView', () => {
-      var hostProtoView: AppProtoView;
-      var hostView: AppView;
-      var hostRenderViewRef: RenderViewRef;
-      beforeEach(() => {
-        hostProtoView = createHostPv([createNestedElBinder(createComponentPv())]);
-        hostView =
-            internalView(<ViewRef>manager.createRootHostView(wrapPv(hostProtoView), null, null));
-        hostRenderViewRef = hostView.render;
-      });
-
-      it('should dehydrate', () => {
-        manager.destroyRootHostView(wrapView(hostView));
-        expect(hostView.hydrated()).toBe(false);
-        expect(renderer.spy('dehydrateView')).toHaveBeenCalledWith(hostView.render);
-      });
-
-      it('should destroy the render view', () => {
-        manager.destroyRootHostView(wrapView(hostView));
-        expect(renderer.spy('destroyView')).toHaveBeenCalledWith(hostRenderViewRef);
-        expect(viewListener.spy('onViewDestroyed')).toHaveBeenCalledWith(hostView);
-      });
-
-      it('should not return the view to the pool', () => {
-        manager.destroyRootHostView(wrapView(hostView));
-        expect(viewPool.spy('returnView')).not.toHaveBeenCalled();
-      });
-
-    });
-
-    describe('createEmbeddedViewInContainer', () => {
-
-      describe('basic functionality', () => {
-        var hostView: AppView;
-        var childProtoView: AppProtoView;
-        var vcRef: ElementRef;
-        var templateRef: TemplateRef;
-        beforeEach(() => {
-          childProtoView = createEmbeddedPv();
-          var hostProtoView = createHostPv(
-              [createNestedElBinder(createComponentPv([createNestedElBinder(childProtoView)]))]);
-          hostView =
-              internalView(<ViewRef>manager.createRootHostView(wrapPv(hostProtoView), null, null));
-          vcRef = hostView.elementRefs[1];
-          templateRef = new TemplateRef_(hostView.elementRefs[1]);
-          resetSpies();
-        });
-
-        it('should initialize the ProtoView', () => {
-          manager.createEmbeddedViewInContainer(vcRef, 0, templateRef);
-          expect(linker.spy('initializeProtoViewIfNeeded')).toHaveBeenCalledWith(childProtoView);
-        });
-
-        describe('create the first view', () => {
-
-          it('should create an AppViewContainer if not yet existing', () => {
-            manager.createEmbeddedViewInContainer(vcRef, 0, templateRef);
-            expect(hostView.viewContainers[1]).toBeTruthy();
-          });
-
-          it('should use an existing nested view', () => {
-            var childView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 0, templateRef));
-            expect(childView.proto).toBe(childProtoView);
-            expect(childView).toBe(hostView.views[2]);
-            expect(viewListener.spy('onViewCreated')).not.toHaveBeenCalled();
-            expect(renderer.spy('createView')).not.toHaveBeenCalled();
-          });
-
-          it('should attach the fragment', () => {
-            var childView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 0, templateRef));
-            expect(childView.proto).toBe(childProtoView);
-            expect(hostView.viewContainers[1].views.length).toBe(1);
-            expect(hostView.viewContainers[1].views[0]).toBe(childView);
-            expect(renderer.spy('attachFragmentAfterElement'))
-                .toHaveBeenCalledWith(vcRef, childView.renderFragment);
-          });
-
-          it('should hydrate the view but not the render view', () => {
-            var childView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 0, templateRef));
-            expect(childView.hydrated()).toBe(true);
-            expect(renderer.spy('hydrateView')).not.toHaveBeenCalled();
-          });
-
-          it('should not set the EventDispatcher', () => {
-            internalView(manager.createEmbeddedViewInContainer(vcRef, 0, templateRef));
-            expect(renderer.spy('setEventDispatcher')).not.toHaveBeenCalled();
-          });
-
-        });
-
-        describe('create the second view', () => {
-          var firstChildView;
-          beforeEach(() => {
-            firstChildView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 0, templateRef));
-            resetSpies();
-          });
-
-          it('should create a new view', () => {
-            var childView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 1, templateRef));
-            expect(childView.proto).toBe(childProtoView);
-            expect(childView).not.toBe(firstChildView);
-            expect(viewListener.spy('onViewCreated')).toHaveBeenCalledWith(childView);
-            expect(renderer.spy('createView'))
-                .toHaveBeenCalledWith(childProtoView.render,
-                                      childProtoView.mergeInfo.embeddedViewCount + 1);
-            expect(childView.render).toBe(createdRenderViews[1].viewRef);
-            expect(childView.renderFragment).toBe(createdRenderViews[1].fragmentRefs[0]);
-          });
-
-          it('should attach the fragment', () => {
-            var childView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 1, templateRef));
-            expect(childView.proto).toBe(childProtoView);
-            expect(hostView.viewContainers[1].views[1]).toBe(childView);
-            expect(renderer.spy('attachFragmentAfterFragment'))
-                .toHaveBeenCalledWith(firstChildView.renderFragment, childView.renderFragment);
-          });
-
-          it('should hydrate the view', () => {
-            var childView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 1, templateRef));
-            expect(childView.hydrated()).toBe(true);
-            expect(renderer.spy('hydrateView')).toHaveBeenCalledWith(childView.render);
-          });
-
-          it('should set the EventDispatcher', () => {
-            var childView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 1, templateRef));
-            expect(renderer.spy('setEventDispatcher'))
-                .toHaveBeenCalledWith(childView.render, childView);
-          });
-
-        });
-
-        describe('create another view when the first view has been returned', () => {
-          beforeEach(() => {
-            internalView(manager.createEmbeddedViewInContainer(vcRef, 0, templateRef));
-            manager.destroyViewInContainer(vcRef, 0);
-            resetSpies();
-          });
-
-          it('should use an existing nested view', () => {
-            var childView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 0, templateRef));
-            expect(childView.proto).toBe(childProtoView);
-            expect(childView).toBe(hostView.views[2]);
-            expect(viewListener.spy('onViewCreated')).not.toHaveBeenCalled();
-            expect(renderer.spy('createView')).not.toHaveBeenCalled();
-          });
-
-        });
-
-        describe('create a host view', () => {
-
-          it('should initialize the ProtoView', () => {
-            var newHostPv = createHostPv([createNestedElBinder(createComponentPv())]);
-            manager.createHostViewInContainer(vcRef, 0, wrapPv(newHostPv), null);
-            expect(linker.spy('initializeProtoViewIfNeeded')).toHaveBeenCalledWith(newHostPv);
-          });
-
-          it('should always create a new view and not use the embedded view', () => {
-            var newHostPv = createHostPv([createNestedElBinder(createComponentPv())]);
-            var newHostView = internalView(
-                <ViewRef>manager.createHostViewInContainer(vcRef, 0, wrapPv(newHostPv), null));
-            expect(newHostView.proto).toBe(newHostPv);
-            expect(newHostView).not.toBe(hostView.views[2]);
-            expect(viewListener.spy('onViewCreated')).toHaveBeenCalledWith(newHostView);
-            expect(renderer.spy('createView'))
-                .toHaveBeenCalledWith(newHostPv.render, newHostPv.mergeInfo.embeddedViewCount + 1);
-          });
-
-        });
-
-      });
-    });
-
-    describe('destroyViewInContainer', () => {
-
-      describe('basic functionality', () => {
-        var hostView: AppView;
-        var childProtoView: AppProtoView;
-        var vcRef: ElementRef;
-        var templateRef: TemplateRef;
-        var firstChildView: AppView;
-        beforeEach(() => {
-          childProtoView = createEmbeddedPv();
-          var hostProtoView = createHostPv(
-              [createNestedElBinder(createComponentPv([createNestedElBinder(childProtoView)]))]);
-          hostView =
-              internalView(<ViewRef>manager.createRootHostView(wrapPv(hostProtoView), null, null));
-          vcRef = hostView.elementRefs[1];
-          templateRef = new TemplateRef_(hostView.elementRefs[1]);
-          firstChildView =
-              internalView(manager.createEmbeddedViewInContainer(vcRef, 0, templateRef));
-          resetSpies();
-        });
-
-        describe('destroy the first view', () => {
-          it('should dehydrate the app view but not the render view', () => {
-            manager.destroyViewInContainer(vcRef, 0);
-            expect(firstChildView.hydrated()).toBe(false);
-            expect(renderer.spy('dehydrateView')).not.toHaveBeenCalled();
-          });
-
-          it('should detach', () => {
-            manager.destroyViewInContainer(vcRef, 0);
-            expect(hostView.viewContainers[1].views).toEqual([]);
-            expect(renderer.spy('detachFragment'))
-                .toHaveBeenCalledWith(firstChildView.renderFragment);
-          });
-
-          it('should not return the view to the pool', () => {
-            manager.destroyViewInContainer(vcRef, 0);
-            expect(viewPool.spy('returnView')).not.toHaveBeenCalled();
-          });
-
-        });
-
-        describe('destroy another view', () => {
-          var secondChildView;
-          beforeEach(() => {
-            secondChildView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 1, templateRef));
-            resetSpies();
-          });
-
-          it('should dehydrate', () => {
-            manager.destroyViewInContainer(vcRef, 1);
-            expect(secondChildView.hydrated()).toBe(false);
-            expect(renderer.spy('dehydrateView')).toHaveBeenCalledWith(secondChildView.render);
-          });
-
-          it('should detach', () => {
-            manager.destroyViewInContainer(vcRef, 1);
-            expect(hostView.viewContainers[1].views[0]).toBe(firstChildView);
-            expect(renderer.spy('detachFragment'))
-                .toHaveBeenCalledWith(secondChildView.renderFragment);
-          });
-
-          it('should return the view to the pool', () => {
-            manager.destroyViewInContainer(vcRef, 1);
-            expect(viewPool.spy('returnView')).toHaveBeenCalledWith(secondChildView);
-          });
-
-        });
-      });
-
-      describe('recursively destroy views in ViewContainers', () => {
-
-        describe('destroy child views when a component is destroyed', () => {
-          var hostView: AppView;
-          var childProtoView: AppProtoView;
-          var vcRef: ElementRef;
-          var templateRef: TemplateRef;
-          var firstChildView: AppView;
-          var secondChildView: AppView;
-          beforeEach(() => {
-            childProtoView = createEmbeddedPv();
-            var hostProtoView = createHostPv(
-                [createNestedElBinder(createComponentPv([createNestedElBinder(childProtoView)]))]);
-            hostView = internalView(
-                <ViewRef>manager.createRootHostView(wrapPv(hostProtoView), null, null));
-            vcRef = hostView.elementRefs[1];
-            templateRef = new TemplateRef_(hostView.elementRefs[1]);
-            firstChildView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 0, templateRef));
-            secondChildView =
-                internalView(manager.createEmbeddedViewInContainer(vcRef, 1, templateRef));
-            resetSpies();
-          });
-
-          it('should dehydrate', () => {
-            manager.destroyRootHostView(wrapView(hostView));
-            expect(firstChildView.hydrated()).toBe(false);
-            expect(secondChildView.hydrated()).toBe(false);
-            expect(renderer.spy('dehydrateView')).toHaveBeenCalledWith(hostView.render);
-            expect(renderer.spy('dehydrateView')).toHaveBeenCalledWith(secondChildView.render);
-          });
-
-          it('should detach', () => {
-            manager.destroyRootHostView(wrapView(hostView));
-            expect(hostView.viewContainers[1].views).toEqual([]);
-            expect(renderer.spy('detachFragment'))
-                .toHaveBeenCalledWith(firstChildView.renderFragment);
-            expect(renderer.spy('detachFragment'))
-                .toHaveBeenCalledWith(secondChildView.renderFragment);
-          });
-
-          it('should return the view to the pool', () => {
-            manager.destroyRootHostView(wrapView(hostView));
-            expect(viewPool.spy('returnView')).not.toHaveBeenCalledWith(firstChildView);
-            expect(viewPool.spy('returnView')).toHaveBeenCalledWith(secondChildView);
-          });
-
-        });
-
-        describe('destroy child views over multiple levels', () => {
-          var hostView: AppView;
-          var childProtoView: AppProtoView;
-          var nestedChildProtoView: AppProtoView;
-          var vcRef: ElementRef;
-          var templateRef: TemplateRef;
-          var nestedVcRefs: ElementRef[];
-          var childViews: AppView[];
-          var nestedChildViews: AppView[];
-          beforeEach(() => {
-            nestedChildProtoView = createEmbeddedPv();
-            childProtoView = createEmbeddedPv([
-              createNestedElBinder(
-                  createComponentPv([createNestedElBinder(nestedChildProtoView)]))
-            ]);
-            var hostProtoView = createHostPv(
-                [createNestedElBinder(createComponentPv([createNestedElBinder(childProtoView)]))]);
-            hostView = internalView(
-                <ViewRef>manager.createRootHostView(wrapPv(hostProtoView), null, null));
-            vcRef = hostView.elementRefs[1];
-            templateRef = new TemplateRef_(hostView.elementRefs[1]);
-            nestedChildViews = [];
-            childViews = [];
-            nestedVcRefs = [];
-            for (var i = 0; i < 2; i++) {
-              var view = internalView(manager.createEmbeddedViewInContainer(vcRef, i, templateRef));
-              childViews.push(view);
-              var nestedVcRef = view.elementRefs[view.elementOffset];
-              nestedVcRefs.push(nestedVcRef);
-              for (var j = 0; j < 2; j++) {
-                var nestedView = internalView(
-                    manager.createEmbeddedViewInContainer(nestedVcRef, j, templateRef));
-                nestedChildViews.push(nestedView);
-              }
-            }
-            resetSpies();
-          });
-
-          it('should dehydrate all child views', () => {
-            manager.destroyRootHostView(wrapView(hostView));
-            childViews.forEach((childView) => expect(childView.hydrated()).toBe(false));
-            nestedChildViews.forEach((childView) => expect(childView.hydrated()).toBe(false));
-          });
-
-        });
-
-      });
-
-    });
-
-    describe('attachViewInContainer', () => {
-
-                                      });
-
-    describe('detachViewInContainer', () => {
-
-                                      });
-  });
-}
diff --git a/modules/angular2/test/core/linker/view_manager_utils_spec.ts b/modules/angular2/test/core/linker/view_manager_utils_spec.ts
deleted file mode 100644
index 9f6bcfc..0000000
--- a/modules/angular2/test/core/linker/view_manager_utils_spec.ts
+++ /dev/null
@@ -1,293 +0,0 @@
-import {
-  AsyncTestCompleter,
-  beforeEach,
-  ddescribe,
-  xdescribe,
-  describe,
-  el,
-  dispatchEvent,
-  expect,
-  iit,
-  inject,
-  beforeEachProviders,
-  it,
-  xit,
-  Log,
-  SpyObject
-} from 'angular2/testing_internal';
-
-import {
-  SpyChangeDetector,
-  SpyProtoElementInjector,
-  SpyElementInjector,
-  SpyPreBuiltObjects
-} from '../spies';
-
-import {Injector, provide} from 'angular2/core';
-import {isBlank, isPresent} from 'angular2/src/facade/lang';
-
-import {
-  AppProtoView,
-  AppView,
-  AppProtoViewMergeInfo,
-  ViewType
-} from 'angular2/src/core/linker/view';
-import {ElementBinder} from 'angular2/src/core/linker/element_binder';
-import {
-  DirectiveProvider,
-  ElementInjector,
-  PreBuiltObjects,
-  ProtoElementInjector
-} from 'angular2/src/core/linker/element_injector';
-import {DirectiveResolver} from 'angular2/src/core/linker/directive_resolver';
-import {Component} from 'angular2/src/core/metadata';
-import {AppViewManagerUtils} from 'angular2/src/core/linker/view_manager_utils';
-import {RenderViewWithFragments} from 'angular2/core';
-
-export function main() {
-  // TODO(tbosch): add more tests here!
-
-  describe('AppViewManagerUtils', () => {
-
-    var utils: AppViewManagerUtils;
-
-    beforeEach(() => { utils = new AppViewManagerUtils(); });
-
-    function createViewWithChildren(pv: AppProtoView): AppView {
-      var renderViewWithFragments = new RenderViewWithFragments(null, [null, null]);
-      return utils.createView(pv, renderViewWithFragments, null, null);
-    }
-
-    describe('shared hydrate functionality', () => {
-
-      it("should hydrate the change detector after hydrating element injectors", () => {
-        var log = new Log();
-
-        var componentProtoView = createComponentPv([createEmptyElBinder()]);
-        var hostView =
-            createViewWithChildren(createHostPv([createNestedElBinder(componentProtoView)]));
-        var componentView = hostView.views[1];
-
-        var spyEi = <any>componentView.elementInjectors[0];
-        spyEi.spy('hydrate').andCallFake(log.fn('hydrate'));
-
-        var spyCd = <any>componentView.changeDetector;
-        spyCd.spy('hydrate').andCallFake(log.fn('hydrateCD'));
-
-        utils.hydrateRootHostView(hostView, createInjector());
-
-        expect(log.result()).toEqual('hydrate; hydrateCD');
-      });
-
-      it("should set up event listeners", () => {
-        var dir = new Object();
-
-        var hostPv =
-            createHostPv([createNestedElBinder(createComponentPv()), createEmptyElBinder()]);
-        var hostView = createViewWithChildren(hostPv);
-        var spyEventAccessor1 = SpyObject.stub({"subscribe": null});
-        SpyObject.stub(
-            hostView.elementInjectors[0],
-            {'getEventEmitterAccessors': [[spyEventAccessor1]], 'getDirectiveAtIndex': dir});
-        var spyEventAccessor2 = SpyObject.stub({"subscribe": null});
-        SpyObject.stub(
-            hostView.elementInjectors[1],
-            {'getEventEmitterAccessors': [[spyEventAccessor2]], 'getDirectiveAtIndex': dir});
-
-        utils.hydrateRootHostView(hostView, createInjector());
-
-        expect(spyEventAccessor1.spy('subscribe')).toHaveBeenCalledWith(hostView, 0, dir);
-        expect(spyEventAccessor2.spy('subscribe')).toHaveBeenCalledWith(hostView, 1, dir);
-      });
-
-      it("should not hydrate element injectors of component views inside of embedded fragments",
-         () => {
-           var hostView = createViewWithChildren(createHostPv([
-             createNestedElBinder(createComponentPv([
-               createNestedElBinder(createEmbeddedPv(
-                   [createNestedElBinder(createComponentPv([createEmptyElBinder()]))]))
-             ]))
-           ]));
-
-           utils.hydrateRootHostView(hostView, createInjector());
-           expect(hostView.elementInjectors.length).toBe(4);
-           expect((<any>hostView.elementInjectors[3]).spy('hydrate')).not.toHaveBeenCalled();
-         });
-
-
-    });
-
-    describe('attachViewInContainer', () => {
-      var parentView, contextView, childView;
-
-      function createViews(numInj = 1) {
-        var childPv = createEmbeddedPv([createEmptyElBinder()]);
-        childView = createViewWithChildren(childPv);
-
-        var parentPv = createHostPv([createEmptyElBinder()]);
-        parentView = createViewWithChildren(parentPv);
-
-        var binders = [];
-        for (var i = 0; i < numInj; i++) {
-          binders.push(createEmptyElBinder(i > 0 ? binders[i - 1] : null))
-        }
-        var contextPv = createHostPv(binders);
-        contextView = createViewWithChildren(contextPv);
-      }
-
-      it('should not modify the rootElementInjectors at the given context view', () => {
-        createViews();
-        utils.attachViewInContainer(parentView, 0, contextView, 0, 0, childView);
-        expect(contextView.rootElementInjectors.length).toEqual(1);
-      });
-
-      it('should link the views rootElementInjectors after the elementInjector at the given context',
-         () => {
-           createViews(2);
-           utils.attachViewInContainer(parentView, 0, contextView, 1, 0, childView);
-           expect(childView.rootElementInjectors[0].spy('link'))
-               .toHaveBeenCalledWith(contextView.elementInjectors[0]);
-         });
-    });
-
-    describe('hydrateViewInContainer', () => {
-      var parentView, contextView, childView;
-
-      function createViews() {
-        var parentPv = createHostPv([createEmptyElBinder()]);
-        parentView = createViewWithChildren(parentPv);
-
-        var contextPv = createHostPv([createEmptyElBinder()]);
-        contextView = createViewWithChildren(contextPv);
-
-        var childPv = createEmbeddedPv([createEmptyElBinder()]);
-        childView = createViewWithChildren(childPv);
-        utils.attachViewInContainer(parentView, 0, contextView, 0, 0, childView);
-      }
-
-      it("should instantiate the elementInjectors with the host of the context's elementInjector",
-         () => {
-           createViews();
-
-           utils.hydrateViewInContainer(parentView, 0, contextView, 0, 0, null);
-           expect(childView.rootElementInjectors[0].spy('hydrate'))
-               .toHaveBeenCalledWith(null, contextView.elementInjectors[0].getHost(),
-                                     childView.preBuiltObjects[0]);
-         });
-    });
-
-    describe('hydrateRootHostView', () => {
-      var hostView;
-
-      function createViews() {
-        var hostPv = createHostPv([createNestedElBinder(createComponentPv())]);
-        hostView = createViewWithChildren(hostPv);
-      }
-
-      it("should instantiate the elementInjectors with the given injector and an empty host element injector",
-         () => {
-           var injector = createInjector();
-           createViews();
-
-           utils.hydrateRootHostView(hostView, injector);
-           expect(hostView.rootElementInjectors[0].spy('hydrate'))
-               .toHaveBeenCalledWith(injector, null, hostView.preBuiltObjects[0]);
-         });
-
-    });
-
-  });
-}
-
-
-export function createInjector() {
-  return Injector.resolveAndCreate([]);
-}
-
-function createElementInjector(parent = null) {
-  var host = new SpyElementInjector();
-  var elementInjector = new SpyElementInjector();
-  var _preBuiltObjects = null;
-  var res = SpyObject.stub(elementInjector, {
-    'isExportingComponent': false,
-    'isExportingElement': false,
-    'getEventEmitterAccessors': [],
-    'getHostActionAccessors': [],
-    'getComponent': new Object(),
-    'getHost': host
-  });
-  res.spy('getNestedView').andCallFake(() => _preBuiltObjects.nestedView);
-  res.spy('hydrate')
-      .andCallFake((mperativelyCreatedInjector: Injector, host: ElementInjector,
-                    preBuiltObjects: PreBuiltObjects) => { _preBuiltObjects = preBuiltObjects; });
-  res.prop('parent', parent);
-  return res;
-}
-
-export function createProtoElInjector(parent: ProtoElementInjector = null): ProtoElementInjector {
-  var pei = new SpyProtoElementInjector();
-  pei.prop("parent", parent);
-  pei.prop("index", 0);
-  pei.spy('instantiate').andCallFake((parentEli) => createElementInjector(parentEli));
-  return <any>pei;
-}
-
-export function createEmptyElBinder(parent: ElementBinder = null) {
-  var parentPeli = isPresent(parent) ? parent.protoElementInjector : null;
-  return new ElementBinder(0, null, 0, createProtoElInjector(parentPeli), null, null);
-}
-
-export function createNestedElBinder(nestedProtoView: AppProtoView) {
-  var componentProvider = null;
-  if (nestedProtoView.type === ViewType.COMPONENT) {
-    var annotation = new DirectiveResolver().resolve(SomeComponent);
-    componentProvider = DirectiveProvider.createFromType(SomeComponent, annotation);
-  }
-  return new ElementBinder(0, null, 0, createProtoElInjector(), componentProvider, nestedProtoView);
-}
-
-function _createProtoView(type: ViewType, binders: ElementBinder[] = null) {
-  if (isBlank(binders)) {
-    binders = [];
-  }
-  var res = new AppProtoView(null, [], type, true, (_) => new SpyChangeDetector(),
-                             new Map<string, any>(), null);
-  var mergedElementCount = 0;
-  var mergedEmbeddedViewCount = 0;
-  var mergedViewCount = 1;
-  for (var i = 0; i < binders.length; i++) {
-    var binder = binders[i];
-    binder.protoElementInjector.index = i;
-    mergedElementCount++;
-    var nestedPv = binder.nestedProtoView;
-    if (isPresent(nestedPv)) {
-      mergedElementCount += nestedPv.mergeInfo.elementCount;
-      mergedEmbeddedViewCount += nestedPv.mergeInfo.embeddedViewCount;
-      mergedViewCount += nestedPv.mergeInfo.viewCount;
-      if (nestedPv.type === ViewType.EMBEDDED) {
-        mergedEmbeddedViewCount++;
-      }
-    }
-  }
-  var mergeInfo =
-      new AppProtoViewMergeInfo(mergedEmbeddedViewCount, mergedElementCount, mergedViewCount);
-  res.init(null, binders, 0, mergeInfo, new Map<string, number>());
-  return res;
-}
-
-export function createHostPv(binders: ElementBinder[] = null) {
-  return _createProtoView(ViewType.HOST, binders);
-}
-
-export function createComponentPv(binders: ElementBinder[] = null) {
-  return _createProtoView(ViewType.COMPONENT, binders);
-}
-
-export function createEmbeddedPv(binders: ElementBinder[] = null) {
-  return _createProtoView(ViewType.EMBEDDED, binders);
-}
-
-
-@Component({selector: 'someComponent'})
-class SomeComponent {
-}
diff --git a/modules/angular2/test/core/linker/view_pool_spec.ts b/modules/angular2/test/core/linker/view_pool_spec.ts
deleted file mode 100644
index 7bb7370..0000000
--- a/modules/angular2/test/core/linker/view_pool_spec.ts
+++ /dev/null
@@ -1,74 +0,0 @@
-import {
-  AsyncTestCompleter,
-  beforeEach,
-  ddescribe,
-  xdescribe,
-  describe,
-  el,
-  dispatchEvent,
-  expect,
-  iit,
-  inject,
-  beforeEachProviders,
-  it,
-  xit,
-  SpyObject,
-  proxy
-} from 'angular2/testing_internal';
-import {AppViewPool} from 'angular2/src/core/linker/view_pool';
-import {AppProtoView, AppView} from 'angular2/src/core/linker/view';
-import {MapWrapper, Map} from 'angular2/src/facade/collection';
-
-export function main() {
-  describe('AppViewPool', () => {
-
-    function createViewPool({capacity}): AppViewPool { return new AppViewPool(capacity); }
-
-    function createProtoView() {
-      return new AppProtoView(null, null, null, null, null, null, null);
-    }
-
-    function createView(pv) {
-      return new AppView(null, pv, null, null, null, new Map<string, any>(), null, null, null);
-    }
-
-    it('should support multiple AppProtoViews', () => {
-      var vf = createViewPool({capacity: 2});
-      var pv1 = createProtoView();
-      var pv2 = createProtoView();
-      var view1 = createView(pv1);
-      var view2 = createView(pv2);
-      vf.returnView(view1);
-      vf.returnView(view2);
-
-      expect(vf.getView(pv1)).toBe(view1);
-      expect(vf.getView(pv2)).toBe(view2);
-    });
-
-    it('should reuse the newest view that has been returned', () => {
-      var pv = createProtoView();
-      var vf = createViewPool({capacity: 2});
-      var view1 = createView(pv);
-      var view2 = createView(pv);
-      vf.returnView(view1);
-      vf.returnView(view2);
-
-      expect(vf.getView(pv)).toBe(view2);
-    });
-
-    it('should not add views when the capacity has been reached', () => {
-      var pv = createProtoView();
-      var vf = createViewPool({capacity: 2});
-      var view1 = createView(pv);
-      var view2 = createView(pv);
-      var view3 = createView(pv);
-      expect(vf.returnView(view1)).toBe(true);
-      expect(vf.returnView(view2)).toBe(true);
-      expect(vf.returnView(view3)).toBe(false);
-
-      expect(vf.getView(pv)).toBe(view2);
-      expect(vf.getView(pv)).toBe(view1);
-    });
-
-  });
-}
diff --git a/modules/angular2/test/core/render/view_factory_spec.ts b/modules/angular2/test/core/render/view_factory_spec.ts
deleted file mode 100644
index 4e3e69e..0000000
--- a/modules/angular2/test/core/render/view_factory_spec.ts
+++ /dev/null
@@ -1,740 +0,0 @@
-import {
-  AsyncTestCompleter,
-  beforeEach,
-  ddescribe,
-  describe,
-  expect,
-  iit,
-  inject,
-  it,
-  xit,
-  stringifyElement
-} from 'angular2/testing_internal';
-
-import {isPresent} from 'angular2/src/facade/lang';
-import {MapWrapper, ListWrapper} from 'angular2/src/facade/collection';
-import * as appCmds from 'angular2/src/core/linker/template_commands';
-import {
-  createRenderView,
-  encapsulateStyles,
-  NodeFactory
-} from 'angular2/src/core/render/view_factory';
-import {
-  RenderTemplateCmd,
-  RenderBeginElementCmd,
-  RenderComponentTemplate
-} from 'angular2/src/core/render/api';
-import {SpyRenderEventDispatcher} from '../spies';
-import {DOM} from 'angular2/src/platform/dom/dom_adapter';
-import {ViewEncapsulation} from 'angular2/src/core/metadata';
-
-function beginElement(name: string, attrNameAndValues: string[], eventTargetAndNames: string[],
-                      isBound: boolean, ngContentIndex: number): RenderBeginElementCmd {
-  return new appCmds.BeginElementCmd(name, attrNameAndValues, eventTargetAndNames, [], [], isBound,
-                                     ngContentIndex)
-}
-
-function endElement() {
-  return new appCmds.EndElementCmd();
-}
-
-function text(value: string, isBound: boolean, ngContentIndex: number) {
-  return new appCmds.TextCmd(value, isBound, ngContentIndex);
-}
-
-function embeddedTemplate(attrNameAndValues: string[], isMerged: boolean, ngContentIndex: number,
-                          children: any[]) {
-  return new appCmds.EmbeddedTemplateCmd(attrNameAndValues, [], [], isMerged, ngContentIndex, null,
-                                         children);
-}
-
-function beginComponent(name: string, attrNameAndValues: string[], eventTargetAndNames: string[],
-                        ngContentIndex: number, templateId: string) {
-  return new appCmds.BeginComponentCmd(
-      name, attrNameAndValues, eventTargetAndNames, [], [], null, ngContentIndex,
-      () => new appCmds.CompiledComponentTemplate(templateId, null, null, null));
-}
-
-function endComponent() {
-  return new appCmds.EndComponentCmd();
-}
-
-function ngContent(index: number, ngContentIndex: number) {
-  return new appCmds.NgContentCmd(index, ngContentIndex);
-}
-
-export function main() {
-  describe('createRenderView', () => {
-    var nodeFactory: DomNodeFactory;
-    var eventDispatcher: SpyRenderEventDispatcher;
-    var componentTemplates = new Map<string, RenderComponentTemplate | RenderTemplateCmd[]>();
-    var defaultCmpTpl: RenderComponentTemplate;
-
-    beforeEach(() => {
-      nodeFactory = new DomNodeFactory(componentTemplates);
-      eventDispatcher = new SpyRenderEventDispatcher();
-      defaultCmpTpl =
-          new RenderComponentTemplate('someId', 'shortid', ViewEncapsulation.None, [], []);
-    });
-
-    describe('primitives', () => {
-
-      it('should create elements with attributes', () => {
-        var view = createRenderView(
-            defaultCmpTpl,
-            [beginElement('div', ['attr1', 'value1'], [], false, null), endElement()], null,
-            nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes)).toEqual('<div attr1="value1"></div>');
-      });
-
-      it('should create host elements with attributes', () => {
-        componentTemplates.set('0', []);
-        var view = createRenderView(
-            defaultCmpTpl,
-            [beginComponent('a-comp', ['attr1', 'value1'], [], null, '0'), endElement()], null,
-            nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes))
-            .toEqual('<a-comp attr1="value1"></a-comp>');
-      });
-
-      it('should create embedded templates with attributes', () => {
-        componentTemplates.set('0', []);
-        var view = createRenderView(defaultCmpTpl,
-                                    [embeddedTemplate(['attr1', 'value1'], false, null, [])], null,
-                                    nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes))
-            .toEqual('<template attr1="value1"></template>');
-      });
-
-      it('should store bound elements', () => {
-        componentTemplates.set('0', []);
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginElement('div', ['id', '1'], [], false, null),
-                                      endElement(),
-                                      beginElement('span', ['id', '2'], [], true, null),
-                                      endElement(),
-                                      beginComponent('a-comp', ['id', '3'], [], null, '0'),
-                                      endElement(),
-                                      embeddedTemplate(['id', '4'], false, null, [])
-                                    ],
-                                    null, nodeFactory);
-        expect(mapAttrs(view.boundElements, 'id')).toEqual(['2', '3', '4']);
-      });
-
-      it('should use the inplace element for the first create element', () => {
-        var el = DOM.createElement('span');
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginElement('div', ['attr1', 'value1'], [], false, null),
-                                      endElement(),
-                                      beginElement('div', [], [], false, null),
-                                      endElement()
-                                    ],
-                                    el, nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes))
-            .toEqual('<span attr1="value1"></span><div></div>');
-      });
-
-      it('should create text nodes', () => {
-        var view =
-            createRenderView(defaultCmpTpl, [text('someText', false, null)], null, nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes)).toEqual('someText');
-      });
-
-      it('should store bound text nodes', () => {
-        var view = createRenderView(defaultCmpTpl, [text('1', false, null), text('2', true, null)],
-                                    null, nodeFactory);
-        expect(stringifyElement(view.boundTextNodes[0])).toEqual('2');
-      });
-
-      it('should register element event listeners', () => {
-        componentTemplates.set('0', []);
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginElement('div', [], [null, 'click'], true, null),
-                                      endElement(),
-                                      beginComponent('a-comp', [], [null, 'click'], null, '0'),
-                                      endElement(),
-                                    ],
-                                    null, nodeFactory);
-        view.setEventDispatcher(<any>eventDispatcher);
-        var event = {};
-        nodeFactory.triggerLocalEvent(view.boundElements[0], 'click', event);
-        nodeFactory.triggerLocalEvent(view.boundElements[1], 'click', event);
-        expect(eventDispatcher.spy('dispatchRenderEvent'))
-            .toHaveBeenCalledWith(0, 'click', MapWrapper.createFromStringMap({'$event': event}));
-        expect(eventDispatcher.spy('dispatchRenderEvent'))
-            .toHaveBeenCalledWith(1, 'click', MapWrapper.createFromStringMap({'$event': event}));
-      });
-
-      it('should register element global event listeners', () => {
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginElement('div', [], ['window', 'scroll'], true, null),
-                                      endElement(),
-                                      beginComponent('a-comp', [], ['window', 'scroll'], null, '0'),
-                                      endElement(),
-                                    ],
-                                    null, nodeFactory);
-        view.hydrate();
-        view.setEventDispatcher(<any>eventDispatcher);
-        var event = {};
-        nodeFactory.triggerGlobalEvent('window', 'scroll', event);
-        expect(eventDispatcher.spy('dispatchRenderEvent'))
-            .toHaveBeenCalledWith(0, 'window:scroll',
-                                  MapWrapper.createFromStringMap({'$event': event}));
-        expect(eventDispatcher.spy('dispatchRenderEvent'))
-            .toHaveBeenCalledWith(1, 'window:scroll',
-                                  MapWrapper.createFromStringMap({'$event': event}));
-      });
-
-    });
-
-    describe('nested nodes', () => {
-      it('should create nested node', () => {
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginElement('a', [], [], false, null),
-                                      beginElement('b', [], [], false, null),
-                                      text('someText', false, null),
-                                      endElement(),
-                                      endElement(),
-                                    ],
-                                    null, nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes)).toEqual('<a><b>someText</b></a>');
-      });
-
-      it('should store bound elements in depth first order', () => {
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginElement('a', ['id', '1'], [], false, null),
-                                      endElement(),
-                                      beginElement('a', ['id', '2'], [], true, null),
-                                      beginElement('a', ['id', '3'], [], false, null),
-                                      endElement(),
-                                      beginElement('a', ['id', '4'], [], true, null),
-                                      endElement(),
-                                      endElement(),
-                                      beginElement('a', ['id', '5'], [], false, null),
-                                      endElement(),
-                                      beginElement('a', ['id', '6'], [], true, null),
-                                      endElement(),
-                                    ],
-                                    null, nodeFactory);
-        expect(mapAttrs(view.boundElements, 'id')).toEqual(['2', '4', '6']);
-      });
-
-      it('should store bound text nodes in depth first order', () => {
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      text('1', false, null),
-                                      text('2', true, null),
-                                      beginElement('a', [], [], false, null),
-                                      text('3', false, null),
-                                      text('4', true, null),
-                                      endElement(),
-                                      text('5', false, null),
-                                      text('6', true, null),
-                                    ],
-                                    null, nodeFactory);
-        expect(mapText(view.boundTextNodes)).toEqual(['2', '4', '6']);
-      });
-    });
-
-    describe('merged embedded templates',
-             () => {
-               it('should create separate fragments', () => {
-                 var view = createRenderView(defaultCmpTpl,
-                                             [
-                                               embeddedTemplate(['attr1', 'value1'], true, null,
-                                                                [text('someText', false, null)])
-                                             ],
-                                             null, nodeFactory);
-                 expect(view.fragments.length).toBe(2);
-                 expect(stringifyFragment(view.fragments[1].nodes)).toEqual('someText');
-               });
-
-               it('should store bound elements after the bound elements of earlier fragments',
-                  () => {
-                    var view =
-            createRenderView(defaultCmpTpl,
-                [
-                  beginElement('a', ['id', '1.1'], [], true, null),
-                  endElement(),
-                  embeddedTemplate(['id', '1.2'], true, null,
-                                   [
-                                     embeddedTemplate(['id', '2.1'], true, null,
-                                                      [
-                                                        beginElement('a', ['id', '3.1'],
-                                                                     [], true, null),
-                                                        endElement()
-                                                      ]),
-                                     beginElement('a', ['id', '2.2'], [], true, null),
-                                     endElement(),
-                                   ]),
-                  beginElement('a', ['id', '1.3'], [], true, null),
-                  endElement(),
-                ],
-                null, nodeFactory);
-                    expect(mapAttrs(view.boundElements, 'id'))
-                        .toEqual(['1.1', '1.2', '1.3', '2.1', '2.2', '3.1']);
-                  });
-
-               it('should store bound text nodes after the bound text nodes of earlier fragments',
-                  () => {
-                    var view =
-            createRenderView(defaultCmpTpl,
-                [
-                  text('1.1', true, null),
-                  embeddedTemplate(['id', '1.2'], true, null,
-                                   [
-                                     text('2.1', true, null),
-                                     embeddedTemplate(['id', '2.1'], true, null,
-                                                      [
-                                                        text('3.1', true, null),
-                                                      ]),
-                                     text('2.2', true, null),
-                                   ]),
-                  text('1.2', true, null),
-                ],
-                null, nodeFactory);
-                    expect(mapText(view.boundTextNodes))
-                        .toEqual(['1.1', '1.2', '2.1', '2.2', '3.1']);
-                  });
-
-             });
-
-    describe('non merged embedded templates', () => {
-      it('should only create the anchor element', () => {
-        var view =
-            createRenderView(defaultCmpTpl,
-                             [
-                               embeddedTemplate(['id', '1.1'], false, null,
-                                                [
-                                                  text('someText', true, null),
-                                                  beginElement('a', ['id', '2.1'], [], true, null),
-                                                  endElement()
-                                                ])
-                             ],
-                             null, nodeFactory);
-        expect(view.fragments.length).toBe(1);
-        expect(stringifyFragment(view.fragments[0].nodes))
-            .toEqual('<template id="1.1"></template>');
-        expect(view.boundTextNodes.length).toBe(0);
-        expect(mapAttrs(view.boundElements, 'id')).toEqual(['1.1']);
-      });
-    });
-
-    describe('components', () => {
-      it('should store the component template in the same fragment', () => {
-        componentTemplates.set('0', [
-          text('hello', false, null),
-        ]);
-        var view = createRenderView(defaultCmpTpl,
-                                    [beginComponent('my-comp', [], [], null, '0'), endComponent()],
-                                    null, nodeFactory);
-        expect(view.fragments.length).toBe(1);
-        expect(stringifyFragment(view.fragments[0].nodes)).toEqual('<my-comp>hello</my-comp>');
-      });
-
-      it('should use native shadow DOM', () => {
-        componentTemplates.set(
-            '0', new RenderComponentTemplate('someId', 'shortid', ViewEncapsulation.Native,
-                                             [
-                                               text('hello', false, null),
-                                             ],
-                                             []));
-        var view = createRenderView(defaultCmpTpl,
-                                    [beginComponent('my-comp', [], [], null, '0'), endComponent()],
-                                    null, nodeFactory);
-        expect(view.fragments.length).toBe(1);
-        expect(stringifyFragment(view.fragments[0].nodes))
-            .toEqual('<my-comp><shadow-root>hello</shadow-root></my-comp>');
-      });
-
-      it('should store bound elements after the bound elements of the main template', () => {
-        componentTemplates.set('0', [
-          beginComponent('b-comp', ['id', '2.1'], [], null, '1'),
-          endComponent(),
-          beginComponent('b-comp', ['id', '2.2'], [], null, '1'),
-          endComponent(),
-        ]);
-        componentTemplates.set('1',
-                               [beginElement('a', ['id', '3.1'], [], true, null), endElement()]);
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginElement('a', ['id', '1.1'], [], true, null),
-                                      endElement(),
-                                      beginComponent('a-comp', ['id', '1.2'], [], null, '0'),
-                                      beginElement('a', ['id', '1.3'], [], true, null),
-                                      endElement(),
-                                      endComponent(),
-                                      beginElement('a', ['id', '1.4'], [], true, null),
-                                      endElement(),
-                                    ],
-                                    null, nodeFactory);
-
-        expect(mapAttrs(view.boundElements, 'id'))
-            .toEqual(['1.1', '1.2', '1.3', '1.4', '2.1', '2.2', '3.1', '3.1']);
-      });
-
-      it('should store bound elements from the view before bound elements from content components',
-         () => {
-           componentTemplates.set('0', [
-             beginElement('a', ['id', '2.1'], [], true, null),
-             endElement(),
-           ]);
-           componentTemplates.set('1', [
-             beginElement('a', ['id', '3.1'], [], true, null),
-             endElement(),
-           ]);
-           var view = createRenderView(defaultCmpTpl,
-                                       [
-                                         beginComponent('a-comp', ['id', '1.1'], [], null, '0'),
-                                         beginComponent('b-comp', ['id', '1.2'], [], null, '1'),
-                                         endComponent(),
-                                         endComponent(),
-                                       ],
-                                       null, nodeFactory);
-
-           expect(mapAttrs(view.boundElements, 'id')).toEqual(['1.1', '1.2', '2.1', '3.1']);
-         });
-
-      it('should process nested components in depth first order', () => {
-        componentTemplates.set('0', [
-          beginComponent('b11-comp', ['id', '2.1'], [], null, '2'),
-          endComponent(),
-          beginComponent('b12-comp', ['id', '2.2'], [], null, '3'),
-          endComponent(),
-        ]);
-        componentTemplates.set('1', [
-          beginComponent('b21-comp', ['id', '3.1'], [], null, '4'),
-          endComponent(),
-          beginComponent('b22-comp', ['id', '3.2'], [], null, '5'),
-          endComponent(),
-        ]);
-        componentTemplates.set('2', [
-          beginElement('b11', ['id', '4.11'], [], true, null),
-          endElement(),
-        ]);
-        componentTemplates.set('3', [
-          beginElement('b12', ['id', '4.12'], [], true, null),
-          endElement(),
-        ]);
-        componentTemplates.set('4', [
-          beginElement('b21', ['id', '4.21'], [], true, null),
-          endElement(),
-        ]);
-        componentTemplates.set('5', [
-          beginElement('b22', ['id', '4.22'], [], true, null),
-          endElement(),
-        ]);
-
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginComponent('a1-comp', ['id', '1.1'], [], null, '0'),
-                                      endComponent(),
-                                      beginComponent('a2-comp', ['id', '1.2'], [], null, '1'),
-                                      endComponent(),
-                                    ],
-                                    null, nodeFactory);
-
-        expect(mapAttrs(view.boundElements, 'id'))
-            .toEqual(['1.1', '1.2', '2.1', '2.2', '4.11', '4.12', '3.1', '3.2', '4.21', '4.22']);
-      });
-
-
-      it('should store bound text nodes after the bound text nodes of the main template', () => {
-        componentTemplates.set('0', [
-          text('2.1', true, null),
-          beginComponent('b-comp', [], [], null, '1'),
-          endComponent(),
-          beginComponent('b-comp', [], [], null, '1'),
-          endComponent(),
-          text('2.2', true, null),
-        ]);
-        componentTemplates.set('1', [
-          text('3.1', true, null),
-        ]);
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      text('1.1', true, null),
-                                      beginComponent('a-comp', [], [], null, '0'),
-                                      text('1.2', true, null),
-                                      endComponent(),
-                                      text('1.3', true, null),
-                                    ],
-                                    null, nodeFactory);
-
-        expect(mapText(view.boundTextNodes))
-            .toEqual(['1.1', '1.2', '1.3', '2.1', '2.2', '3.1', '3.1']);
-      });
-    });
-
-    it('should store bound text nodes from the view before bound text nodes from content components',
-       () => {
-         componentTemplates.set('0', [text('2.1', true, null)]);
-         componentTemplates.set('1', [text('3.1', true, null)]);
-         var view = createRenderView(defaultCmpTpl,
-                                     [
-                                       beginComponent('a-comp', [], [], null, '0'),
-                                       beginComponent('b-comp', [], [], null, '1'),
-                                       endComponent(),
-                                       endComponent(),
-                                     ],
-                                     null, nodeFactory);
-
-         expect(mapText(view.boundTextNodes)).toEqual(['2.1', '3.1']);
-       });
-
-    describe('content projection', () => {
-      it('should remove non projected nodes', () => {
-        componentTemplates.set('0', []);
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginComponent('my-comp', [], [], null, '0'),
-                                      text('hello', false, null),
-                                      endComponent()
-                                    ],
-                                    null, nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes)).toEqual('<my-comp></my-comp>');
-      });
-
-      it('should keep non projected nodes in the light dom when using native shadow dom', () => {
-        componentTemplates.set('0', new RenderComponentTemplate('someId', 'shortid',
-                                                                ViewEncapsulation.Native, [], []));
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginComponent('my-comp', [], [], null, '0'),
-                                      text('hello', false, null),
-                                      endComponent()
-                                    ],
-                                    null, nodeFactory);
-        var rootEl = view.fragments[0].nodes[0];
-        expect(stringifyElement(rootEl))
-            .toEqual('<my-comp><shadow-root></shadow-root>hello</my-comp>');
-      });
-
-      it('should project commands based on their ngContentIndex', () => {
-        componentTemplates.set('0', [
-          text('(', false, null),
-          ngContent(0, null),
-          text(',', false, null),
-          ngContent(1, null),
-          text(')', false, null)
-        ]);
-        var view = createRenderView(defaultCmpTpl,
-                                    [
-                                      beginComponent('my-comp', [], [], null, '0'),
-                                      text('2', false, 1),
-                                      text('1', false, 0),
-                                      endComponent()
-                                    ],
-                                    null, nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes)).toEqual('<my-comp>(1,2)</my-comp>');
-      });
-
-      it('should reproject nodes over multiple ng-content commands', () => {
-        componentTemplates.set(
-            '0', [beginComponent('b-comp', [], [], null, '1'), ngContent(0, 0), endComponent()]);
-        componentTemplates.set(
-            '1', [text('(', false, null), ngContent(0, null), text(')', false, null)]);
-        var view = createRenderView(
-            defaultCmpTpl,
-            [beginComponent('a-comp', [], [], null, '0'), text('hello', false, 0), endComponent()],
-            null, nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes))
-            .toEqual('<a-comp><b-comp>(hello)</b-comp></a-comp>');
-      });
-
-
-      it('should store content injection points for root component in a view', () => {
-        componentTemplates.set('0', [ngContent(0, null)]);
-        var view = createRenderView(defaultCmpTpl,
-                                    [beginComponent('a-comp', [], [], null, '0'), endComponent()],
-                                    DOM.createElement('root'), nodeFactory);
-        expect(stringifyFragment(view.rootContentInsertionPoints))
-            .toEqual('<root-content-insertion-point></root-content-insertion-point>');
-      });
-    });
-
-    describe('view encapsulation', () => {
-      it('should not add attributes to elements in template with ViewEncapsulation.None', () => {
-        var tpl = new RenderComponentTemplate('someId', 'shortid', ViewEncapsulation.None, [], []);
-        var view = createRenderView(tpl, [beginElement('div', [], [], false, null), endElement()],
-                                    null, nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes)).toEqual('<div></div>');
-      });
-
-      it('should not add attributes to elements in template with ViewEncapsulation.Native', () => {
-        var tpl =
-            new RenderComponentTemplate('someId', 'shortid', ViewEncapsulation.Native, [], []);
-        var view = createRenderView(tpl, [beginElement('div', [], [], false, null), endElement()],
-                                    null, nodeFactory);
-        expect(stringifyFragment(view.fragments[0].nodes)).toEqual('<div></div>');
-      });
-
-      describe('ViewEncapsulation.Emulated', () => {
-        var encapsulatedTpl;
-
-        beforeEach(() => {
-          encapsulatedTpl =
-              new RenderComponentTemplate('someId', 'shortid', ViewEncapsulation.Emulated, [], []);
-        });
-
-        it('should add marker attributes to content elements', () => {
-          var view = createRenderView(encapsulatedTpl,
-                                      [beginElement('div', [], [], false, null), endElement()],
-                                      null, nodeFactory);
-          expect(stringifyFragment(view.fragments[0].nodes))
-              .toEqual('<div _ngcontent-shortid=""></div>');
-        });
-
-        it('should add marker attributes to content elements in merged embedded templates', () => {
-          var view = createRenderView(
-              encapsulatedTpl,
-              [
-                embeddedTemplate([], true, null,
-                                 [beginElement('div', [], [], false, null), endElement()])
-              ],
-              null, nodeFactory);
-          expect(stringifyFragment(view.fragments[0].nodes)).toEqual('<template></template>');
-          expect(stringifyFragment(view.fragments[1].nodes))
-              .toEqual('<div _ngcontent-shortid=""></div>');
-        });
-
-        it('should add marker attributes to host elements and content elements of nested components',
-           () => {
-             componentTemplates.set(
-                 '0', new RenderComponentTemplate(
-                          'innerComp', 'innerid', ViewEncapsulation.Emulated,
-                          [beginElement('div', [], [], false, null), endElement()], []));
-             var view = createRenderView(
-                 defaultCmpTpl, [beginComponent('my-comp', [], [], null, '0'), endComponent()],
-                 null, nodeFactory);
-             expect(stringifyFragment(view.fragments[0].nodes))
-                 .toEqual(
-                     '<my-comp _nghost-innerid=""><div _ngcontent-innerid=""></div></my-comp>');
-           });
-      });
-    });
-  });
-
-  describe('encapsulateStyles', () => {
-    const input = 'div[%COMP%] {}';
-
-    it('should not change styles for ViewEncapsulation.Native', () => {
-      var tpl =
-          new RenderComponentTemplate('someId', 'shortid', ViewEncapsulation.Native, [], [input]);
-      expect(encapsulateStyles(tpl)).toEqual([input]);
-    });
-
-    it('should not change styles for ViewEncapsulation.None', () => {
-      var tpl =
-          new RenderComponentTemplate('someId', 'shortid', ViewEncapsulation.None, [], [input]);
-      expect(encapsulateStyles(tpl)).toEqual([input]);
-    });
-
-    it('should change styles for ViewEncapsulation.Emulated', () => {
-      var tpl =
-          new RenderComponentTemplate('someId', 'shortid', ViewEncapsulation.Emulated, [], [input]);
-      expect(encapsulateStyles(tpl)).toEqual(['div[shortid] {}']);
-    });
-  });
-}
-
-class DomNodeFactory implements NodeFactory<Node> {
-  private _globalEventListeners: GlobalEventListener[] = [];
-  private _localEventListeners: LocalEventListener[] = [];
-
-  constructor(private _components: Map<string, RenderComponentTemplate | RenderTemplateCmd[]>) {}
-
-  triggerLocalEvent(el: Element, eventName: string, event: any) {
-    this._localEventListeners.forEach(listener => {
-      if (listener.eventName == eventName) {
-        listener.callback(event);
-      }
-    });
-  }
-
-  triggerGlobalEvent(target: string, eventName: string, event: any) {
-    this._globalEventListeners.forEach(listener => {
-      if (listener.eventName == eventName && listener.target == target) {
-        listener.callback(event);
-      }
-    });
-  }
-
-  resolveComponentTemplate(templateId: string): RenderComponentTemplate {
-    var data = this._components.get(templateId);
-    if (data instanceof RenderComponentTemplate) {
-      return data;
-    } else {
-      return new RenderComponentTemplate(templateId, templateId, ViewEncapsulation.None,
-                                         <RenderTemplateCmd[]>data, []);
-    }
-  }
-  createTemplateAnchor(attrNameAndValues: string[]): Node {
-    var el = DOM.createElement('template');
-    this._setAttributes(el, attrNameAndValues);
-    return el;
-  }
-  createElement(name: string, attrNameAndValues: string[]): Node {
-    var el = DOM.createElement(name);
-    this._setAttributes(el, attrNameAndValues);
-    return el;
-  }
-  mergeElement(existing: Node, attrNameAndValues: string[]) {
-    DOM.clearNodes(existing);
-    this._setAttributes(existing, attrNameAndValues);
-  }
-  private _setAttributes(el: Node, attrNameAndValues: string[]) {
-    for (var attrIdx = 0; attrIdx < attrNameAndValues.length; attrIdx += 2) {
-      DOM.setAttribute(el, attrNameAndValues[attrIdx], attrNameAndValues[attrIdx + 1]);
-    }
-  }
-  createShadowRoot(host: Node, templateId: string): Node {
-    var root = DOM.createElement('shadow-root');
-    DOM.appendChild(host, root);
-    return root;
-  }
-  createText(value: string): Node { return DOM.createTextNode(isPresent(value) ? value : ''); }
-  createRootContentInsertionPoint(): Node {
-    return DOM.createElement('root-content-insertion-point');
-  }
-  appendChild(parent: Node, child: Node) { DOM.appendChild(parent, child); }
-  on(element: Node, eventName: string, callback: Function) {
-    this._localEventListeners.push(new LocalEventListener(element, eventName, callback));
-  }
-  globalOn(target: string, eventName: string, callback: Function): Function {
-    var listener = new GlobalEventListener(target, eventName, callback);
-    this._globalEventListeners.push(listener);
-    return () => {
-      var index = this._globalEventListeners.indexOf(listener);
-      if (index !== -1) {
-        this._globalEventListeners.splice(index, 1);
-      }
-    }
-  }
-}
-
-class LocalEventListener {
-  constructor(public element: Node, public eventName: string, public callback: Function) {}
-}
-
-class GlobalEventListener {
-  constructor(public target: string, public eventName: string, public callback: Function) {}
-}
-
-function stringifyFragment(nodes: Node[]) {
-  return nodes.map(stringifyElement).join('');
-}
-
-function mapAttrs(nodes: Node[], attrName): string[] {
-  return nodes.map(node => DOM.getAttribute(node, attrName));
-}
-
-function mapText(nodes: Node[]): string[] {
-  return nodes.map(node => DOM.getText(node));
-}
diff --git a/modules/angular2/test/core/render/view_spec.ts b/modules/angular2/test/core/render/view_spec.ts
deleted file mode 100644
index ca5ae06..0000000
--- a/modules/angular2/test/core/render/view_spec.ts
+++ /dev/null
@@ -1,38 +0,0 @@
-import {
-  AsyncTestCompleter,
-  beforeEach,
-  ddescribe,
-  describe,
-  expect,
-  iit,
-  inject,
-  it,
-  xit
-} from 'angular2/testing_internal';
-
-import {DefaultRenderView} from 'angular2/src/core/render/view';
-
-export function main() {
-  describe('DefaultRenderView', () => {
-    describe('hydrate', () => {
-      it('should register global event listeners', () => {
-        var addCount = 0;
-        var adder = () => { addCount++ };
-        var view = new DefaultRenderView<Node>([], [], [], [], [adder], []);
-        view.hydrate();
-        expect(addCount).toBe(1);
-      });
-    });
-
-    describe('dehydrate', () => {
-      it('should deregister global event listeners', () => {
-        var removeCount = 0;
-        var adder = () => () => { removeCount++ };
-        var view = new DefaultRenderView<Node>([], [], [], [], [adder], []);
-        view.hydrate();
-        view.dehydrate();
-        expect(removeCount).toBe(1);
-      });
-    });
-  });
-}
diff --git a/modules/angular2/test/core/spies.dart b/modules/angular2/test/core/spies.dart
index 4ea88e6..1b74e89 100644
--- a/modules/angular2/test/core/spies.dart
+++ b/modules/angular2/test/core/spies.dart
@@ -8,10 +8,7 @@ import 'package:angular2/src/core/linker/directive_resolver.dart';
 import 'package:angular2/src/core/linker/view.dart';
 import 'package:angular2/src/core/linker/element_ref.dart';
 import 'package:angular2/src/core/linker/view_manager.dart';
-import 'package:angular2/src/core/linker/proto_view_factory.dart';
-import 'package:angular2/src/core/linker/view_pool.dart';
 import 'package:angular2/src/core/linker/view_listener.dart';
-import 'package:angular2/src/core/linker/element_injector.dart';
 import 'package:angular2/src/platform/dom/dom_adapter.dart';
 import 'package:angular2/testing_internal.dart';
 
@@ -52,48 +49,37 @@ class SpyView extends SpyObject implements AppView {
 }
 
 @proxy
-class SpyElementRef extends SpyObject implements ElementRef_ {
+class SpyProtoView extends SpyObject implements AppProtoView {
   noSuchMethod(m) => super.noSuchMethod(m);
 }
 
 @proxy
-class SpyAppViewManager extends SpyObject implements AppViewManager {
+class SpyHostViewFactory extends SpyObject implements HostViewFactory {
   noSuchMethod(m) => super.noSuchMethod(m);
 }
 
 @proxy
-class SpyRenderer extends SpyObject implements Renderer {
-  noSuchMethod(m) => super.noSuchMethod(m);
-}
-
-@proxy
-class SpyAppViewPool extends SpyObject implements AppViewPool {
+class SpyElementRef extends SpyObject implements ElementRef {
   noSuchMethod(m) => super.noSuchMethod(m);
 }
 
 @proxy
-class SpyAppViewListener extends SpyObject implements AppViewListener {
+class SpyAppViewManager extends SpyObject implements AppViewManager_ {
   noSuchMethod(m) => super.noSuchMethod(m);
 }
 
 @proxy
-class SpyProtoViewFactory extends SpyObject implements ProtoViewFactory {
-  noSuchMethod(m) => super.noSuchMethod(m);
-}
-
-@proxy
-class SpyProtoElementInjector extends SpyObject
-    implements ProtoElementInjector {
+class SpyRenderer extends SpyObject implements Renderer {
   noSuchMethod(m) => super.noSuchMethod(m);
 }
 
 @proxy
-class SpyElementInjector extends SpyObject implements ElementInjector {
+class SpyRootRenderer extends SpyObject implements RootRenderer {
   noSuchMethod(m) => super.noSuchMethod(m);
 }
 
 @proxy
-class SpyPreBuiltObjects extends SpyObject implements PreBuiltObjects {
+class SpyAppViewListener extends SpyObject implements AppViewListener {
   noSuchMethod(m) => super.noSuchMethod(m);
 }
 
@@ -101,9 +87,3 @@ class SpyPreBuiltObjects extends SpyObject implements PreBuiltObjects {
 class SpyDomAdapter extends SpyObject implements DomAdapter {
   noSuchMethod(m) => super.noSuchMethod(m);
 }
-
-@proxy
-class SpyRenderEventDispatcher extends SpyObject
-    implements RenderEventDispatcher {
-  noSuchMethod(m) => super.noSuchMethod(m);
-}
\ No newline at end of file
diff --git a/modules/angular2/test/core/spies.ts b/modules/angular2/test/core/spies.ts
index 09a65fa..413a8ee 100644
--- a/modules/angular2/test/core/spies.ts
+++ b/modules/angular2/test/core/spies.ts
@@ -5,23 +5,14 @@ import {
   DynamicChangeDetector
 } from 'angular2/src/core/change_detection/change_detection';
 
-import {Renderer, RenderEventDispatcher} from 'angular2/src/core/render/api';
+import {Renderer} from 'angular2/src/core/render/api';
 import {DirectiveResolver} from 'angular2/src/core/linker/directive_resolver';
 
-import {AppView} from 'angular2/src/core/linker/view';
+import {AppView, AppProtoView, HostViewFactory} from 'angular2/src/core/linker/view';
 import {ElementRef} from 'angular2/src/core/linker/element_ref';
-import {AppViewManager} from 'angular2/src/core/linker/view_manager';
-import {AppViewPool} from 'angular2/src/core/linker/view_pool';
+import {AppViewManager_} from 'angular2/src/core/linker/view_manager';
 import {AppViewListener} from 'angular2/src/core/linker/view_listener';
-import {ProtoViewFactory} from 'angular2/src/core/linker/proto_view_factory';
 import {DomAdapter} from 'angular2/src/platform/dom/dom_adapter';
-import {ClientMessageBroker} from 'angular2/src/web_workers/shared/client_message_broker';
-
-import {
-  ElementInjector,
-  PreBuiltObjects,
-  ProtoElementInjector
-} from 'angular2/src/core/linker/element_injector';
 
 import {SpyObject, proxy} from 'angular2/testing_internal';
 
@@ -43,12 +34,20 @@ export class SpyView extends SpyObject {
   constructor() { super(AppView); }
 }
 
+export class SpyProtoView extends SpyObject {
+  constructor() { super(AppProtoView); }
+}
+
+export class SpyHostViewFactory extends SpyObject {
+  constructor() { super(HostViewFactory); }
+}
+
 export class SpyElementRef extends SpyObject {
   constructor() { super(ElementRef); }
 }
 
 export class SpyAppViewManager extends SpyObject {
-  constructor() { super(AppViewManager); }
+  constructor() { super(AppViewManager_); }
 }
 
 export class SpyRenderer extends SpyObject {
@@ -57,52 +56,42 @@ export class SpyRenderer extends SpyObject {
     // so we can't generates spy functions automatically
     // by inspecting the prototype...
     super(Renderer);
-    this.spy('setEventDispatcher');
+    this.spy('renderComponent');
+    this.spy('selectRootElement');
+    this.spy('createElement');
+    this.spy('createViewRoot');
+    this.spy('createTemplateAnchor');
+    this.spy('createText');
+    this.spy('projectNodes');
+    this.spy('attachViewAfter');
+    this.spy('detachView');
     this.spy('destroyView');
-    this.spy('createView');
-    this.spy('createProtoView');
-    this.spy('hydrateView');
-    this.spy('dehydrateView');
-    this.spy('attachFragmentAfterElement');
-    this.spy('attachFragmentAfterFragment');
-    this.spy('detachFragment');
+    this.spy('listen');
+    this.spy('listenGlobal');
+    this.spy('setElementProperty');
+    this.spy('setElementAttribute');
+    this.spy('setBindingDebugInfo');
+    this.spy('setElementClass');
+    this.spy('setElementStyle');
+    this.spy('invokeElementMethod');
+    this.spy('setText');
   }
 }
 
-export class SpyAppViewPool extends SpyObject {
-  constructor() { super(AppViewPool); }
+export class SpyRootRenderer extends SpyObject {
+  constructor() {
+    // Note: RootRenderer is an abstract class,
+    // so we can't generates spy functions automatically
+    // by inspecting the prototype...
+    super(SpyRootRenderer);
+    this.spy('renderComponent');
+  }
 }
 
 export class SpyAppViewListener extends SpyObject {
   constructor() { super(AppViewListener); }
 }
 
-export class SpyProtoViewFactory extends SpyObject {
-  constructor() { super(ProtoViewFactory); }
-}
-
-export class SpyProtoElementInjector extends SpyObject {
-  constructor() { super(ProtoElementInjector); }
-}
-
-export class SpyElementInjector extends SpyObject {
-  constructor() { super(ElementInjector); }
-}
-
-export class SpyPreBuiltObjects extends SpyObject {
-  constructor() { super(PreBuiltObjects); }
-}
-
 export class SpyDomAdapter extends SpyObject {
   constructor() { super(DomAdapter); }
 }
-
-export class SpyRenderEventDispatcher extends SpyObject {
-  constructor() {
-    // Note: RenderEventDispatcher is an interface,
-    // so we can't pass it to super() and have to register
-    // the spy methods on our own.
-    super();
-    this.spy('dispatchRenderEvent');
-  }
-}
\ No newline at end of file
diff --git a/modules/angular2/test/platform/browser/debug/debug_element_view_listener_spec.ts b/modules/angular2/test/platform/browser/debug/debug_element_view_listener_spec.ts
index 5b6d095..bc77dee 100644
--- a/modules/angular2/test/platform/browser/debug/debug_element_view_listener_spec.ts
+++ b/modules/angular2/test/platform/browser/debug/debug_element_view_listener_spec.ts
@@ -14,7 +14,6 @@ import {
   TestComponentBuilder,
 } from 'angular2/testing_internal';
 import {global} from 'angular2/src/facade/lang';
-import {APP_VIEW_POOL_CAPACITY} from 'angular2/src/core/linker/view_pool';
 import {provide, Component, Directive, Injectable, View} from 'angular2/core';
 import {inspectNativeElement} from 'angular2/platform/browser';
 import {IS_DART} from 'angular2/src/facade/lang';
@@ -28,8 +27,6 @@ class MyComp {
 
 export function main() {
   describe('element probe', function() {
-    beforeEachProviders(() => [provide(APP_VIEW_POOL_CAPACITY, {useValue: 0})]);
-
     it('should return a TestElement from a dom element',
        inject([TestComponentBuilder, AsyncTestCompleter], (tcb: TestComponentBuilder, async) => {
          tcb.overrideTemplate(MyComp, '<div some-dir></div>')
diff --git a/modules/angular2/test/public_api_spec.ts b/modules/angular2/test/public_api_spec.ts
index 0943936..d188602 100644
--- a/modules/angular2/test/public_api_spec.ts
+++ b/modules/angular2/test/public_api_spec.ts
@@ -594,6 +594,7 @@ var NG_COMPILER = [
   "SourceModule.moduleUrl=",
   "SourceModule.sourceWithModuleRefs",
   "SourceModule.sourceWithModuleRefs=",
+  "SourceModule#getSourceWithoutImports()",
   "SourceWithImports.imports",
   "SourceWithImports.imports=",
   "SourceWithImports.source",
@@ -690,9 +691,9 @@ var NG_CORE = [
   'AbstractProviderError.message=',
   'AbstractProviderError.stackTrace',
   'AppViewManager:js',
-  'AppViewManager.getHostElement():js',
   /*
   Abstract methods
+  'AppViewManager.getHostElement()',
   'AppViewManager.attachViewInContainer()',
   'AppViewManager.createEmbeddedViewInContainer()',
   'AppViewManager.createHostViewInContainer()',
@@ -948,15 +949,14 @@ var NG_CORE = [
   'DynamicComponentLoader.loadNextToLocation()',
   */
   'ElementRef',
-  'ElementRef.boundElementIndex',
-  'ElementRef.boundElementIndex=',
   'ElementRef.nativeElement',
-  'ElementRef.parentView',
-  'ElementRef.parentView=',
-  'ElementRef.renderView',
   'ErrorHandlingFn:dart',
   'Output',
   'Output.bindingPropertyName',
+  'EmbeddedViewRef:dart',
+  'EmbeddedViewRef.changeDetectorRef',
+  'EmbeddedViewRef.destroyed',
+  'EmbeddedViewRef.rootNodes',
   'EventEmitter',
   /*
    Dart Stream/EventEmitter
@@ -1026,6 +1026,7 @@ var NG_CORE = [
   'HostListenerMetadata.args',
   'HostListenerMetadata.eventName',
   'HostMetadata',
+  'HostViewFactoryRef:dart',
   'Inject',
   'Inject.token',
   'InjectMetadata',
@@ -1043,6 +1044,7 @@ var NG_CORE = [
   'Injector.get()',
   'Injector.getAt()',
   'Injector.getOptional()',
+  'Injector.hostBoundary',
   'Injector.instantiateResolved()',
   'Injector.internalStrategy',
   'Injector.parent',
@@ -1137,7 +1139,6 @@ var NG_CORE = [
   'Input.bindingPropertyName',
   'InputMetadata',
   'InputMetadata.bindingPropertyName',
-  'ProtoViewRef',
   'Query',
   'Query.descendants',
   'Query.first',
@@ -1185,36 +1186,15 @@ var NG_CORE = [
   'QueryMetadata.selector',
   'QueryMetadata.token',
   'QueryMetadata.varBindings',
-  'RenderFragmentRef',
-  'RenderProtoViewRef',
-  'RenderViewRef',
-  'RenderViewWithFragments',
-  'RenderViewWithFragments.fragmentRefs',
-  'RenderViewWithFragments.fragmentRefs=',
-  'RenderViewWithFragments.viewRef',
-  'RenderViewWithFragments.viewRef=',
   'Renderer',
-  /*
-   Abstract methods
-  'Renderer.attachFragmentAfterElement()',
-  'Renderer.attachFragmentAfterFragment()',
-  'Renderer.createProtoView()',
-  'Renderer.registerComponentTemplate()',
-  'Renderer.createRootHostView()',
-  'Renderer.createView()',
-  'Renderer.dehydrateView()',
-   'Renderer.destroyView()',
-   'Renderer.detachFragment()',
-   'Renderer.getNativeElementSync()',
-   'Renderer.hydrateView()',
-   'Renderer.invokeElementMethod()',
-   'Renderer.setElementAttribute()',
-   'Renderer.setElementClass()',
-   'Renderer.setElementProperty()',
-   'Renderer.setElementStyle()',
-   'Renderer.setEventDispatcher()',
-   'Renderer.setText()',
-  */
+  'RootRenderer',
+  'RenderComponentType',
+  'RenderComponentType.encapsulation',
+  'RenderComponentType.encapsulation=',
+  'RenderComponentType.id',
+  'RenderComponentType.id=',
+  'RenderComponentType.styles',
+  'RenderComponentType.styles=',
   'ResolvedBinding:dart',
   'ResolvedProvider:dart',
   'ResolvedProvider.key:dart',
@@ -1318,7 +1298,6 @@ var NG_CORE = [
    'ViewContainerRef.detach()',
   */
   'ViewContainerRef.element',
-  'ViewContainerRef.element=',
   /*
    'ViewContainerRef.get()',
    'ViewContainerRef.indexOf()',
@@ -1355,9 +1334,6 @@ var NG_CORE = [
   'ViewQueryMetadata.selector',
   'ViewQueryMetadata.token',
   'ViewQueryMetadata.varBindings',
-  'ViewRef',
-  'ViewRef.changeDetectorRef',
-  'ViewRef.changeDetectorRef=',
   /*
    Abstract method
    'ViewRef.setLocal()',
@@ -1391,7 +1367,8 @@ var NG_CORE = [
   'DoCheck:dart',
   'HostViewRef:dart',
   'HostViewRef.changeDetectorRef',
-  'HostViewRef.changeDetectorRef=',
+  'HostViewRef.destroyed',
+  'HostViewRef.rootNodes',
   'IterableDifferFactory:dart',
   'IterableDiffer:dart',
   'KeyValueDifferFactory:dart',
@@ -1401,56 +1378,6 @@ var NG_CORE = [
   'OnInit:dart',
   'PipeTransform:dart',
   'reflector',
-  'RenderBeginCmd:dart',
-  'RenderBeginCmd.isBound',
-  'RenderBeginCmd.ngContentIndex',
-  'RenderBeginComponentCmd:dart',
-  'RenderBeginComponentCmd.attrNameAndValues',
-  'RenderBeginComponentCmd.eventTargetAndNames',
-  'RenderBeginComponentCmd.isBound',
-  'RenderBeginComponentCmd.name',
-  'RenderBeginComponentCmd.ngContentIndex',
-  'RenderBeginComponentCmd.templateId',
-  'RenderBeginElementCmd:dart',
-  'RenderBeginElementCmd.attrNameAndValues',
-  'RenderBeginElementCmd.isBound',
-  'RenderBeginElementCmd.eventTargetAndNames',
-  'RenderBeginElementCmd.name',
-  'RenderBeginElementCmd.ngContentIndex',
-  'RenderCommandVisitor:dart',
-  'RenderEmbeddedTemplateCmd:dart',
-  'RenderEmbeddedTemplateCmd.attrNameAndValues',
-  'RenderEmbeddedTemplateCmd.children',
-  'RenderEmbeddedTemplateCmd.eventTargetAndNames',
-  'RenderEmbeddedTemplateCmd.isBound',
-  'RenderEmbeddedTemplateCmd.isMerged',
-  'RenderEmbeddedTemplateCmd.name',
-  'RenderEmbeddedTemplateCmd.ngContentIndex',
-  'RenderNgContentCmd:dart',
-  'RenderNgContentCmd.ngContentIndex',
-  'RenderTemplateCmd:dart',
-  'RenderTextCmd:dart',
-  'RenderTextCmd.isBound',
-  'RenderTextCmd.ngContentIndex',
-  'RenderTextCmd.value',
-  'RenderElementRef:dart',
-  'RenderElementRef.boundElementIndex',
-  'RenderElementRef.boundElementIndex=',
-  'RenderElementRef.renderView',
-  'RenderElementRef.renderView=',
-  'RenderEventDispatcher:dart',
-  'RenderNgContentCmd.index',
-  'RenderComponentTemplate',
-  'RenderComponentTemplate.commands',
-  'RenderComponentTemplate.commands=',
-  'RenderComponentTemplate.encapsulation',
-  'RenderComponentTemplate.encapsulation=',
-  'RenderComponentTemplate.id',
-  'RenderComponentTemplate.id=',
-  'RenderComponentTemplate.shortId',
-  'RenderComponentTemplate.shortId=',
-  'RenderComponentTemplate.styles',
-  'RenderComponentTemplate.styles=',
   'Stream:dart',
   'Stream.any():dart',
   'Stream.asBroadcastStream():dart',
@@ -1532,7 +1459,10 @@ var NG_CORE = [
   'Reflector.registerType():dart',
   'Reflector.setter():dart',
   'Reflector.trackUsage():dart',
-  'SetterFn:dart'
+  'SetterFn:dart',
+  'ViewRef:dart',
+  'ViewRef.changeDetectorRef',
+  'ViewRef.destroyed',
 ];
 
 var NG_INSTRUMENTATION = [
diff --git a/modules/angular2/test/router/integration/bootstrap_spec.ts b/modules/angular2/test/router/integration/bootstrap_spec.ts
index 45d7534..9518524 100644
--- a/modules/angular2/test/router/integration/bootstrap_spec.ts
+++ b/modules/angular2/test/router/integration/bootstrap_spec.ts
@@ -82,7 +82,6 @@ export function main() {
            tcb.createAsync(AppCmp).then((fixture) => {
              var router = fixture.debugElement.componentInstance.router;
              PromiseWrapper.catchError(router.navigateByUrl('/cause-error'), (error) => {
-               expect(fixture.debugElement.nativeElement).toHaveText('outer { oh no }');
                expect(error).toContainError('oops!');
                async.done();
              });
diff --git a/modules/angular2/test/web_workers/shared/render_proto_view_ref_store_spec.ts b/modules/angular2/test/web_workers/shared/render_proto_view_ref_store_spec.ts
deleted file mode 100644
index 94cae2d..0000000
--- a/modules/angular2/test/web_workers/shared/render_proto_view_ref_store_spec.ts
+++ /dev/null
@@ -1,56 +0,0 @@
-import {
-  AsyncTestCompleter,
-  inject,
-  describe,
-  ddescribe,
-  beforeEach,
-  it,
-  expect
-} from "angular2/testing_internal";
-import {RenderProtoViewRef} from "angular2/src/core/render/api";
-import {RenderProtoViewRefStore} from "angular2/src/web_workers/shared/render_proto_view_ref_store";
-import {
-  WebWorkerRenderProtoViewRef
-} from "angular2/src/web_workers/shared/render_proto_view_ref_store";
-
-export function main() {
-  describe("RenderProtoViewRefStore", () => {
-    describe("on WebWorker", () => {
-      var store: RenderProtoViewRefStore;
-      beforeEach(() => { store = new RenderProtoViewRefStore(true); });
-
-      it("should allocate refs", () => {
-        expect((<WebWorkerRenderProtoViewRef>store.allocate()).refNumber).toBe(0);
-        expect((<WebWorkerRenderProtoViewRef>store.allocate()).refNumber).toBe(1);
-      });
-
-      it("should be serializable", () => {
-        var protoView = store.allocate();
-        expect(store.deserialize(store.serialize(protoView))).toEqual(protoView);
-      });
-
-    });
-
-    describe("on UI", () => {
-      var store: RenderProtoViewRefStore;
-      beforeEach(() => { store = new RenderProtoViewRefStore(false); });
-
-      it("should associate views with the correct references", () => {
-        var renderProtoViewRef = new RenderProtoViewRef();
-
-        store.store(renderProtoViewRef, 100);
-        expect(store.deserialize(100)).toBe(renderProtoViewRef);
-      });
-
-      it("should be serializable", () => {
-        var renderProtoViewRef = new RenderProtoViewRef();
-        store.store(renderProtoViewRef, 0);
-
-        var deserialized = store.deserialize(store.serialize(renderProtoViewRef));
-        expect(deserialized).toBe(renderProtoViewRef);
-      });
-
-    });
-
-  });
-}
diff --git a/modules/angular2/test/web_workers/shared/render_store_spec.ts b/modules/angular2/test/web_workers/shared/render_store_spec.ts
new file mode 100644
index 0000000..2564609
--- /dev/null
+++ b/modules/angular2/test/web_workers/shared/render_store_spec.ts
@@ -0,0 +1,37 @@
+import {
+  AsyncTestCompleter,
+  inject,
+  describe,
+  ddescribe,
+  beforeEach,
+  it,
+  expect
+} from "angular2/testing_internal";
+import {RenderStore} from "angular2/src/web_workers/shared/render_store";
+
+export function main() {
+  describe("RenderStoreSpec", () => {
+    var store: RenderStore;
+    beforeEach(() => { store = new RenderStore(); });
+
+    it('should allocate ids', () => {
+      expect(store.allocateId()).toBe(0);
+      expect(store.allocateId()).toBe(1);
+    });
+
+    it('should serialize objects', () => {
+      var id = store.allocateId();
+      var obj = 'testObject';
+      store.store(obj, id);
+      expect(store.serialize(obj)).toBe(id);
+    });
+
+    it('should deserialize objects', () => {
+      var id = store.allocateId();
+      var obj = 'testObject';
+      store.store(obj, id);
+      expect(store.deserialize(id)).toBe(obj);
+    });
+
+  });
+}
\ No newline at end of file
diff --git a/modules/angular2/test/web_workers/shared/render_view_with_fragments_store_spec.ts b/modules/angular2/test/web_workers/shared/render_view_with_fragments_store_spec.ts
deleted file mode 100644
index 3f42c33..0000000
--- a/modules/angular2/test/web_workers/shared/render_view_with_fragments_store_spec.ts
+++ /dev/null
@@ -1,144 +0,0 @@
-import {
-  AsyncTestCompleter,
-  beforeEach,
-  inject,
-  describe,
-  it,
-  expect
-} from "angular2/testing_internal";
-import {
-  RenderViewWithFragments,
-  RenderViewRef,
-  RenderFragmentRef
-} from "angular2/src/core/render/api";
-import {
-  RenderViewWithFragmentsStore,
-  WebWorkerRenderViewRef,
-  WebWorkerRenderFragmentRef
-} from "angular2/src/web_workers/shared/render_view_with_fragments_store";
-import {ListWrapper} from "angular2/src/facade/collection";
-
-export function main() {
-  describe("RenderViewWithFragmentsStore", () => {
-    describe("on WebWorker", () => {
-      var store: RenderViewWithFragmentsStore;
-      beforeEach(() => { store = new RenderViewWithFragmentsStore(true); });
-
-      it("should allocate fragmentCount + 1 refs", () => {
-        var view: RenderViewWithFragments = store.allocate(10);
-
-        var viewRef: WebWorkerRenderViewRef = <WebWorkerRenderViewRef>view.viewRef;
-        expect(viewRef.refNumber).toEqual(0);
-
-        var fragmentRefs: WebWorkerRenderFragmentRef[] =
-            <WebWorkerRenderFragmentRef[]>view.fragmentRefs;
-        expect(fragmentRefs.length).toEqual(10);
-
-        for (var i = 0; i < fragmentRefs.length; i++) {
-          expect(fragmentRefs[i].refNumber).toEqual(i + 1);
-        }
-      });
-
-      it("should not reuse a reference", () => {
-        store.allocate(10);
-        var view = store.allocate(0);
-        var viewRef = <WebWorkerRenderViewRef>view.viewRef;
-        expect(viewRef.refNumber).toEqual(11);
-      });
-
-      it("should be serializable", () => {
-        var view = store.allocate(1);
-        expect(store.deserializeViewWithFragments(store.serializeViewWithFragments(view)))
-            .toEqual(view);
-      });
-
-      it("should remove a view and all attached fragments", () => {
-        const NUM_FRAGMENTS = 5;
-        var view = store.allocate(NUM_FRAGMENTS);
-        var viewRef = (<WebWorkerRenderViewRef>view.viewRef).refNumber;
-        store.remove(view.viewRef);
-
-        expect(store.deserializeRenderViewRef(viewRef++)).toBeNull();
-        for (var i = 0; i < NUM_FRAGMENTS; i++) {
-          expect(store.deserializeRenderFragmentRef(viewRef++)).toBeNull();
-        }
-      });
-    });
-
-    describe("on UI", () => {
-      var store: RenderViewWithFragmentsStore;
-      beforeEach(() => { store = new RenderViewWithFragmentsStore(false); });
-      function createMockRenderViewWithFragments(): RenderViewWithFragments {
-        var view = new MockRenderViewRef();
-        var fragments = ListWrapper.createGrowableSize(20);
-        for (var i = 0; i < 20; i++) {
-          fragments[i] = new MockRenderFragmentRef();
-        }
-
-        return new RenderViewWithFragments(view, fragments);
-      }
-      it("should associate views with the correct references", () => {
-        var renderViewWithFragments = createMockRenderViewWithFragments();
-
-        store.store(renderViewWithFragments, 100);
-        expect(store.deserializeRenderViewRef(100)).toBe(renderViewWithFragments.viewRef);
-
-        for (var i = 0; i < renderViewWithFragments.fragmentRefs.length; i++) {
-          expect(store.deserializeRenderFragmentRef(101 + i))
-              .toBe(renderViewWithFragments.fragmentRefs[i]);
-        }
-      });
-
-      describe("RenderViewWithFragments", () => {
-        it("should be serializable", () => {
-          var renderViewWithFragments = createMockRenderViewWithFragments();
-          store.store(renderViewWithFragments, 0);
-
-          var deserialized = store.deserializeViewWithFragments(
-              store.serializeViewWithFragments(renderViewWithFragments));
-          expect(deserialized.viewRef).toBe(renderViewWithFragments.viewRef);
-
-          expect(deserialized.fragmentRefs.length)
-              .toEqual(renderViewWithFragments.fragmentRefs.length);
-
-          for (var i = 0; i < deserialized.fragmentRefs.length; i++) {
-            var val = deserialized.fragmentRefs[i];
-            expect(val).toBe(renderViewWithFragments.fragmentRefs[i]);
-          };
-        });
-      });
-
-      describe("RenderViewRef", () => {
-        it("should be serializable", () => {
-          var renderViewWithFragments = createMockRenderViewWithFragments();
-          store.store(renderViewWithFragments, 0);
-
-          var deserialized = store.deserializeRenderViewRef(
-              store.serializeRenderViewRef(renderViewWithFragments.viewRef));
-          expect(deserialized).toBe(renderViewWithFragments.viewRef);
-        });
-      });
-
-      describe("RenderFragmentRef", () => {
-        it("should be serializable", () => {
-          var renderViewWithFragments = createMockRenderViewWithFragments();
-          store.store(renderViewWithFragments, 0);
-
-          var serialized =
-              store.serializeRenderFragmentRef(renderViewWithFragments.fragmentRefs[0]);
-          var deserialized = store.deserializeRenderFragmentRef(serialized);
-
-          expect(deserialized).toBe(renderViewWithFragments.fragmentRefs[0]);
-        });
-      });
-    });
-  });
-}
-
-class MockRenderViewRef extends RenderViewRef {
-  constructor() { super(); }
-}
-
-class MockRenderFragmentRef extends RenderFragmentRef {
-  constructor() { super(); }
-}
diff --git a/modules/angular2/test/web_workers/shared/service_message_broker_spec.ts b/modules/angular2/test/web_workers/shared/service_message_broker_spec.ts
index d30be8b..0273a77 100644
--- a/modules/angular2/test/web_workers/shared/service_message_broker_spec.ts
+++ b/modules/angular2/test/web_workers/shared/service_message_broker_spec.ts
@@ -18,10 +18,7 @@ import {
 import {ObservableWrapper, PromiseWrapper} from 'angular2/src/facade/async';
 import {provide} from 'angular2/core';
 import {ON_WEB_WORKER} from 'angular2/src/web_workers/shared/api';
-import {RenderProtoViewRefStore} from 'angular2/src/web_workers/shared/render_proto_view_ref_store';
-import {
-  RenderViewWithFragmentsStore
-} from 'angular2/src/web_workers/shared/render_view_with_fragments_store';
+import {RenderStore} from 'angular2/src/web_workers/shared/render_store';
 
 export function main() {
   const CHANNEL = "UIMessageBroker Test Channel";
@@ -31,11 +28,7 @@ export function main() {
   const RESULT = 20;
   const ID = "methodId";
 
-  beforeEachProviders(() => [
-    provide(ON_WEB_WORKER, {useValue: true}),
-    RenderProtoViewRefStore,
-    RenderViewWithFragmentsStore
-  ]);
+  beforeEachProviders(() => [provide(ON_WEB_WORKER, {useValue: true}), RenderStore]);
 
   describe("UIMessageBroker", () => {
     var messageBuses;
diff --git a/modules/angular2/test/web_workers/worker/event_dispatcher_spec.ts b/modules/angular2/test/web_workers/worker/event_dispatcher_spec.ts
deleted file mode 100644
index a97d1b0..0000000
--- a/modules/angular2/test/web_workers/worker/event_dispatcher_spec.ts
+++ /dev/null
@@ -1,71 +0,0 @@
-import {
-  AsyncTestCompleter,
-  inject,
-  describe,
-  it,
-  expect,
-  beforeEach,
-  beforeEachProviders,
-  SpyObject,
-  proxy
-} from 'angular2/testing_internal';
-import {Serializer} from 'angular2/src/web_workers/shared/serializer';
-import {ON_WEB_WORKER} from 'angular2/src/web_workers/shared/api';
-import {provide} from 'angular2/core';
-import {RenderProtoViewRefStore} from 'angular2/src/web_workers/shared/render_proto_view_ref_store';
-import {
-  RenderViewWithFragmentsStore,
-  WebWorkerRenderViewRef
-} from 'angular2/src/web_workers/shared/render_view_with_fragments_store';
-import {RenderEventDispatcher, RenderViewRef} from 'angular2/src/core/render/api';
-import {createPairedMessageBuses} from '../shared/web_worker_test_util';
-import {WebWorkerEventDispatcher} from 'angular2/src/web_workers/worker/event_dispatcher';
-import {ObservableWrapper} from 'angular2/src/facade/async';
-import {EVENT_CHANNEL} from 'angular2/src/web_workers/shared/messaging_api';
-
-export function main() {
-  describe("EventDispatcher", () => {
-    beforeEachProviders(() => [
-      provide(ON_WEB_WORKER, {useValue: true}),
-      RenderProtoViewRefStore,
-      RenderViewWithFragmentsStore
-    ]);
-
-    it("should dispatch events", inject([Serializer, AsyncTestCompleter], (serializer, async) => {
-         var messageBuses = createPairedMessageBuses();
-         var webWorkerEventDispatcher =
-             new WebWorkerEventDispatcher(messageBuses.worker, serializer);
-
-         var elementIndex = 15;
-         var eventName = 'click';
-
-         var eventDispatcher = new SpyEventDispatcher((elementIndex, eventName, locals) => {
-           expect(elementIndex).toEqual(elementIndex);
-           expect(eventName).toEqual(eventName);
-           async.done();
-         });
-
-         var viewRef = new WebWorkerRenderViewRef(0);
-         serializer.allocateRenderViews(0);  // serialize the ref so it's in the store
-         viewRef =
-             serializer.deserialize(serializer.serialize(viewRef, RenderViewRef), RenderViewRef);
-         webWorkerEventDispatcher.registerEventDispatcher(viewRef, eventDispatcher);
-
-         ObservableWrapper.callEmit(messageBuses.ui.to(EVENT_CHANNEL), {
-           'viewRef': viewRef.serialize(),
-           'elementIndex': elementIndex,
-           'eventName': eventName,
-           'locals': {'$event': {'target': {value: null}}}
-         });
-       }));
-  });
-}
-
-class SpyEventDispatcher implements RenderEventDispatcher {
-  constructor(private _callback: Function) {}
-
-  dispatchRenderEvent(elementIndex: number, eventName: string, locals: Map<string, any>): boolean {
-    this._callback(elementIndex, eventName, locals);
-    return false;
-  }
-}
diff --git a/modules/angular2/test/web_workers/worker/renderer_integration_spec.ts b/modules/angular2/test/web_workers/worker/renderer_integration_spec.ts
index 8f56648..ac6874c 100644
--- a/modules/angular2/test/web_workers/worker/renderer_integration_spec.ts
+++ b/modules/angular2/test/web_workers/worker/renderer_integration_spec.ts
@@ -3,6 +3,7 @@ import {
   inject,
   ddescribe,
   describe,
+  dispatchEvent,
   it,
   iit,
   expect,
@@ -23,8 +24,9 @@ import {
   Injectable,
   ElementRef
 } from 'angular2/core';
+import {AppViewListener} from 'angular2/src/core/linker/view_listener';
 import {NgIf} from 'angular2/common';
-import {WebWorkerRenderer} from "angular2/src/web_workers/worker/renderer";
+import {WebWorkerRootRenderer} from "angular2/src/web_workers/worker/renderer";
 import {
   ClientMessageBrokerFactory,
   ClientMessageBrokerFactory_,
@@ -32,38 +34,22 @@ import {
   FnArg
 } from "angular2/src/web_workers/shared/client_message_broker";
 import {Serializer} from "angular2/src/web_workers/shared/serializer";
-import {
-  RenderProtoViewRef,
-  RenderViewWithFragments,
-  RenderViewRef,
-  RenderFragmentRef,
-  Renderer
-} from "angular2/src/core/render/api";
-import {DomRenderer, DomRenderer_} from 'angular2/src/platform/dom/dom_renderer';
-import {DefaultRenderView} from 'angular2/src/core/render/view';
-import {
-  RenderProtoViewRefStore,
-  WebWorkerRenderProtoViewRef
-} from "angular2/src/web_workers/shared/render_proto_view_ref_store";
-import {
-  RenderViewWithFragmentsStore,
-  WebWorkerRenderViewRef
-} from 'angular2/src/web_workers/shared/render_view_with_fragments_store';
+import {RootRenderer} from "angular2/src/core/render/api";
+import {DomRootRenderer, DomRootRenderer_} from 'angular2/src/platform/dom/dom_renderer';
+import {RenderStore} from "angular2/src/web_workers/shared/render_store";
 import {MessageBasedRenderer} from 'angular2/src/web_workers/ui/renderer';
 import {createPairedMessageBuses, PairedMessageBuses} from '../shared/web_worker_test_util';
 import {
   ServiceMessageBrokerFactory,
   ServiceMessageBrokerFactory_
 } from 'angular2/src/web_workers/shared/service_message_broker';
-import {WebWorkerEventDispatcher} from 'angular2/src/web_workers/worker/event_dispatcher';
 import {ChangeDetectorGenConfig} from 'angular2/src/core/change_detection/change_detection';
 
 
 export function main() {
   function createWebWorkerBrokerFactory(
       messageBuses: PairedMessageBuses, workerSerializer: Serializer, uiSerializer: Serializer,
-      domRenderer: DomRenderer, uiRenderProtoViewStore: RenderProtoViewRefStore,
-      uiRenderViewStore: RenderViewWithFragmentsStore): ClientMessageBrokerFactory {
+      domRootRenderer: DomRootRenderer, uiRenderStore: RenderStore): ClientMessageBrokerFactory {
     var uiMessageBus = messageBuses.ui;
     var workerMessageBus = messageBuses.worker;
 
@@ -74,67 +60,62 @@ export function main() {
     // set up the ui side
     var uiMessageBrokerFactory = new ServiceMessageBrokerFactory_(uiMessageBus, uiSerializer);
     var renderer = new MessageBasedRenderer(uiMessageBrokerFactory, uiMessageBus, uiSerializer,
-                                            uiRenderProtoViewStore, uiRenderViewStore, domRenderer);
+                                            uiRenderStore, domRootRenderer);
     renderer.start();
 
     return webWorkerBrokerFactory;
   }
 
-  function createWorkerRenderer(
-      workerSerializer: Serializer, uiSerializer: Serializer, domRenderer: DomRenderer,
-      uiRenderProtoViewStore: RenderProtoViewRefStore,
-      uiRenderViewStore: RenderViewWithFragmentsStore,
-      workerRenderProtoViewStore: RenderProtoViewRefStore,
-      workerRenderViewStore: RenderViewWithFragmentsStore): WebWorkerRenderer {
+  function createWorkerRenderer(workerSerializer: Serializer, uiSerializer: Serializer,
+                                domRootRenderer: DomRootRenderer, uiRenderStore: RenderStore,
+                                workerRenderStore: RenderStore): WebWorkerRootRenderer {
     var messageBuses = createPairedMessageBuses();
-    var brokerFactory =
-        createWebWorkerBrokerFactory(messageBuses, workerSerializer, uiSerializer, domRenderer,
-                                     uiRenderProtoViewStore, uiRenderViewStore);
-    var workerEventDispatcher = new WebWorkerEventDispatcher(messageBuses.worker, workerSerializer);
-    return new WebWorkerRenderer(brokerFactory, workerRenderProtoViewStore, workerRenderViewStore,
-                                 workerEventDispatcher);
+    var brokerFactory = createWebWorkerBrokerFactory(messageBuses, workerSerializer, uiSerializer,
+                                                     domRootRenderer, uiRenderStore);
+    return new WebWorkerRootRenderer(brokerFactory, messageBuses.worker, workerSerializer,
+                                     workerRenderStore);
   }
 
   describe("Web Worker Renderer", () => {
     var uiInjector: Injector;
-    var uiRenderViewStore: RenderViewWithFragmentsStore;
+    var uiRenderStore: RenderStore;
+    var workerRenderStore: RenderStore;
 
     beforeEachProviders(() => {
-      var uiRenderProtoViewStore = new RenderProtoViewRefStore(false);
-      uiRenderViewStore = new RenderViewWithFragmentsStore(false);
+      uiRenderStore = new RenderStore();
       var testInjector = new TestInjector();
       testInjector.addProviders([
-        provide(RenderProtoViewRefStore, {useValue: uiRenderProtoViewStore}),
-        provide(RenderViewWithFragmentsStore, {useValue: uiRenderViewStore}),
-        provide(DomRenderer, {useClass: DomRenderer_}),
-        provide(Renderer, {useExisting: DomRenderer})
+        provide(RenderStore, {useValue: uiRenderStore}),
+        provide(DomRootRenderer, {useClass: DomRootRenderer_}),
+        provide(RootRenderer, {useExisting: DomRootRenderer})
       ]);
       uiInjector = testInjector.createInjector();
       var uiSerializer = uiInjector.get(Serializer);
-      var domRenderer = uiInjector.get(DomRenderer);
-      var workerRenderProtoViewStore = new RenderProtoViewRefStore(true);
-      var workerRenderViewStore = new RenderViewWithFragmentsStore(true);
+      var domRootRenderer = uiInjector.get(DomRootRenderer);
+      workerRenderStore = new RenderStore();
       return [
         provide(ChangeDetectorGenConfig,
                 {useValue: new ChangeDetectorGenConfig(true, true, false)}),
-        provide(RenderProtoViewRefStore, {useValue: workerRenderProtoViewStore}),
-        provide(RenderViewWithFragmentsStore, {useValue: workerRenderViewStore}),
-        provide(Renderer,
+        provide(RenderStore, {useValue: workerRenderStore}),
+        provide(RootRenderer,
                 {
                   useFactory: (workerSerializer) => {
-                    return createWorkerRenderer(workerSerializer, uiSerializer, domRenderer,
-                                                uiRenderProtoViewStore, uiRenderViewStore,
-                                                workerRenderProtoViewStore, workerRenderViewStore);
+                    return createWorkerRenderer(workerSerializer, uiSerializer, domRootRenderer,
+                                                uiRenderStore, workerRenderStore);
                   },
                   deps: [Serializer]
-                })
+                }),
+        provide(AppViewListener, {useClass: AppViewListener})
       ];
     });
 
     function getRenderElement(elementRef: ElementRef) {
-      var renderView = <DefaultRenderView<Node>>uiRenderViewStore.deserializeRenderViewRef(
-          (<WebWorkerRenderViewRef>elementRef.renderView).refNumber);
-      return renderView.boundElements[elementRef.boundElementIndex];
+      var id = workerRenderStore.serialize(elementRef.nativeElement);
+      return uiRenderStore.deserialize(id);
+    }
+
+    function getRenderer(elementRef: ElementRef) {
+      return (<any>elementRef).internalElement.parentView.renderer;
     }
 
     it('should update text nodes',
@@ -154,28 +135,28 @@ export function main() {
        }));
 
     it('should update any element property/attributes/class/style independent of the compilation on the root element and other elements',
-       inject([TestComponentBuilder, Renderer, AsyncTestCompleter], (tcb: TestComponentBuilder,
-                                                                     renderer: Renderer, async) => {
+       inject([TestComponentBuilder, AsyncTestCompleter], (tcb: TestComponentBuilder, async) => {
          tcb.overrideView(MyComp, new ViewMetadata(
                                       {template: '<input [title]="y" style="position:absolute">'}))
              .createAsync(MyComp)
              .then((fixture) => {
                var checkSetters = (elr) => {
+                 var renderer = getRenderer(elr);
                  var el = getRenderElement(elr);
-                 renderer.setElementProperty(elr, 'tabIndex', 1);
+                 renderer.setElementProperty(elr.nativeElement, 'tabIndex', 1);
                  expect((<HTMLInputElement>el).tabIndex).toEqual(1);
 
-                 renderer.setElementClass(elr, 'a', true);
+                 renderer.setElementClass(elr.nativeElement, 'a', true);
                  expect(DOM.hasClass(el, 'a')).toBe(true);
-                 renderer.setElementClass(elr, 'a', false);
+                 renderer.setElementClass(elr.nativeElement, 'a', false);
                  expect(DOM.hasClass(el, 'a')).toBe(false);
 
-                 renderer.setElementStyle(elr, 'width', '10px');
+                 renderer.setElementStyle(elr.nativeElement, 'width', '10px');
                  expect(DOM.getStyle(el, 'width')).toEqual('10px');
-                 renderer.setElementStyle(elr, 'width', null);
+                 renderer.setElementStyle(elr.nativeElement, 'width', null);
                  expect(DOM.getStyle(el, 'width')).toEqual('');
 
-                 renderer.setElementAttribute(elr, 'someattr', 'someValue');
+                 renderer.setElementAttribute(elr.nativeElement, 'someattr', 'someValue');
                  expect(DOM.getAttribute(el, 'someattr')).toEqual('someValue');
                };
 
@@ -189,20 +170,19 @@ export function main() {
        }));
 
     it('should update any template comment property/attributes',
-       inject([TestComponentBuilder, Renderer, AsyncTestCompleter],
-              (tcb: TestComponentBuilder, renderer: Renderer, async) => {
-                var tpl = '<template [ngIf]="ctxBoolProp"></template>';
-                tcb.overrideView(MyComp, new ViewMetadata({template: tpl, directives: [NgIf]}))
-
-                    .createAsync(MyComp)
-                    .then((fixture) => {
-                      (<MyComp>fixture.debugElement.componentInstance).ctxBoolProp = true;
-                      fixture.detectChanges();
-                      var el = getRenderElement(fixture.debugElement.elementRef);
-                      expect(DOM.getInnerHTML(el)).toContain('"ng-reflect-ng-if": "true"');
-                      async.done();
-                    });
-              }));
+       inject([TestComponentBuilder, AsyncTestCompleter], (tcb: TestComponentBuilder, async) => {
+         var tpl = '<template [ngIf]="ctxBoolProp"></template>';
+         tcb.overrideView(MyComp, new ViewMetadata({template: tpl, directives: [NgIf]}))
+
+             .createAsync(MyComp)
+             .then((fixture) => {
+               (<MyComp>fixture.debugElement.componentInstance).ctxBoolProp = true;
+               fixture.detectChanges();
+               var el = getRenderElement(fixture.debugElement.elementRef);
+               expect(DOM.getInnerHTML(el)).toContain('"ng-reflect-ng-if": "true"');
+               async.done();
+             });
+       }));
 
     it('should add and remove fragments',
        inject([TestComponentBuilder, AsyncTestCompleter], (tcb: TestComponentBuilder, async) => {
@@ -229,19 +209,35 @@ export function main() {
        }));
 
     if (DOM.supportsDOMEvents()) {
-      it('should call actions on the element independent of the compilation',
-         inject([TestComponentBuilder, Renderer, AsyncTestCompleter],
-                (tcb: TestComponentBuilder, renderer: Renderer, async) => {
-                  tcb.overrideView(MyComp, new ViewMetadata({template: '<input [title]="y">'}))
-                      .createAsync(MyComp)
-                      .then((fixture) => {
-                        var elRef = fixture.debugElement.componentViewChildren[0].elementRef;
-                        renderer.invokeElementMethod(elRef, 'setAttribute', ['a', 'b']);
-
-                        expect(DOM.getAttribute(getRenderElement(elRef), 'a')).toEqual('b');
-                        async.done();
-                      });
-                }));
+      it('should call actions on the element',
+         inject([TestComponentBuilder, AsyncTestCompleter], (tcb: TestComponentBuilder, async) => {
+           tcb.overrideView(MyComp, new ViewMetadata({template: '<input [title]="y">'}))
+               .createAsync(MyComp)
+               .then((fixture) => {
+                 var elRef = fixture.debugElement.componentViewChildren[0].elementRef;
+                 getRenderer(elRef)
+                     .invokeElementMethod(elRef.nativeElement, 'setAttribute', ['a', 'b']);
+
+                 expect(DOM.getAttribute(getRenderElement(elRef), 'a')).toEqual('b');
+                 async.done();
+               });
+         }));
+
+      it('should listen to events',
+         inject([TestComponentBuilder, AsyncTestCompleter], (tcb: TestComponentBuilder, async) => {
+           tcb.overrideView(MyComp,
+                            new ViewMetadata({template: '<input (change)="ctxNumProp = 1">'}))
+               .createAsync(MyComp)
+               .then((fixture) => {
+                 var elRef = fixture.debugElement.componentViewChildren[0].elementRef;
+                 dispatchEvent(getRenderElement(elRef), 'change');
+                 expect(fixture.componentInstance.ctxNumProp).toBe(1);
+
+                 fixture.destroy();
+
+                 async.done();
+               });
+         }));
     }
   });
 }
diff --git a/modules/benchmarks/e2e_test/element_injector_perf.dart b/modules/benchmarks/e2e_test/element_injector_perf.dart
deleted file mode 100644
index 022c55d..0000000
--- a/modules/benchmarks/e2e_test/element_injector_perf.dart
+++ /dev/null
@@ -1,3 +0,0 @@
-library benchmarks.e2e_test.element_injector_perf;
-
-main() {}
diff --git a/modules/benchmarks/e2e_test/element_injector_perf.ts b/modules/benchmarks/e2e_test/element_injector_perf.ts
deleted file mode 100644
index 030dd69..0000000
--- a/modules/benchmarks/e2e_test/element_injector_perf.ts
+++ /dev/null
@@ -1,31 +0,0 @@
-import {runClickBenchmark, verifyNoBrowserErrors} from 'angular2/src/testing/perf_util';
-
-describe('ng2 element injector benchmark', function() {
-
-  var URL = 'benchmarks/src/element_injector/element_injector_benchmark.html';
-
-  afterEach(verifyNoBrowserErrors);
-
-  it('should log the stats for instantiate', function(done) {
-    runClickBenchmark({
-      url: URL,
-      buttons: ['#instantiate'],
-      id: 'ng2.elementInjector.instantiate',
-      params: [{name: 'iterations', value: 20000, scale: 'linear'}],
-      microMetrics: {'instantiateAvg': 'avg time for injection (in ms)'},
-      waitForAngular2: false
-    }).then(done, done.fail);
-  });
-
-  it('should log the stats for hydrate', function(done) {
-    runClickBenchmark({
-      url: URL,
-      buttons: ['#hydrate'],
-      id: 'ng2.elementInjector.hydrate',
-      params: [{name: 'iterations', value: 20000, scale: 'linear'}],
-      microMetrics: {'instantiateAvg': 'avg time for injection (in ms)'},
-      waitForAngular2: false
-    }).then(done, done.fail);
-  });
-
-});
diff --git a/modules/benchmarks/e2e_test/largetable_perf.ts b/modules/benchmarks/e2e_test/largetable_perf.ts
index be348c8..2cc96f0 100644
--- a/modules/benchmarks/e2e_test/largetable_perf.ts
+++ b/modules/benchmarks/e2e_test/largetable_perf.ts
@@ -29,21 +29,6 @@ describe('ng2 largetable benchmark', function() {
     });
   });
 
-  it('should log the stats without viewcache', function(done) {
-    runClickBenchmark({
-      url: URL,
-      buttons: ['#ng2DestroyDom', '#ng2CreateDom'],
-      id: 'ng2.largetable.interpolation.plain',
-      params: [
-        {name: 'rows', value: 20, scale: 'sqrt'},
-        {name: 'columns', value: 20, scale: 'sqrt'},
-        {name: 'benchmarkType', value: 'interpolation'},
-        {name: 'viewcache', value: 'false'}
-      ]
-    }).then(done, done.fail);
-  });
-
-
   it('should log the baseline stats', function(done) {
     runClickBenchmark({
       url: URL,
diff --git a/modules/benchmarks/e2e_test/static_tree_perf.ts b/modules/benchmarks/e2e_test/static_tree_perf.ts
index 93d2a8e..77f57b8 100644
--- a/modules/benchmarks/e2e_test/static_tree_perf.ts
+++ b/modules/benchmarks/e2e_test/static_tree_perf.ts
@@ -6,31 +6,19 @@ describe('ng2 static tree benchmark', function() {
 
   afterEach(verifyNoBrowserErrors);
 
-  it('should log the ng stats with viewcache', function(done) {
-    runClickBenchmark({
-      url: URL,
-      buttons: ['#ng2DestroyDom', '#ng2CreateDom'],
-      id: 'ng2.static.tree.create.viewcache',
-      params: [{name: 'viewcache', value: 'true'}]
-    }).then(done, done.fail);
-  });
-
-  it('should log the ng stats without viewcache', function(done) {
+  it('should log the ng stats', function(done) {
     runClickBenchmark({
       url: URL,
       buttons: ['#ng2DestroyDom', '#ng2CreateDom'],
       id: 'ng2.static.tree.create.plain',
-      params: [{name: 'viewcache', value: 'false'}]
+      params: []
     }).then(done, done.fail);
   });
 
   it('should log the ng stats (update)', function(done) {
-    runClickBenchmark({
-      url: URL,
-      buttons: ['#ng2CreateDom'],
-      id: 'ng2.static.tree.update',
-      params: [{name: 'viewcache', value: 'true'}]
-    }).then(done, done.fail);
+    runClickBenchmark(
+        {url: URL, buttons: ['#ng2CreateDom'], id: 'ng2.static.tree.update', params: []})
+        .then(done, done.fail);
   });
 
   it('should log the baseline stats', function(done) {
@@ -38,17 +26,14 @@ describe('ng2 static tree benchmark', function() {
       url: URL,
       buttons: ['#baselineDestroyDom', '#baselineCreateDom'],
       id: 'baseline.static.tree.create',
-      params: [{name: 'depth', value: 9, scale: 'log2'}]
+      params: []
     }).then(done, done.fail);
   });
 
   it('should log the baseline stats (update)', function(done) {
-    runClickBenchmark({
-      url: URL,
-      buttons: ['#baselineCreateDom'],
-      id: 'baseline.static.tree.update',
-      params: [{name: 'depth', value: 9, scale: 'log2'}]
-    }).then(done, done.fail);
+    runClickBenchmark(
+        {url: URL, buttons: ['#baselineCreateDom'], id: 'baseline.static.tree.update', params: []})
+        .then(done, done.fail);
   });
 
 });
diff --git a/modules/benchmarks/e2e_test/tree_perf.ts b/modules/benchmarks/e2e_test/tree_perf.ts
index 31b552c..a8e915f 100644
--- a/modules/benchmarks/e2e_test/tree_perf.ts
+++ b/modules/benchmarks/e2e_test/tree_perf.ts
@@ -6,21 +6,12 @@ describe('ng2 tree benchmark', function() {
 
   afterEach(verifyNoBrowserErrors);
 
-  it('should log the ng stats with viewcache', function(done) {
-    runClickBenchmark({
-      url: URL,
-      buttons: ['#ng2DestroyDom', '#ng2CreateDom'],
-      id: 'ng2.tree.create.viewcache',
-      params: [{name: 'depth', value: 9, scale: 'log2'}, {name: 'viewcache', value: 'true'}]
-    }).then(done, done.fail);
-  });
-
-  it('should log the ng stats without viewcache', function(done) {
+  it('should log the ng stats', function(done) {
     runClickBenchmark({
       url: URL,
       buttons: ['#ng2DestroyDom', '#ng2CreateDom'],
       id: 'ng2.tree.create.plain',
-      params: [{name: 'depth', value: 9, scale: 'log2'}, {name: 'viewcache', value: 'false'}]
+      params: [{name: 'depth', value: 9, scale: 'log2'}]
     }).then(done, done.fail);
   });
 
@@ -29,7 +20,7 @@ describe('ng2 tree benchmark', function() {
       url: URL,
       buttons: ['#ng2CreateDom'],
       id: 'ng2.tree.update',
-      params: [{name: 'depth', value: 9, scale: 'log2'}, {name: 'viewcache', value: 'true'}]
+      params: [{name: 'depth', value: 9, scale: 'log2'}]
     }).then(done, done.fail);
   });
 
diff --git a/modules/benchmarks/src/change_detection/change_detection_benchmark.ts b/modules/benchmarks/src/change_detection/change_detection_benchmark.ts
index 00e9152..8417f4c 100644
--- a/modules/benchmarks/src/change_detection/change_detection_benchmark.ts
+++ b/modules/benchmarks/src/change_detection/change_detection_benchmark.ts
@@ -245,13 +245,12 @@ function runBaselineWrites(baselineHead, numberOfRuns, object) {
 // ---- CHANGE DETECTION
 
 function setUpChangeDetection(protoChangeDetectorFactory: Function, iterations, object) {
-  var dispatcher = new DummyDispatcher();
   var parser = new Parser(new Lexer());
 
   var genConfig = new ChangeDetectorGenConfig(false, false, true);
   var parentProto = protoChangeDetectorFactory(
       new ChangeDetectorDefinition('parent', null, [], [], [], [], genConfig));
-  var parentCd = parentProto.instantiate(dispatcher);
+  var parentCd = parentProto.instantiate();
 
   var directiveRecord = new DirectiveRecord({directiveIndex: new DirectiveIndex(0, 0)});
   var bindings = [
@@ -281,10 +280,10 @@ function setUpChangeDetection(protoChangeDetectorFactory: Function, iterations,
       new ChangeDetectorDefinition("proto", null, [], bindings, [], [directiveRecord], genConfig));
 
   var targetObj = new Obj();
-  parentCd.hydrate(object, null, new FakeDirectives(targetObj), null);
+  parentCd.hydrate(object, null, new DummyDispatcher(targetObj), null);
   for (var i = 0; i < iterations; ++i) {
-    var cd = proto.instantiate(dispatcher);
-    cd.hydrate(object, null, new FakeDirectives(targetObj), null);
+    var cd = proto.instantiate();
+    cd.hydrate(object, null, new DummyDispatcher(targetObj), null);
     parentCd.addContentChild(cd);
   }
   return parentCd;
@@ -374,20 +373,17 @@ export function main() {
   }
 }
 
-class FakeDirectives {
+class DummyDispatcher implements ChangeDispatcher {
   targetObj: Obj;
-
   constructor(targetObj) { this.targetObj = targetObj; }
-
-  getDirectiveFor(record) { return this.targetObj; }
-}
-
-class DummyDispatcher implements ChangeDispatcher {
-  getDebugContext(elementIndex: number, directiveIndex: DirectiveIndex): DebugContext {
+  getDebugContext(appElement: any, elementIndex: number, directiveIndex: number): DebugContext {
     throw "getDebugContext not implemented.";
   }
   notifyOnBinding(bindingTarget, newValue) { throw "Should not be used"; }
   logBindingUpdate(bindingTarget, newValue) { throw "Should not be used"; }
   notifyAfterContentChecked() {}
   notifyAfterViewChecked() {}
+  notifyOnDestroy() {}
+  getDetectorFor(directiveIndex: DirectiveIndex): any { throw "getDetectorFor not implemented."; }
+  getDirectiveFor(record) { return this.targetObj; }
 }
diff --git a/modules/benchmarks/src/element_injector/element_injector_benchmark.html b/modules/benchmarks/src/element_injector/element_injector_benchmark.html
deleted file mode 100644
index 409d5fb..0000000
--- a/modules/benchmarks/src/element_injector/element_injector_benchmark.html
+++ /dev/null
@@ -1,21 +0,0 @@
-<!doctype html>
-<html>
-<body>
-
-<h2>Params</h2>
-<form>
-  Iterations:
-  <input type="number" name="iterations" placeholder="iterations" value="20000">
-  <br>
-  <button>Apply</button>
-</form>
-
-<h2>Actions</h2>
-<p>
-<button id="instantiate">instantiate</button>
-<button id="hydrate">hydrate</button>
-</p>
-
-$SCRIPTS$
-</body>
-</html>
diff --git a/modules/benchmarks/src/element_injector/element_injector_benchmark.ts b/modules/benchmarks/src/element_injector/element_injector_benchmark.ts
deleted file mode 100644
index 3c674c3..0000000
--- a/modules/benchmarks/src/element_injector/element_injector_benchmark.ts
+++ /dev/null
@@ -1,54 +0,0 @@
-import {reflector} from 'angular2/src/core/reflection/reflection';
-import {ReflectionCapabilities} from 'angular2/src/core/reflection/reflection_capabilities';
-import {Injectable, Injector} from 'angular2/core';
-import {ProtoElementInjector, DirectiveProvider} from 'angular2/src/core/linker/element_injector';
-import {getIntParameter, bindAction, microBenchmark} from 'angular2/src/testing/benchmark_util';
-import {BrowserDomAdapter} from 'angular2/src/platform/browser/browser_adapter';
-
-var count = 0;
-
-export function main() {
-  BrowserDomAdapter.makeCurrent();
-  var iterations = getIntParameter('iterations');
-
-  reflector.reflectionCapabilities = new ReflectionCapabilities();
-  var providers = [
-    DirectiveProvider.createFromType(A, null),
-    DirectiveProvider.createFromType(B, null),
-    DirectiveProvider.createFromType(C, null)
-  ];
-  var proto = ProtoElementInjector.create(null, 0, providers, false, 0, null);
-  var elementInjector = proto.instantiate(null);
-
-  function instantiate() {
-    for (var i = 0; i < iterations; ++i) {
-      var ei = proto.instantiate(null);
-      ei.hydrate(null, null, null);
-    }
-  }
-
-  function hydrate() {
-    for (var i = 0; i < iterations; ++i) {
-      elementInjector.dehydrate();
-      elementInjector.hydrate(null, null, null);
-    }
-  }
-
-  bindAction('#instantiate', () => microBenchmark('instantiateAvg', iterations, instantiate));
-  bindAction('#hydrate', () => microBenchmark('instantiateAvg', iterations, hydrate));
-}
-
-@Injectable()
-class A {
-  constructor() { count++; }
-}
-
-@Injectable()
-class B {
-  constructor() { count++; }
-}
-
-@Injectable()
-class C {
-  constructor(a: A, b: B) { count++; }
-}
diff --git a/modules/benchmarks/src/largetable/largetable_benchmark.ts b/modules/benchmarks/src/largetable/largetable_benchmark.ts
index b776122..362eb17 100644
--- a/modules/benchmarks/src/largetable/largetable_benchmark.ts
+++ b/modules/benchmarks/src/largetable/largetable_benchmark.ts
@@ -12,7 +12,6 @@ import {Component, Directive, View, bind, provide} from 'angular2/core';
 import {NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/common';
 import {ApplicationRef} from 'angular2/src/core/application_ref';
 import {BrowserDomAdapter} from 'angular2/src/platform/browser/browser_adapter';
-import {APP_VIEW_POOL_CAPACITY} from 'angular2/src/core/linker/view_pool';
 
 import {ListWrapper} from 'angular2/src/facade/collection';
 
@@ -24,12 +23,10 @@ export const LARGETABLE_ROWS = 'LargetableComponent.rows';
 export const LARGETABLE_COLS = 'LargetableComponent.cols';
 
 function _createBindings() {
-  var viewCacheCapacity = getStringParameter('viewcache') == 'true' ? 10000 : 1;
   return [
     provide(BENCHMARK_TYPE, {useValue: getStringParameter('benchmarkType')}),
     provide(LARGETABLE_ROWS, {useValue: getIntParameter('rows')}),
-    provide(LARGETABLE_COLS, {useValue: getIntParameter('columns')}),
-    provide(APP_VIEW_POOL_CAPACITY, {useValue: viewCacheCapacity})
+    provide(LARGETABLE_COLS, {useValue: getIntParameter('columns')})
   ];
 }
 
diff --git a/modules/benchmarks/src/naive_infinite_scroll/index.ts b/modules/benchmarks/src/naive_infinite_scroll/index.ts
index abcbdcd..a25ebcb 100644
--- a/modules/benchmarks/src/naive_infinite_scroll/index.ts
+++ b/modules/benchmarks/src/naive_infinite_scroll/index.ts
@@ -2,7 +2,6 @@ import {bootstrap} from 'angular2/bootstrap';
 
 import {App} from './app';
 
-import {APP_VIEW_POOL_CAPACITY} from 'angular2/src/core/linker/view_pool';
 import {bind, provide} from 'angular2/core';
 
 export function main() {
@@ -10,5 +9,5 @@ export function main() {
 }
 
 function createBindings(): any[] {
-  return [provide(APP_VIEW_POOL_CAPACITY, {useValue: 100000})];
+  return [];
 }
diff --git a/modules/benchmarks/src/static_tree/tree_benchmark.ts b/modules/benchmarks/src/static_tree/tree_benchmark.ts
index aa8aa86..47ddc85 100644
--- a/modules/benchmarks/src/static_tree/tree_benchmark.ts
+++ b/modules/benchmarks/src/static_tree/tree_benchmark.ts
@@ -24,11 +24,9 @@ import {
   windowProfileEnd
 } from 'angular2/src/testing/benchmark_util';
 import {BrowserDomAdapter} from 'angular2/src/platform/browser/browser_adapter';
-import {APP_VIEW_POOL_CAPACITY} from 'angular2/src/core/linker/view_pool';
 
 function createBindings(): Provider[] {
-  var viewCacheCapacity = getStringParameter('viewcache') == 'true' ? 10000 : 0;
-  return [provide(APP_VIEW_POOL_CAPACITY, {useValue: viewCacheCapacity})];
+  return [];
 }
 
 function setupReflector() {
diff --git a/modules/benchmarks/src/tree/tree_benchmark.ts b/modules/benchmarks/src/tree/tree_benchmark.ts
index c179fac..c993b28 100644
--- a/modules/benchmarks/src/tree/tree_benchmark.ts
+++ b/modules/benchmarks/src/tree/tree_benchmark.ts
@@ -23,11 +23,9 @@ import {
   windowProfileEnd
 } from 'angular2/src/testing/benchmark_util';
 import {BrowserDomAdapter} from 'angular2/src/platform/browser/browser_adapter';
-import {APP_VIEW_POOL_CAPACITY} from 'angular2/src/core/linker/view_pool';
 
 function createProviders(): Provider[] {
-  var viewCacheCapacity = getStringParameter('viewcache') == 'true' ? 10000 : 1;
-  return [provide(APP_VIEW_POOL_CAPACITY, {useValue: viewCacheCapacity})];
+  return [];
 }
 
 var BASELINE_TREE_TEMPLATE;
diff --git a/modules/playground/src/hello_world/index.ts b/modules/playground/src/hello_world/index.ts
index ccf5338..15c5141 100644
--- a/modules/playground/src/hello_world/index.ts
+++ b/modules/playground/src/hello_world/index.ts
@@ -24,7 +24,9 @@ class GreetingService {
 class RedDec {
   // ElementRef is always injectable and it wraps the element on which the
   // directive was found by the compiler.
-  constructor(el: ElementRef, renderer: Renderer) { renderer.setElementStyle(el, 'color', 'red'); }
+  constructor(el: ElementRef, renderer: Renderer) {
+    renderer.setElementStyle(el.nativeElement, 'color', 'red');
+  }
 }
 
 // Angular 2.0 supports 2 basic types of directives:
diff --git a/modules/playground/src/observable_models/index.dart b/modules/playground/src/observable_models/index.dart
index c7fe3ee..3d5197f 100644
--- a/modules/playground/src/observable_models/index.dart
+++ b/modules/playground/src/observable_models/index.dart
@@ -2,13 +2,11 @@ library benchmarks.src.naive_infinite_scroll.index;
 
 import "package:angular2/bootstrap.dart" show bootstrap;
 import "app.dart" show App;
-import "package:angular2/src/core/linker/view_pool.dart"
-    show APP_VIEW_POOL_CAPACITY;
 import "package:angular2/core.dart" show bind;
 
 main() {
   bootstrap(App, createBindings());
 }
 List<dynamic> createBindings() {
-  return [bind(APP_VIEW_POOL_CAPACITY).toValue(100000)];
+  return [];
 }
diff --git a/modules/playground/src/web_workers/kitchen_sink/index_common.ts b/modules/playground/src/web_workers/kitchen_sink/index_common.ts
index 3c8f131..737ca01 100644
--- a/modules/playground/src/web_workers/kitchen_sink/index_common.ts
+++ b/modules/playground/src/web_workers/kitchen_sink/index_common.ts
@@ -13,7 +13,9 @@ class GreetingService {
 class RedDec {
   // ElementRef is always injectable and it wraps the element on which the
   // directive was found by the compiler.
-  constructor(el: ElementRef, renderer: Renderer) { renderer.setElementStyle(el, 'color', 'red'); }
+  constructor(el: ElementRef, renderer: Renderer) {
+    renderer.setElementStyle(el.nativeElement, 'color', 'red');
+  }
   // constructor(renderer: Renderer) {}
 }
 
diff --git a/modules_dart/angular2_testing/lib/angular2_testing.dart b/modules_dart/angular2_testing/lib/angular2_testing.dart
index da737b3..629e0f6 100644
--- a/modules_dart/angular2_testing/lib/angular2_testing.dart
+++ b/modules_dart/angular2_testing/lib/angular2_testing.dart
@@ -51,12 +51,11 @@ void setUpProviders(Iterable<Provider> providerFactory()) {
   setUp(() {
     try {
       _testInjector.addProviders(providerFactory());
-    } catch(e) {
+    } catch (e) {
       throw 'setUpProviders was called after the injector had '
           'been used in a setUp or test block. This invalidates the '
           'test injector';
     }
-
   });
 
   _addTestInjectorTearDown();
diff --git a/modules_dart/transform/lib/src/transform/common/annotation_matcher.dart b/modules_dart/transform/lib/src/transform/common/annotation_matcher.dart
index 137c0d1..af1c51c 100644
--- a/modules_dart/transform/lib/src/transform/common/annotation_matcher.dart
+++ b/modules_dart/transform/lib/src/transform/common/annotation_matcher.dart
@@ -48,6 +48,20 @@ const _COMPONENTS = const [
       superClass: 'Directive'),
 ];
 
+const _PIPES = const [
+  const ClassDescriptor(
+      'Pipe', 'package:angular2/src/core/metadata/directive.dart',
+      superClass: 'Injectable'),
+  const ClassDescriptor('Pipe', 'package:angular2/src/core/metadata.dart',
+      superClass: 'Injectable'),
+  const ClassDescriptor('Pipe', 'package:angular2/angular2.dart',
+      superClass: 'Injectable'),
+  const ClassDescriptor('Pipe', 'package:angular2/core.dart',
+      superClass: 'Injectable'),
+  const ClassDescriptor('Pipe', 'package:angular2/web_worker/worker.dart',
+      superClass: 'Injectable'),
+];
+
 const _VIEWS = const [
   const ClassDescriptor('View', 'package:angular2/angular2.dart'),
   const ClassDescriptor('View', 'package:angular2/web_worker/worker.dart'),
@@ -79,6 +93,7 @@ class AnnotationMatcher extends ClassMatcherBase {
     return new AnnotationMatcher._([]
       ..addAll(_COMPONENTS)
       ..addAll(_DIRECTIVES)
+      ..addAll(_PIPES)
       ..addAll(_INJECTABLES)
       ..addAll(_VIEWS)
       ..addAll(_ENTRYPOINTS));
@@ -109,6 +124,10 @@ class AnnotationMatcher extends ClassMatcherBase {
   bool isView(Annotation annotation, AssetId assetId) =>
       _implementsWithWarning(annotation, assetId, _VIEWS);
 
+  /// Checks if an [Annotation] node implements [Pipe].
+  bool isPipe(Annotation annotation, AssetId assetId) =>
+      _implementsWithWarning(annotation, assetId, _PIPES);
+
   /// Checks if an [Annotation] node implements [AngularEntrypoint]
   bool isEntrypoint(Annotation annotation, AssetId assetId) =>
       _implementsWithWarning(annotation, assetId, _ENTRYPOINTS);
diff --git a/modules_dart/transform/lib/src/transform/common/code/reflection_info_code.dart b/modules_dart/transform/lib/src/transform/common/code/reflection_info_code.dart
index b3ff095..403bab7 100644
--- a/modules_dart/transform/lib/src/transform/common/code/reflection_info_code.dart
+++ b/modules_dart/transform/lib/src/transform/common/code/reflection_info_code.dart
@@ -79,26 +79,34 @@ class ReflectionInfoVisitor extends RecursiveAstVisitor<ReflectionInfoModel> {
     }
 
     if (node.metadata != null) {
-      var componentDirectives, viewDirectives;
+      var componentDirectives = new Iterable.empty();
+      var componentPipes = new Iterable.empty();
+      var viewDirectives, viewPipes;
       node.metadata.forEach((node) {
         if (_annotationMatcher.isComponent(node, assetId)) {
-          componentDirectives = _extractDirectives(node);
+          componentDirectives = _extractReferencedTypes(node, 'directives');
+          componentPipes = _extractReferencedTypes(node, 'pipes');
         } else if (_annotationMatcher.isView(node, assetId)) {
-          viewDirectives = _extractDirectives(node);
+          viewDirectives = _extractReferencedTypes(node, 'directives');
+          viewPipes = _extractReferencedTypes(node, 'pipes');
         }
         model.annotations.add(_annotationVisitor.visitAnnotation(node));
       });
-      if (componentDirectives != null && componentDirectives.isNotEmpty) {
-        if (viewDirectives != null) {
-          log.warning(
-              'Cannot specify view parameters on @Component when a @View '
-              'is present. Component name: ${model.name}',
-              asset: assetId);
-        }
-        model.directives.addAll(componentDirectives);
-      } else if (viewDirectives != null) {
+      if ((componentDirectives.isNotEmpty || componentPipes.isNotEmpty) &&
+          (viewDirectives != null || viewPipes != null)) {
+        log.warning(
+            'Cannot specify view parameters on @Component when a @View '
+            'is present. Component name: ${model.name}',
+            asset: assetId);
+      }
+      model.directives.addAll(componentDirectives);
+      model.pipes.addAll(componentPipes);
+      if (viewDirectives != null) {
         model.directives.addAll(viewDirectives);
       }
+      if (viewPipes != null) {
+        model.pipes.addAll(viewPipes);
+      }
     }
     if (ctor != null &&
         ctor.parameters != null &&
@@ -151,43 +159,44 @@ class ReflectionInfoVisitor extends RecursiveAstVisitor<ReflectionInfoModel> {
     }
   }
 
-  /// Returns [PrefixedDirective] values parsed from the value of the
-  /// `directives` parameter of the provided `node`.
-  /// This will always return a non-null value, so if there are no `directives`
-  /// specified on `node`, it will return an empty iterable.
-  Iterable<PrefixedDirective> _extractDirectives(Annotation node) {
+  /// Returns [PrefixedType] values parsed from the value of the
+  /// `fieldName` parameter of the provided `node`.
+  /// This will always return a non-null value, so if there is no field
+  /// called `fieldName`, it will return an empty iterable.
+  Iterable<PrefixedType> _extractReferencedTypes(
+      Annotation node, String fieldName) {
     assert(_annotationMatcher.isComponent(node, assetId) ||
         _annotationMatcher.isView(node, assetId));
 
     if (node.arguments == null && node.arguments.arguments == null) {
       return const [];
     }
-    final directivesNode = node.arguments.arguments.firstWhere((arg) {
-      return arg is NamedExpression && '${arg.name.label}' == 'directives';
+    final typesNode = node.arguments.arguments.firstWhere((arg) {
+      return arg is NamedExpression && '${arg.name.label}' == fieldName;
     }, orElse: () => null);
-    if (directivesNode == null) return const [];
+    if (typesNode == null) return const [];
 
-    if (directivesNode.expression is! ListLiteral) {
+    if (typesNode.expression is! ListLiteral) {
       log.warning(
-          'Angular 2 expects a list literal for `directives` '
-          'but found a ${directivesNode.expression.runtimeType}',
+          'Angular 2 expects a list literal for `${fieldName}` '
+          'but found a ${typesNode.expression.runtimeType}',
           asset: assetId);
       return const [];
     }
-    final directives = <PrefixedDirective>[];
-    for (var dep in (directivesNode.expression as ListLiteral).elements) {
+    final types = <PrefixedType>[];
+    for (var dep in (typesNode.expression as ListLiteral).elements) {
       if (dep is PrefixedIdentifier) {
-        directives.add(new PrefixedDirective()
+        types.add(new PrefixedType()
           ..prefix = '${dep.prefix}'
           ..name = '${dep.identifier}');
       } else if (dep is Identifier) {
-        directives.add(new PrefixedDirective()..name = '${dep}');
+        types.add(new PrefixedType()..name = '${dep}');
       } else {
-        log.warning('Found unexpected value $dep in `directives`.',
+        log.warning('Ignoring unexpected value $dep in `${fieldName}`.',
             asset: assetId);
       }
     }
-    return directives;
+    return types;
   }
 
   @override
diff --git a/modules_dart/transform/lib/src/transform/common/directive_metadata_reader.dart b/modules_dart/transform/lib/src/transform/common/directive_metadata_reader.dart
deleted file mode 100644
index f8188ee..0000000
--- a/modules_dart/transform/lib/src/transform/common/directive_metadata_reader.dart
+++ /dev/null
@@ -1,552 +0,0 @@
-library angular2.transform.common.directive_metadata_reader;
-
-import 'dart:async';
-
-import 'package:analyzer/analyzer.dart';
-
-import 'package:angular2/src/compiler/directive_metadata.dart';
-import 'package:angular2/src/compiler/template_compiler.dart';
-
-import 'package:angular2/src/core/change_detection/change_detection.dart';
-import 'package:angular2/src/core/linker/interfaces.dart' show LifecycleHooks;
-import 'package:angular2/src/core/metadata/view.dart' show ViewEncapsulation;
-import 'package:angular2/src/transform/common/annotation_matcher.dart';
-import 'package:angular2/src/transform/common/interface_matcher.dart';
-import 'package:angular2/src/transform/common/logging.dart';
-import 'package:barback/barback.dart' show AssetId;
-
-import 'naive_eval.dart';
-
-class DirectiveMetadataReader {
-  final _DirectiveMetadataVisitor _visitor;
-  final TemplateCompiler _templateCompiler;
-
-  DirectiveMetadataReader._(this._visitor, this._templateCompiler);
-
-  /// Accepts an [AnnotationMatcher] which tests that an [Annotation]
-  /// is a [Directive], [Component], or [View].
-  factory DirectiveMetadataReader(AnnotationMatcher annotationMatcher,
-      InterfaceMatcher interfaceMatcher, TemplateCompiler templateCompiler) {
-    var lifecycleVisitor = new _LifecycleHookVisitor(interfaceMatcher);
-    var visitor =
-        new _DirectiveMetadataVisitor(annotationMatcher, lifecycleVisitor);
-
-    return new DirectiveMetadataReader._(visitor, templateCompiler);
-  }
-
-  /// Reads *un-normalized* [CompileDirectiveMetadata] from the
-  /// [ClassDeclaration] `node`.
-  ///
-  /// `node` is expected to be a class which may have a [Directive] or [Component]
-  /// annotation. If `node` does not have one of these annotations, this function
-  /// returns `null`.
-  ///
-  /// `assetId` is the [AssetId] from which `node` was read, unless `node` was
-  /// read from a part file, in which case `assetId` should be the [AssetId] of
-  /// the parent file.
-  Future<CompileDirectiveMetadata> readDirectiveMetadata(
-      ClassDeclaration node, AssetId assetId) {
-    _visitor.reset(assetId);
-    node.accept(_visitor);
-    if (!_visitor.hasMetadata) {
-      return new Future.value(null);
-    } else {
-      final metadata = _visitor.createMetadata();
-      return _templateCompiler.normalizeDirectiveMetadata(metadata);
-    }
-  }
-}
-
-/// Evaluates the [Map] represented by `expression` and adds all `key`,
-/// `value` pairs to `map`. If `expression` does not evaluate to a [Map],
-/// throws a descriptive [FormatException].
-void _populateMap(Expression expression, Map map, String propertyName) {
-  var evaluated = naiveEval(expression);
-  if (evaluated is! Map) {
-    throw new FormatException(
-        'Angular 2 expects a Map but could not understand the value for '
-        '$propertyName.',
-        '$expression' /* source */);
-  }
-  evaluated.forEach((key, value) {
-    if (value != null) {
-      map[key] = '$value';
-    }
-  });
-}
-
-/// Evaluates the [List] represented by `expression` and adds all values,
-/// to `list`. If `expression` does not evaluate to a [List], throws a
-/// descriptive [FormatException].
-void _populateList(
-    Expression expression, List<String> list, String propertyName) {
-  var evaluated = naiveEval(expression);
-  if (evaluated is! List) {
-    throw new FormatException(
-        'Angular 2 expects a List but could not understand the value for '
-        '$propertyName.',
-        '$expression' /* source */);
-  }
-  list.addAll(evaluated.map((e) => e.toString()));
-}
-
-/// Evaluates `node` and expects that the result will be a string. If not,
-/// throws a [FormatException].
-String _expressionToString(Expression node, String nodeDescription) {
-  var value = naiveEval(node);
-  if (value is! String) {
-    throw new FormatException(
-        'Angular 2 could not understand the value '
-        'in $nodeDescription.',
-        '$node' /* source */);
-  }
-  return value;
-}
-
-/// Visitor responsible for processing a [Directive] annotated
-/// [ClassDeclaration] and creating a [CompileDirectiveMetadata] object.
-class _DirectiveMetadataVisitor extends Object
-    with RecursiveAstVisitor<Object> {
-  /// Tests [Annotation]s to determine if they deifne a [Directive],
-  /// [Component], [View], or none of these.
-  final AnnotationMatcher _annotationMatcher;
-
-  final _LifecycleHookVisitor _lifecycleVisitor;
-
-  /// The [AssetId] we are currently processing.
-  AssetId _assetId;
-
-  _DirectiveMetadataVisitor(this._annotationMatcher, this._lifecycleVisitor) {
-    reset(null);
-  }
-
-  /// Whether the visitor has found a [Component] or [Directive] annotation
-  /// since the last call to `reset`.
-  bool _hasMetadata = false;
-
-  // Annotation fields
-  CompileTypeMetadata _type;
-  bool _isComponent;
-  String _selector;
-  String _exportAs;
-  ChangeDetectionStrategy _changeDetection;
-  List<String> _inputs;
-  List<String> _outputs;
-  Map<String, String> _host;
-  List<LifecycleHooks> _lifecycleHooks;
-  CompileTemplateMetadata _cmpTemplate;
-  CompileTemplateMetadata _viewTemplate;
-
-  void reset(AssetId assetId) {
-    _lifecycleVisitor.reset(assetId);
-    _assetId = assetId;
-
-    _type = null;
-    _isComponent = false;
-    _hasMetadata = false;
-    _selector = '';
-    _exportAs = null;
-    _changeDetection = ChangeDetectionStrategy.Default;
-    _inputs = <String>[];
-    _outputs = <String>[];
-    _host = <String, String>{};
-    _lifecycleHooks = null;
-    _cmpTemplate = null;
-    _viewTemplate = null;
-  }
-
-  bool get hasMetadata => _hasMetadata;
-
-  get _template => _viewTemplate != null ? _viewTemplate : _cmpTemplate;
-
-  CompileDirectiveMetadata createMetadata() {
-    return CompileDirectiveMetadata.create(
-        type: _type,
-        isComponent: _isComponent,
-        dynamicLoadable: true,
-        // NOTE(kegluneq): For future optimization.
-        selector: _selector,
-        exportAs: _exportAs,
-        changeDetection: _changeDetection,
-        inputs: _inputs,
-        outputs: _outputs,
-        host: _host,
-        lifecycleHooks: _lifecycleHooks,
-        template: _template);
-  }
-
-  /// Ensures that we do not specify View values on an `@Component` annotation
-  /// when there is a @View annotation present.
-  void _validateTemplates() {
-    if (_cmpTemplate != null && _viewTemplate != null) {
-      var name = '(Unknown)';
-      if (_type != null && _type.name != null && _type.name.isNotEmpty) {
-        name = _type.name;
-      }
-      log.warning(
-          'Cannot specify view parameters on @Component when a @View '
-          'is present. Component name: ${name}',
-          asset: _assetId);
-    }
-  }
-
-  @override
-  Object visitAnnotation(Annotation node) {
-    var isComponent = _annotationMatcher.isComponent(node, _assetId);
-    var isDirective = _annotationMatcher.isDirective(node, _assetId);
-    if (isDirective) {
-      if (_hasMetadata) {
-        throw new FormatException(
-            'Only one Directive is allowed per class. '
-            'Found unexpected "$node".',
-            '$node' /* source */);
-      }
-      _isComponent = isComponent;
-      _hasMetadata = true;
-      if (isComponent) {
-        _cmpTemplate =
-            new _CompileTemplateMetadataVisitor().visitAnnotation(node);
-        _validateTemplates();
-      }
-      super.visitAnnotation(node);
-    } else if (_annotationMatcher.isView(node, _assetId)) {
-      if (_viewTemplate != null) {
-        // TODO(kegluneq): Support multiple views on a single class.
-        throw new FormatException(
-            'Only one View is allowed per class. '
-            'Found unexpected "$node".',
-            '$node' /* source */);
-      }
-      _viewTemplate =
-          new _CompileTemplateMetadataVisitor().visitAnnotation(node);
-      _validateTemplates();
-    }
-
-    // Annotation we do not recognize - no need to visit.
-    return null;
-  }
-
-  @override
-  Object visitFieldDeclaration(FieldDeclaration node) {
-    for (var variable in node.fields.variables) {
-      for (var meta in node.metadata) {
-        if (_isAnnotation(meta, 'Output')) {
-          _addPropertyToType(_outputs, variable.name.toString(), meta);
-        }
-
-        if (_isAnnotation(meta, 'Input')) {
-          _addPropertyToType(_inputs, variable.name.toString(), meta);
-        }
-
-        if (_isAnnotation(meta, 'HostBinding')) {
-          final renamed = _getRenamedValue(meta);
-          if (renamed != null) {
-            _host['[${renamed}]'] = '${variable.name}';
-          } else {
-            _host['[${variable.name}]'] = '${variable.name}';
-          }
-        }
-      }
-    }
-    return null;
-  }
-
-  @override
-  Object visitMethodDeclaration(MethodDeclaration node) {
-    for (var meta in node.metadata) {
-      if (_isAnnotation(meta, 'Output') && node.isGetter) {
-        _addPropertyToType(_outputs, node.name.toString(), meta);
-      }
-
-      if (_isAnnotation(meta, 'Input') && node.isSetter) {
-        _addPropertyToType(_inputs, node.name.toString(), meta);
-      }
-
-      if (_isAnnotation(meta, 'HostListener')) {
-        if (meta.arguments.arguments.length == 0 ||
-            meta.arguments.arguments.length > 2) {
-          throw new ArgumentError(
-              'Incorrect value passed to HostListener. Expected 1 or 2.');
-        }
-
-        final eventName = _getHostListenerEventName(meta);
-        final params = _getHostListenerParams(meta);
-        _host['(${eventName})'] = '${node.name}($params)';
-      }
-    }
-    return null;
-  }
-
-  void _addPropertyToType(List type, String name, Annotation meta) {
-    final renamed = _getRenamedValue(meta);
-    if (renamed != null) {
-      type.add('${name}: ${renamed}');
-    } else {
-      type.add('${name}');
-    }
-  }
-
-  //TODO Use AnnotationMatcher instead of string matching
-  bool _isAnnotation(Annotation node, String annotationName) {
-    var id = node.name;
-    final name = id is PrefixedIdentifier ? '${id.identifier}' : '$id';
-    return name == annotationName;
-  }
-
-  String _getRenamedValue(Annotation node) {
-    if (node.arguments.arguments.length == 1) {
-      final renamed = naiveEval(node.arguments.arguments.single);
-      if (renamed is! String) {
-        throw new ArgumentError(
-            'Incorrect value. Expected a String, but got "${renamed}".');
-      }
-      return renamed;
-    } else {
-      return null;
-    }
-  }
-
-  String _getHostListenerEventName(Annotation node) {
-    final name = naiveEval(node.arguments.arguments.first);
-    if (name is! String) {
-      throw new ArgumentError(
-          'Incorrect event name. Expected a String, but got "${name}".');
-    }
-    return name;
-  }
-
-  String _getHostListenerParams(Annotation node) {
-    if (node.arguments.arguments.length == 2) {
-      return naiveEval(node.arguments.arguments[1]).join(',');
-    } else {
-      return "";
-    }
-  }
-
-  @override
-  Object visitClassDeclaration(ClassDeclaration node) {
-    node.metadata.accept(this);
-    if (this._hasMetadata) {
-      _type = new CompileTypeMetadata(
-          moduleUrl: 'asset:${_assetId.package}/${_assetId.path}',
-          name: node.name.toString(),
-          runtime: null // Intentionally `null`, cannot be provided here.
-          );
-      _lifecycleHooks = node.implementsClause != null
-          ? node.implementsClause.accept(_lifecycleVisitor)
-          : const [];
-
-      node.members.accept(this);
-    }
-    return null;
-  }
-
-  @override
-  Object visitNamedExpression(NamedExpression node) {
-    // TODO(kegluneq): Remove this limitation.
-    if (node.name is! Label || node.name.label is! SimpleIdentifier) {
-      throw new FormatException(
-          'Angular 2 currently only supports simple identifiers in directives.',
-          '$node' /* source */);
-    }
-    var keyString = '${node.name.label}';
-    switch (keyString) {
-      case 'selector':
-        _populateSelector(node.expression);
-        break;
-      case 'inputs':
-        _populateProperties(node.expression);
-        break;
-      case 'properties':
-        _populateProperties(node.expression);
-        break;
-      case 'host':
-        _populateHost(node.expression);
-        break;
-      case 'exportAs':
-        _populateExportAs(node.expression);
-        break;
-      case 'changeDetection':
-        _populateChangeDetection(node.expression);
-        break;
-      case 'outputs':
-        _populateEvents(node.expression);
-        break;
-      case 'events':
-        _populateEvents(node.expression);
-        break;
-    }
-    return null;
-  }
-
-  void _populateSelector(Expression selectorValue) {
-    _checkMeta();
-    _selector = _expressionToString(selectorValue, 'Directive#selector');
-  }
-
-  void _checkMeta() {
-    if (!_hasMetadata) {
-      throw new ArgumentError(
-          'Incorrect value passed to readDirectiveMetadata. '
-          'Expected type is ClassDeclaration');
-    }
-  }
-
-  void _populateProperties(Expression inputsValue) {
-    _checkMeta();
-    _populateList(inputsValue, _inputs, 'Directive#inputs');
-  }
-
-  void _populateHost(Expression hostValue) {
-    _checkMeta();
-    _populateMap(hostValue, _host, 'Directive#host');
-  }
-
-  void _populateExportAs(Expression exportAsValue) {
-    _checkMeta();
-    _exportAs = _expressionToString(exportAsValue, 'Directive#exportAs');
-  }
-
-  void _populateEvents(Expression outputsValue) {
-    _checkMeta();
-    _populateList(outputsValue, _outputs, 'Directive#outputs');
-  }
-
-  void _populateChangeDetection(Expression value) {
-    _checkMeta();
-    _changeDetection = _changeDetectionStrategies[value.toSource()];
-  }
-
-  static final Map<String, ChangeDetectionStrategy> _changeDetectionStrategies =
-      new Map.fromIterable(ChangeDetectionStrategy.values,
-          key: (v) => v.toString());
-}
-
-/// Visitor responsible for parsing an [ImplementsClause] and returning a
-/// [List<LifecycleHooks>] that the [Directive] subscribes to.
-class _LifecycleHookVisitor extends SimpleAstVisitor<List<LifecycleHooks>> {
-  /// Tests [Identifier]s of implemented interfaces to determine if they
-  /// correspond to [LifecycleHooks] values.
-  final InterfaceMatcher _ifaceMatcher;
-
-  /// The [AssetId] we are currently processing.
-  AssetId _assetId;
-
-  _LifecycleHookVisitor(this._ifaceMatcher);
-
-  void reset(AssetId assetId) {
-    _assetId = assetId;
-  }
-
-  @override
-  List<LifecycleHooks> visitImplementsClause(ImplementsClause node) {
-    if (node == null || node.interfaces == null) return const [];
-
-    return node.interfaces.map((TypeName ifaceTypeName) {
-      var id = ifaceTypeName.name;
-      if (_ifaceMatcher.isAfterContentChecked(id, _assetId)) {
-        return LifecycleHooks.AfterContentChecked;
-      } else if (_ifaceMatcher.isAfterContentInit(id, _assetId)) {
-        return LifecycleHooks.AfterContentInit;
-      } else if (_ifaceMatcher.isAfterViewChecked(id, _assetId)) {
-        return LifecycleHooks.AfterViewChecked;
-      } else if (_ifaceMatcher.isAfterViewInit(id, _assetId)) {
-        return LifecycleHooks.AfterViewInit;
-      } else if (_ifaceMatcher.isDoCheck(id, _assetId)) {
-        return LifecycleHooks.DoCheck;
-      } else if (_ifaceMatcher.isOnChange(id, _assetId)) {
-        return LifecycleHooks.OnChanges;
-      } else if (_ifaceMatcher.isOnDestroy(id, _assetId)) {
-        return LifecycleHooks.OnDestroy;
-      } else if (_ifaceMatcher.isOnInit(id, _assetId)) {
-        return LifecycleHooks.OnInit;
-      }
-      return null;
-    }).where((e) => e != null).toList(growable: false);
-  }
-}
-
-/// Visitor responsible for parsing a @View [Annotation] and producing a
-/// [CompileTemplateMetadata].
-class _CompileTemplateMetadataVisitor
-    extends RecursiveAstVisitor<CompileTemplateMetadata> {
-  ViewEncapsulation _encapsulation;
-  String _template;
-  String _templateUrl;
-  List<String> _styles;
-  List<String> _styleUrls;
-
-  @override
-  CompileTemplateMetadata visitAnnotation(Annotation node) {
-    super.visitAnnotation(node);
-
-    if (_encapsulation == null &&
-        _template == null &&
-        _templateUrl == null &&
-        _styles == null &&
-        _styleUrls == null) {
-      return null;
-    }
-
-    return new CompileTemplateMetadata(
-        encapsulation: _encapsulation,
-        template: _template,
-        templateUrl: _templateUrl,
-        styles: _styles,
-        styleUrls: _styleUrls);
-  }
-
-  @override
-  CompileTemplateMetadata visitNamedExpression(NamedExpression node) {
-    // TODO(kegluneq): Remove this limitation.
-    if (node.name is! Label || node.name.label is! SimpleIdentifier) {
-      throw new FormatException(
-          'Angular 2 currently only supports simple identifiers in directives.',
-          '$node' /* source */);
-    }
-    var keyString = '${node.name.label}';
-    switch (keyString) {
-      case 'encapsulation':
-        _populateEncapsulation(node.expression);
-        break;
-      case 'template':
-        _populateTemplate(node.expression);
-        break;
-      case 'templateUrl':
-        _populateTemplateUrl(node.expression);
-        break;
-      case 'styles':
-        _populateStyles(node.expression);
-        break;
-      case 'styleUrls':
-        _populateStyleUrls(node.expression);
-        break;
-    }
-    return null;
-  }
-
-  void _populateTemplate(Expression value) {
-    _template = _expressionToString(value, 'View#template');
-  }
-
-  void _populateTemplateUrl(Expression value) {
-    _templateUrl = _expressionToString(value, 'View#templateUrl');
-  }
-
-  void _populateStyles(Expression value) {
-    _styles = <String>[];
-    _populateList(value, _styles, 'View#styles');
-  }
-
-  void _populateStyleUrls(Expression value) {
-    _styleUrls = <String>[];
-    _populateList(value, _styleUrls, 'View#styleUrls');
-  }
-
-  void _populateEncapsulation(Expression value) {
-    _encapsulation = _viewEncapsulationMap[value.toSource()];
-  }
-
-  static final _viewEncapsulationMap =
-      new Map.fromIterable(ViewEncapsulation.values, key: (v) => v.toString());
-}
diff --git a/modules_dart/transform/lib/src/transform/common/interface_matcher.dart b/modules_dart/transform/lib/src/transform/common/interface_matcher.dart
index ac9916e..865a7c0 100644
--- a/modules_dart/transform/lib/src/transform/common/interface_matcher.dart
+++ b/modules_dart/transform/lib/src/transform/common/interface_matcher.dart
@@ -47,8 +47,7 @@ const _ON_AFTER_CONTENT_INIT_INTERFACES = const [
       'AfterContentInit', 'package:angular2/lifecycle_hooks.dart'),
   const ClassDescriptor(
       'AfterContentInit', 'package:angular2/src/core/linker.dart'),
-  const ClassDescriptor(
-      'AfterContentInit', 'package:angular2/core.dart'),
+  const ClassDescriptor('AfterContentInit', 'package:angular2/core.dart'),
   const ClassDescriptor(
       'AfterContentInit', 'package:angular2/src/core/linker/interfaces.dart')
 ];
@@ -59,8 +58,7 @@ const _ON_AFTER_CONTENT_CHECKED_INTERFACES = const [
       'AfterContentChecked', 'package:angular2/lifecycle_hooks.dart'),
   const ClassDescriptor(
       'AfterContentChecked', 'package:angular2/src/core/linker.dart'),
-  const ClassDescriptor(
-      'AfterContentChecked', 'package:angular2/core.dart'),
+  const ClassDescriptor('AfterContentChecked', 'package:angular2/core.dart'),
   const ClassDescriptor(
       'AfterContentChecked', 'package:angular2/src/core/linker/interfaces.dart')
 ];
@@ -70,8 +68,7 @@ const _ON_AFTER_VIEW_INIT_INTERFACES = const [
       'AfterViewInit', 'package:angular2/lifecycle_hooks.dart'),
   const ClassDescriptor(
       'AfterViewInit', 'package:angular2/src/core/linker.dart'),
-  const ClassDescriptor(
-      'AfterViewInit', 'package:angular2/core.dart'),
+  const ClassDescriptor('AfterViewInit', 'package:angular2/core.dart'),
   const ClassDescriptor(
       'AfterViewInit', 'package:angular2/src/core/linker/interfaces.dart')
 ];
@@ -81,8 +78,7 @@ const _ON_AFTER_VIEW_CHECKED_INTERFACES = const [
       'AfterViewChecked', 'package:angular2/lifecycle_hooks.dart'),
   const ClassDescriptor(
       'AfterViewChecked', 'package:angular2/src/core/linker.dart'),
-  const ClassDescriptor(
-      'AfterViewChecked', 'package:angular2/core.dart'),
+  const ClassDescriptor('AfterViewChecked', 'package:angular2/core.dart'),
   const ClassDescriptor(
       'AfterViewChecked', 'package:angular2/src/core/linker/interfaces.dart')
 ];
diff --git a/modules_dart/transform/lib/src/transform/common/model/reflection_info_model.pb.dart b/modules_dart/transform/lib/src/transform/common/model/reflection_info_model.pb.dart
index ae55179..a96d4e2 100644
--- a/modules_dart/transform/lib/src/transform/common/model/reflection_info_model.pb.dart
+++ b/modules_dart/transform/lib/src/transform/common/model/reflection_info_model.pb.dart
@@ -52,33 +52,32 @@ class PropertyMetadataModel extends GeneratedMessage {
 class _ReadonlyPropertyMetadataModel extends PropertyMetadataModel
     with ReadonlyMessageMixin {}
 
-class PrefixedDirective extends GeneratedMessage {
-  static final BuilderInfo _i = new BuilderInfo('PrefixedDirective')
+class PrefixedType extends GeneratedMessage {
+  static final BuilderInfo _i = new BuilderInfo('PrefixedType')
     ..a(1, 'prefix', PbFieldType.OS)
     ..a(2, 'name', PbFieldType.OS)
     ..hasRequiredFields = false;
 
-  PrefixedDirective() : super();
-  PrefixedDirective.fromBuffer(List<int> i,
+  PrefixedType() : super();
+  PrefixedType.fromBuffer(List<int> i,
       [ExtensionRegistry r = ExtensionRegistry.EMPTY])
       : super.fromBuffer(i, r);
-  PrefixedDirective.fromJson(String i,
+  PrefixedType.fromJson(String i,
       [ExtensionRegistry r = ExtensionRegistry.EMPTY])
       : super.fromJson(i, r);
-  PrefixedDirective clone() => new PrefixedDirective()..mergeFromMessage(this);
+  PrefixedType clone() => new PrefixedType()..mergeFromMessage(this);
   BuilderInfo get info_ => _i;
-  static PrefixedDirective create() => new PrefixedDirective();
-  static PbList<PrefixedDirective> createRepeated() =>
-      new PbList<PrefixedDirective>();
-  static PrefixedDirective getDefault() {
+  static PrefixedType create() => new PrefixedType();
+  static PbList<PrefixedType> createRepeated() => new PbList<PrefixedType>();
+  static PrefixedType getDefault() {
     if (_defaultInstance == null) _defaultInstance =
-        new _ReadonlyPrefixedDirective();
+        new _ReadonlyPrefixedType();
     return _defaultInstance;
   }
 
-  static PrefixedDirective _defaultInstance;
-  static void $checkItem(PrefixedDirective v) {
-    if (v is! PrefixedDirective) checkItemFailed(v, 'PrefixedDirective');
+  static PrefixedType _defaultInstance;
+  static void $checkItem(PrefixedType v) {
+    if (v is! PrefixedType) checkItemFailed(v, 'PrefixedType');
   }
 
   String get prefix => $_get(0, 1, '');
@@ -98,8 +97,7 @@ class PrefixedDirective extends GeneratedMessage {
   void clearName() => clearField(2);
 }
 
-class _ReadonlyPrefixedDirective extends PrefixedDirective
-    with ReadonlyMessageMixin {}
+class _ReadonlyPrefixedType extends PrefixedType with ReadonlyMessageMixin {}
 
 class ReflectionInfoModel extends GeneratedMessage {
   static final BuilderInfo _i = new BuilderInfo('ReflectionInfoModel')
@@ -113,8 +111,10 @@ class ReflectionInfoModel extends GeneratedMessage {
     ..p(6, 'interfaces', PbFieldType.PS)
     ..pp(7, 'propertyMetadata', PbFieldType.PM,
         PropertyMetadataModel.$checkItem, PropertyMetadataModel.create)
-    ..pp(8, 'directives', PbFieldType.PM, PrefixedDirective.$checkItem,
-        PrefixedDirective.create);
+    ..pp(8, 'directives', PbFieldType.PM, PrefixedType.$checkItem,
+        PrefixedType.create)
+    ..pp(9, 'pipes', PbFieldType.PM, PrefixedType.$checkItem,
+        PrefixedType.create);
 
   ReflectionInfoModel() : super();
   ReflectionInfoModel.fromBuffer(List<int> i,
@@ -172,7 +172,9 @@ class ReflectionInfoModel extends GeneratedMessage {
 
   List<PropertyMetadataModel> get propertyMetadata => $_get(6, 7, null);
 
-  List<PrefixedDirective> get directives => $_get(7, 8, null);
+  List<PrefixedType> get directives => $_get(7, 8, null);
+
+  List<PrefixedType> get pipes => $_get(8, 9, null);
 }
 
 class _ReadonlyReflectionInfoModel extends ReflectionInfoModel
@@ -192,8 +194,8 @@ const PropertyMetadataModel$json = const {
   ],
 };
 
-const PrefixedDirective$json = const {
-  '1': 'PrefixedDirective',
+const PrefixedType$json = const {
+  '1': 'PrefixedType',
   '2': const [
     const {'1': 'prefix', '3': 1, '4': 1, '5': 9},
     const {'1': 'name', '3': 2, '4': 1, '5': 9},
@@ -233,14 +235,21 @@ const ReflectionInfoModel$json = const {
       '3': 8,
       '4': 3,
       '5': 11,
-      '6': '.angular2.src.transform.common.model.proto.PrefixedDirective'
+      '6': '.angular2.src.transform.common.model.proto.PrefixedType'
+    },
+    const {
+      '1': 'pipes',
+      '3': 9,
+      '4': 3,
+      '5': 11,
+      '6': '.angular2.src.transform.common.model.proto.PrefixedType'
     },
   ],
 };
 
 /**
  * Generated with:
- * reflection_info_model.proto (e81bf93b6872b2bd5fabc6625be2560bacc3d186)
+ * reflection_info_model.proto (7670e589733b1190f9b4f1c9b42f90a613975afd)
  * libprotoc 2.6.1
  * dart-protoc-plugin (af5fc2bf1de367a434c3b1847ab260510878ffc0)
  */
diff --git a/modules_dart/transform/lib/src/transform/common/model/reflection_info_model.proto b/modules_dart/transform/lib/src/transform/common/model/reflection_info_model.proto
index 65064dd..c4ef6e0 100644
--- a/modules_dart/transform/lib/src/transform/common/model/reflection_info_model.proto
+++ b/modules_dart/transform/lib/src/transform/common/model/reflection_info_model.proto
@@ -13,12 +13,12 @@ message PropertyMetadataModel {
   repeated AnnotationModel annotations = 2;
 }
 
-message PrefixedDirective {
-  // The prefix used to reference this Directive, if any.
+message PrefixedType {
+  // The prefix used to reference this Type, if any.
   optional string prefix = 1;
 
-  // The name of the Directive or directive alias.
-  // See https://goo.gl/d8XPt0 for info on directive aliases.
+  // The name of the Type or type alias.
+  // See https://goo.gl/d8XPt0 for info on type aliases.
   optional string name = 2;
 }
 
@@ -44,5 +44,8 @@ message ReflectionInfoModel {
 
   // Directive dependencies parsed from the @View or @Component `directives`
   // parameter.
-  repeated PrefixedDirective directives = 8;
+  repeated PrefixedType directives = 8;
+
+  // Pipe dependencies parsed from the @View or @Component `pipes` parameter.
+  repeated PrefixedType pipes = 9;
 }
diff --git a/modules_dart/transform/lib/src/transform/common/ng_compiler.dart b/modules_dart/transform/lib/src/transform/common/ng_compiler.dart
index c8021d3..55c2512 100644
--- a/modules_dart/transform/lib/src/transform/common/ng_compiler.dart
+++ b/modules_dart/transform/lib/src/transform/common/ng_compiler.dart
@@ -1,6 +1,6 @@
 library angular2.transform.template_compiler.ng_compiler;
 
-import 'package:angular2/src/compiler/command_compiler.dart';
+import 'package:angular2/src/compiler/view_compiler.dart';
 import 'package:angular2/src/compiler/html_parser.dart';
 import 'package:angular2/src/compiler/style_compiler.dart';
 import 'package:angular2/src/compiler/template_compiler.dart';
@@ -13,6 +13,7 @@ import 'package:angular2/src/transform/common/asset_reader.dart';
 import 'package:angular2/src/core/change_detection/interfaces.dart';
 import 'package:angular2/src/compiler/change_detector_compiler.dart';
 import 'package:angular2/router/router_link_dsl.dart';
+import 'package:angular2/src/compiler/proto_view_compiler.dart';
 
 import 'xhr_impl.dart';
 import 'url_resolver.dart';
@@ -25,8 +26,11 @@ TemplateCompiler createTemplateCompiler(AssetReader reader,
 
   // TODO(yjbanov): add router AST transformer when ready
   var parser = new ng.Parser(new ng.Lexer());
-  var templateParser = new TemplateParser(parser,
-      new DomElementSchemaRegistry(), _htmlParser, [new RouterLinkTransform(parser)]);
+  var templateParser = new TemplateParser(
+      parser,
+      new DomElementSchemaRegistry(),
+      _htmlParser,
+      [new RouterLinkTransform(parser)]);
 
   var cdCompiler = changeDetectionConfig != null
       ? new ChangeDetectionCompiler(changeDetectionConfig)
@@ -37,6 +41,9 @@ TemplateCompiler createTemplateCompiler(AssetReader reader,
       new TemplateNormalizer(_xhr, _urlResolver, _htmlParser),
       templateParser,
       new StyleCompiler(_xhr, _urlResolver),
-      new CommandCompiler(),
-      cdCompiler);
+      cdCompiler,
+      new ProtoViewCompiler(),
+      new ViewCompiler(),
+      null /* ResolvedMetadataCache */,
+      changeDetectionConfig);
 }
diff --git a/modules_dart/transform/lib/src/transform/common/ng_meta.dart b/modules_dart/transform/lib/src/transform/common/ng_meta.dart
index 0ba3fa2..25199a5 100644
--- a/modules_dart/transform/lib/src/transform/common/ng_meta.dart
+++ b/modules_dart/transform/lib/src/transform/common/ng_meta.dart
@@ -33,8 +33,9 @@ class NgMeta {
   static const _TYPE_VALUE = 'type';
   static const _VALUE_KEY = 'value';
 
-  /// Directive metadata for each type annotated as a directive.
-  final Map<String, CompileDirectiveMetadata> types;
+  /// Metadata for each type annotated as a directive/pipe.
+  /// Type: [CompileDirectiveMetadata]/[CompilePipeMetadata]
+  final Map<String, dynamic> types;
 
   /// List of other types and names associated with a given name.
   final Map<String, List<String>> aliases;
@@ -43,7 +44,7 @@ class NgMeta {
   final NgDepsModel ngDeps;
 
   NgMeta(
-      {Map<String, CompileDirectiveMetadata> types,
+      {Map<String, dynamic> types,
       Map<String, List<String>> aliases,
       this.ngDeps: null})
       : this.types = types != null ? types : {},
@@ -91,7 +92,7 @@ class NgMeta {
           continue;
         }
         if (entry[_KIND_KEY] == _TYPE_VALUE) {
-          types[key] = CompileDirectiveMetadata.fromJson(entry[_VALUE_KEY]);
+          types[key] = CompileMetadataWithType.fromJson(entry[_VALUE_KEY]);
         } else if (entry[_KIND_KEY] == _ALIAS_VALUE) {
           aliases[key] = entry[_VALUE_KEY];
         }
@@ -123,8 +124,8 @@ class NgMeta {
   }
 
   /// Returns the metadata for every type associated with the given [alias].
-  List<CompileDirectiveMetadata> flatten(String alias) {
-    var result = <CompileDirectiveMetadata>[];
+  List<dynamic> flatten(String alias) {
+    var result = [];
     var seen = new Set();
     helper(name) {
       if (!seen.add(name)) {
diff --git a/modules_dart/transform/lib/src/transform/common/options.dart b/modules_dart/transform/lib/src/transform/common/options.dart
index 460df8a..822302f 100644
--- a/modules_dart/transform/lib/src/transform/common/options.dart
+++ b/modules_dart/transform/lib/src/transform/common/options.dart
@@ -10,6 +10,7 @@ const ENTRY_POINT_PARAM = 'entry_points';
 const FORMAT_CODE_PARAM = 'format_code';
 const REFLECT_PROPERTIES_AS_ATTRIBUTES = 'reflect_properties_as_attributes';
 const PLATFORM_DIRECTIVES = 'platform_directives';
+const PLATFORM_PIPES = 'platform_pipes';
 const INIT_REFLECTOR_PARAM = 'init_reflector';
 const INLINE_VIEWS_PARAM = 'inline_views';
 const MIRROR_MODE_PARAM = 'mirror_mode';
@@ -44,9 +45,15 @@ class TransformerOptions {
   final bool genChangeDetectionDebugInfo;
 
   /// A set of directives that will be automatically passed-in to the template compiler
-  /// Format of an item in the list: angular2/lib/src/common/directives.dart#CORE_DIRECTIVES
+  /// Format of an item in the list:
+  /// angular2/lib/src/common/common_directives.dart#COMMON_DIRECTIVES
   final List<String> platformDirectives;
 
+  /// A set of pipes that will be automatically passed-in to the template compiler
+  /// Format of an item in the list:
+  /// angular2/lib/src/common/pipes.dart#COMMON_PIPES
+  final List<String> platformPipes;
+
   /// Whether to format generated code.
   /// Code that is only modified will never be formatted because doing so may
   /// invalidate the source maps generated by `dart2js` and/or other tools.
@@ -76,6 +83,7 @@ class TransformerOptions {
       {this.genChangeDetectionDebugInfo,
       this.reflectPropertiesAsAttributes,
       this.platformDirectives,
+      this.platformPipes,
       this.inlineViews,
       this.lazyTransformers,
       this.formatCode});
@@ -89,6 +97,7 @@ class TransformerOptions {
       bool genChangeDetectionDebugInfo: false,
       bool reflectPropertiesAsAttributes: false,
       List<String> platformDirectives,
+      List<String> platformPipes,
       bool lazyTransformers: false,
       bool formatCode: false}) {
     var annotationMatcher = new AnnotationMatcher()
@@ -101,6 +110,7 @@ class TransformerOptions {
         genChangeDetectionDebugInfo: genChangeDetectionDebugInfo,
         reflectPropertiesAsAttributes: reflectPropertiesAsAttributes,
         platformDirectives: platformDirectives,
+        platformPipes: platformPipes,
         inlineViews: inlineViews,
         lazyTransformers: lazyTransformers,
         formatCode: formatCode);
diff --git a/modules_dart/transform/lib/src/transform/common/options_reader.dart b/modules_dart/transform/lib/src/transform/common/options_reader.dart
index 21a78b7..9123917 100644
--- a/modules_dart/transform/lib/src/transform/common/options_reader.dart
+++ b/modules_dart/transform/lib/src/transform/common/options_reader.dart
@@ -13,6 +13,7 @@ TransformerOptions parseBarbackSettings(BarbackSettings settings) {
   var reflectPropertiesAsAttributes =
       _readBool(config, REFLECT_PROPERTIES_AS_ATTRIBUTES, defaultValue: false);
   var platformDirectives = _readStringList(config, PLATFORM_DIRECTIVES);
+  var platformPipes = _readStringList(config, PLATFORM_PIPES);
   var formatCode = _readBool(config, FORMAT_CODE_PARAM, defaultValue: false);
   String mirrorModeVal =
       config.containsKey(MIRROR_MODE_PARAM) ? config[MIRROR_MODE_PARAM] : '';
@@ -36,6 +37,7 @@ TransformerOptions parseBarbackSettings(BarbackSettings settings) {
       customAnnotationDescriptors: _readCustomAnnotations(config),
       reflectPropertiesAsAttributes: reflectPropertiesAsAttributes,
       platformDirectives: platformDirectives,
+      platformPipes: platformPipes,
       inlineViews: _readBool(config, INLINE_VIEWS_PARAM, defaultValue: false),
       lazyTransformers:
           _readBool(config, LAZY_TRANSFORMERS, defaultValue: false),
diff --git a/modules_dart/transform/lib/src/transform/common/type_metadata_reader.dart b/modules_dart/transform/lib/src/transform/common/type_metadata_reader.dart
new file mode 100644
index 0000000..a9200d1
--- /dev/null
+++ b/modules_dart/transform/lib/src/transform/common/type_metadata_reader.dart
@@ -0,0 +1,680 @@
+library angular2.transform.common.type_metadata_reader;
+
+import 'dart:async';
+
+import 'package:analyzer/analyzer.dart';
+
+import 'package:angular2/src/compiler/directive_metadata.dart';
+import 'package:angular2/src/compiler/template_compiler.dart';
+
+import 'package:angular2/src/core/change_detection/change_detection.dart';
+import 'package:angular2/src/core/linker/interfaces.dart' show LifecycleHooks;
+import 'package:angular2/src/core/metadata/view.dart' show ViewEncapsulation;
+import 'package:angular2/src/transform/common/annotation_matcher.dart';
+import 'package:angular2/src/transform/common/interface_matcher.dart';
+import 'package:angular2/src/transform/common/logging.dart';
+import 'package:barback/barback.dart' show AssetId;
+
+import 'naive_eval.dart';
+import 'url_resolver.dart';
+
+class TypeMetadataReader {
+  final _DirectiveMetadataVisitor _directiveVisitor;
+  final _PipeMetadataVisitor _pipeVisitor;
+  final TemplateCompiler _templateCompiler;
+
+  TypeMetadataReader._(
+      this._directiveVisitor, this._pipeVisitor, this._templateCompiler);
+
+  /// Accepts an [AnnotationMatcher] which tests that an [Annotation]
+  /// is a [Directive], [Component], or [View].
+  factory TypeMetadataReader(AnnotationMatcher annotationMatcher,
+      InterfaceMatcher interfaceMatcher, TemplateCompiler templateCompiler) {
+    var lifecycleVisitor = new _LifecycleHookVisitor(interfaceMatcher);
+    var directiveVisitor =
+        new _DirectiveMetadataVisitor(annotationMatcher, lifecycleVisitor);
+    var pipeVisitor = new _PipeMetadataVisitor(annotationMatcher);
+
+    return new TypeMetadataReader._(
+        directiveVisitor, pipeVisitor, templateCompiler);
+  }
+
+  /// Reads *un-normalized* [CompileDirectiveMetadata]/[CompilePipeMetadata] from the
+  /// [ClassDeclaration] `node`.
+  ///
+  /// `node` is expected to be a class which may have a [Directive] or [Component]
+  /// annotation. If `node` does not have one of these annotations, this function
+  /// returns `null`.
+  ///
+  /// `assetId` is the [AssetId] from which `node` was read, unless `node` was
+  /// read from a part file, in which case `assetId` should be the [AssetId] of
+  /// the parent file.
+  Future<dynamic> readTypeMetadata(ClassDeclaration node, AssetId assetId) {
+    _directiveVisitor.reset(assetId);
+    _pipeVisitor.reset(assetId);
+    node.accept(_directiveVisitor);
+    node.accept(_pipeVisitor);
+    if (_directiveVisitor.hasMetadata) {
+      final metadata = _directiveVisitor.createMetadata();
+      return _templateCompiler.normalizeDirectiveMetadata(metadata);
+    } else if (_pipeVisitor.hasMetadata) {
+      return new Future.value(_pipeVisitor.createMetadata());
+    } else {
+      return new Future.value(null);
+    }
+  }
+}
+
+/// Evaluates the [Map] represented by `expression` and adds all `key`,
+/// `value` pairs to `map`. If `expression` does not evaluate to a [Map],
+/// throws a descriptive [FormatException].
+void _populateMap(Expression expression, Map map, String propertyName) {
+  var evaluated = naiveEval(expression);
+  if (evaluated is! Map) {
+    throw new FormatException(
+        'Angular 2 expects a Map but could not understand the value for '
+        '$propertyName.',
+        '$expression' /* source */);
+  }
+  evaluated.forEach((key, value) {
+    if (value != null) {
+      map[key] = '$value';
+    }
+  });
+}
+
+/// Evaluates the [List] represented by `expression` and adds all values,
+/// to `list`. If `expression` does not evaluate to a [List], throws a
+/// descriptive [FormatException].
+void _populateList(
+    Expression expression, List<String> list, String propertyName) {
+  var evaluated = naiveEval(expression);
+  if (evaluated is! List) {
+    throw new FormatException(
+        'Angular 2 expects a List but could not understand the value for '
+        '$propertyName.',
+        '$expression' /* source */);
+  }
+  list.addAll(evaluated.map((e) => e.toString()));
+}
+
+/// Evaluates `node` and expects that the result will be a string. If not,
+/// throws a [FormatException].
+String _expressionToString(Expression node, String nodeDescription) {
+  var value = naiveEval(node);
+  if (value is! String) {
+    throw new FormatException(
+        'Angular 2 could not understand the value '
+        'in $nodeDescription.',
+        '$node' /* source */);
+  }
+  return value;
+}
+
+/// Evaluates `node` and expects that the result will be a bool. If not,
+/// throws a [FormatException].
+bool _expressionToBool(Expression node, String nodeDescription) {
+  var value = naiveEval(node);
+  if (value is! bool) {
+    throw new FormatException(
+        'Angular 2 could not understand the value '
+        'in $nodeDescription.',
+        '$node' /* source */);
+  }
+  return value;
+}
+
+/// Visitor responsible for processing a [Directive] annotated
+/// [ClassDeclaration] and creating a [CompileDirectiveMetadata] object.
+class _DirectiveMetadataVisitor extends Object
+    with RecursiveAstVisitor<Object> {
+  /// Tests [Annotation]s to determine if they deifne a [Directive],
+  /// [Component], [View], or none of these.
+  final AnnotationMatcher _annotationMatcher;
+
+  final _LifecycleHookVisitor _lifecycleVisitor;
+
+  /// The [AssetId] we are currently processing.
+  AssetId _assetId;
+
+  _DirectiveMetadataVisitor(this._annotationMatcher, this._lifecycleVisitor) {
+    reset(null);
+  }
+
+  /// Whether the visitor has found a [Component] or [Directive] annotation
+  /// since the last call to `reset`.
+  bool _hasMetadata = false;
+
+  // Annotation fields
+  CompileTypeMetadata _type;
+  bool _isComponent;
+  String _selector;
+  String _exportAs;
+  ChangeDetectionStrategy _changeDetection;
+  List<String> _inputs;
+  List<String> _outputs;
+  Map<String, String> _host;
+  List<LifecycleHooks> _lifecycleHooks;
+  CompileTemplateMetadata _cmpTemplate;
+  CompileTemplateMetadata _viewTemplate;
+
+  void reset(AssetId assetId) {
+    _lifecycleVisitor.reset(assetId);
+    _assetId = assetId;
+
+    _type = null;
+    _isComponent = false;
+    _hasMetadata = false;
+    _selector = '';
+    _exportAs = null;
+    _changeDetection = ChangeDetectionStrategy.Default;
+    _inputs = <String>[];
+    _outputs = <String>[];
+    _host = <String, String>{};
+    _lifecycleHooks = null;
+    _cmpTemplate = null;
+    _viewTemplate = null;
+  }
+
+  bool get hasMetadata => _hasMetadata;
+
+  get _template => _viewTemplate != null ? _viewTemplate : _cmpTemplate;
+
+  CompileDirectiveMetadata createMetadata() {
+    return CompileDirectiveMetadata.create(
+        type: _type,
+        isComponent: _isComponent,
+        dynamicLoadable: true,
+        // NOTE(kegluneq): For future optimization.
+        selector: _selector,
+        exportAs: _exportAs,
+        changeDetection: _changeDetection,
+        inputs: _inputs,
+        outputs: _outputs,
+        host: _host,
+        lifecycleHooks: _lifecycleHooks,
+        template: _template);
+  }
+
+  /// Ensures that we do not specify View values on an `@Component` annotation
+  /// when there is a @View annotation present.
+  void _validateTemplates() {
+    if (_cmpTemplate != null && _viewTemplate != null) {
+      var name = '(Unknown)';
+      if (_type != null && _type.name != null && _type.name.isNotEmpty) {
+        name = _type.name;
+      }
+      log.warning(
+          'Cannot specify view parameters on @Component when a @View '
+          'is present. Component name: ${name}',
+          asset: _assetId);
+    }
+  }
+
+  @override
+  Object visitAnnotation(Annotation node) {
+    var isComponent = _annotationMatcher.isComponent(node, _assetId);
+    var isDirective = _annotationMatcher.isDirective(node, _assetId);
+    if (isDirective) {
+      if (_hasMetadata) {
+        throw new FormatException(
+            'Only one Directive is allowed per class. '
+            'Found unexpected "$node".',
+            '$node' /* source */);
+      }
+      _isComponent = isComponent;
+      _hasMetadata = true;
+      if (isComponent) {
+        _cmpTemplate =
+            new _CompileTemplateMetadataVisitor().visitAnnotation(node);
+        _validateTemplates();
+      }
+      super.visitAnnotation(node);
+    } else if (_annotationMatcher.isView(node, _assetId)) {
+      if (_viewTemplate != null) {
+        // TODO(kegluneq): Support multiple views on a single class.
+        throw new FormatException(
+            'Only one View is allowed per class. '
+            'Found unexpected "$node".',
+            '$node' /* source */);
+      }
+      _viewTemplate =
+          new _CompileTemplateMetadataVisitor().visitAnnotation(node);
+      _validateTemplates();
+    }
+
+    // Annotation we do not recognize - no need to visit.
+    return null;
+  }
+
+  @override
+  Object visitFieldDeclaration(FieldDeclaration node) {
+    for (var variable in node.fields.variables) {
+      for (var meta in node.metadata) {
+        if (_isAnnotation(meta, 'Output')) {
+          _addPropertyToType(_outputs, variable.name.toString(), meta);
+        }
+
+        if (_isAnnotation(meta, 'Input')) {
+          _addPropertyToType(_inputs, variable.name.toString(), meta);
+        }
+
+        if (_isAnnotation(meta, 'HostBinding')) {
+          final renamed = _getRenamedValue(meta);
+          if (renamed != null) {
+            _host['[${renamed}]'] = '${variable.name}';
+          } else {
+            _host['[${variable.name}]'] = '${variable.name}';
+          }
+        }
+      }
+    }
+    return null;
+  }
+
+  @override
+  Object visitMethodDeclaration(MethodDeclaration node) {
+    for (var meta in node.metadata) {
+      if (_isAnnotation(meta, 'Output') && node.isGetter) {
+        _addPropertyToType(_outputs, node.name.toString(), meta);
+      }
+
+      if (_isAnnotation(meta, 'Input') && node.isSetter) {
+        _addPropertyToType(_inputs, node.name.toString(), meta);
+      }
+
+      if (_isAnnotation(meta, 'HostListener')) {
+        if (meta.arguments.arguments.length == 0 ||
+            meta.arguments.arguments.length > 2) {
+          throw new ArgumentError(
+              'Incorrect value passed to HostListener. Expected 1 or 2.');
+        }
+
+        final eventName = _getHostListenerEventName(meta);
+        final params = _getHostListenerParams(meta);
+        _host['(${eventName})'] = '${node.name}($params)';
+      }
+    }
+    return null;
+  }
+
+  void _addPropertyToType(List type, String name, Annotation meta) {
+    final renamed = _getRenamedValue(meta);
+    if (renamed != null) {
+      type.add('${name}: ${renamed}');
+    } else {
+      type.add('${name}');
+    }
+  }
+
+  //TODO Use AnnotationMatcher instead of string matching
+  bool _isAnnotation(Annotation node, String annotationName) {
+    var id = node.name;
+    final name = id is PrefixedIdentifier ? '${id.identifier}' : '$id';
+    return name == annotationName;
+  }
+
+  String _getRenamedValue(Annotation node) {
+    if (node.arguments.arguments.length == 1) {
+      final renamed = naiveEval(node.arguments.arguments.single);
+      if (renamed is! String) {
+        throw new ArgumentError(
+            'Incorrect value. Expected a String, but got "${renamed}".');
+      }
+      return renamed;
+    } else {
+      return null;
+    }
+  }
+
+  String _getHostListenerEventName(Annotation node) {
+    final name = naiveEval(node.arguments.arguments.first);
+    if (name is! String) {
+      throw new ArgumentError(
+          'Incorrect event name. Expected a String, but got "${name}".');
+    }
+    return name;
+  }
+
+  String _getHostListenerParams(Annotation node) {
+    if (node.arguments.arguments.length == 2) {
+      return naiveEval(node.arguments.arguments[1]).join(',');
+    } else {
+      return "";
+    }
+  }
+
+  @override
+  Object visitClassDeclaration(ClassDeclaration node) {
+    node.metadata.accept(this);
+    if (this._hasMetadata) {
+      _type = new CompileTypeMetadata(
+          moduleUrl: toAssetUri(_assetId),
+          name: node.name.toString(),
+          runtime: null // Intentionally `null`, cannot be provided here.
+          );
+      _lifecycleHooks = node.implementsClause != null
+          ? node.implementsClause.accept(_lifecycleVisitor)
+          : const [];
+
+      node.members.accept(this);
+    }
+    return null;
+  }
+
+  @override
+  Object visitNamedExpression(NamedExpression node) {
+    // TODO(kegluneq): Remove this limitation.
+    if (node.name is! Label || node.name.label is! SimpleIdentifier) {
+      throw new FormatException(
+          'Angular 2 currently only supports simple identifiers in directives.',
+          '$node' /* source */);
+    }
+    var keyString = '${node.name.label}';
+    switch (keyString) {
+      case 'selector':
+        _populateSelector(node.expression);
+        break;
+      case 'inputs':
+        _populateProperties(node.expression);
+        break;
+      case 'properties':
+        _populateProperties(node.expression);
+        break;
+      case 'host':
+        _populateHost(node.expression);
+        break;
+      case 'exportAs':
+        _populateExportAs(node.expression);
+        break;
+      case 'changeDetection':
+        _populateChangeDetection(node.expression);
+        break;
+      case 'outputs':
+        _populateEvents(node.expression);
+        break;
+      case 'events':
+        _populateEvents(node.expression);
+        break;
+    }
+    return null;
+  }
+
+  void _populateSelector(Expression selectorValue) {
+    _checkMeta();
+    _selector = _expressionToString(selectorValue, 'Directive#selector');
+  }
+
+  void _checkMeta() {
+    if (!_hasMetadata) {
+      throw new ArgumentError('Incorrect value passed to readTypeMetadata. '
+          'Expected type is ClassDeclaration');
+    }
+  }
+
+  void _populateProperties(Expression inputsValue) {
+    _checkMeta();
+    _populateList(inputsValue, _inputs, 'Directive#inputs');
+  }
+
+  void _populateHost(Expression hostValue) {
+    _checkMeta();
+    _populateMap(hostValue, _host, 'Directive#host');
+  }
+
+  void _populateExportAs(Expression exportAsValue) {
+    _checkMeta();
+    _exportAs = _expressionToString(exportAsValue, 'Directive#exportAs');
+  }
+
+  void _populateEvents(Expression outputsValue) {
+    _checkMeta();
+    _populateList(outputsValue, _outputs, 'Directive#outputs');
+  }
+
+  void _populateChangeDetection(Expression value) {
+    _checkMeta();
+    _changeDetection = _changeDetectionStrategies[value.toSource()];
+  }
+
+  static final Map<String, ChangeDetectionStrategy> _changeDetectionStrategies =
+      new Map.fromIterable(ChangeDetectionStrategy.values,
+          key: (v) => v.toString());
+}
+
+/// Visitor responsible for parsing an [ImplementsClause] and returning a
+/// [List<LifecycleHooks>] that the [Directive] subscribes to.
+class _LifecycleHookVisitor extends SimpleAstVisitor<List<LifecycleHooks>> {
+  /// Tests [Identifier]s of implemented interfaces to determine if they
+  /// correspond to [LifecycleHooks] values.
+  final InterfaceMatcher _ifaceMatcher;
+
+  /// The [AssetId] we are currently processing.
+  AssetId _assetId;
+
+  _LifecycleHookVisitor(this._ifaceMatcher);
+
+  void reset(AssetId assetId) {
+    _assetId = assetId;
+  }
+
+  @override
+  List<LifecycleHooks> visitImplementsClause(ImplementsClause node) {
+    if (node == null || node.interfaces == null) return const [];
+
+    return node.interfaces.map((TypeName ifaceTypeName) {
+      var id = ifaceTypeName.name;
+      if (_ifaceMatcher.isAfterContentChecked(id, _assetId)) {
+        return LifecycleHooks.AfterContentChecked;
+      } else if (_ifaceMatcher.isAfterContentInit(id, _assetId)) {
+        return LifecycleHooks.AfterContentInit;
+      } else if (_ifaceMatcher.isAfterViewChecked(id, _assetId)) {
+        return LifecycleHooks.AfterViewChecked;
+      } else if (_ifaceMatcher.isAfterViewInit(id, _assetId)) {
+        return LifecycleHooks.AfterViewInit;
+      } else if (_ifaceMatcher.isDoCheck(id, _assetId)) {
+        return LifecycleHooks.DoCheck;
+      } else if (_ifaceMatcher.isOnChange(id, _assetId)) {
+        return LifecycleHooks.OnChanges;
+      } else if (_ifaceMatcher.isOnDestroy(id, _assetId)) {
+        return LifecycleHooks.OnDestroy;
+      } else if (_ifaceMatcher.isOnInit(id, _assetId)) {
+        return LifecycleHooks.OnInit;
+      }
+      return null;
+    }).where((e) => e != null).toList(growable: false);
+  }
+}
+
+/// Visitor responsible for parsing a @View [Annotation] and producing a
+/// [CompileTemplateMetadata].
+class _CompileTemplateMetadataVisitor
+    extends RecursiveAstVisitor<CompileTemplateMetadata> {
+  ViewEncapsulation _encapsulation;
+  String _template;
+  String _templateUrl;
+  List<String> _styles;
+  List<String> _styleUrls;
+
+  @override
+  CompileTemplateMetadata visitAnnotation(Annotation node) {
+    super.visitAnnotation(node);
+
+    if (_encapsulation == null &&
+        _template == null &&
+        _templateUrl == null &&
+        _styles == null &&
+        _styleUrls == null) {
+      return null;
+    }
+
+    return new CompileTemplateMetadata(
+        encapsulation: _encapsulation,
+        template: _template,
+        templateUrl: _templateUrl,
+        styles: _styles,
+        styleUrls: _styleUrls);
+  }
+
+  @override
+  CompileTemplateMetadata visitNamedExpression(NamedExpression node) {
+    // TODO(kegluneq): Remove this limitation.
+    if (node.name is! Label || node.name.label is! SimpleIdentifier) {
+      throw new FormatException(
+          'Angular 2 currently only supports simple identifiers in directives.',
+          '$node' /* source */);
+    }
+    var keyString = '${node.name.label}';
+    switch (keyString) {
+      case 'encapsulation':
+        _populateEncapsulation(node.expression);
+        break;
+      case 'template':
+        _populateTemplate(node.expression);
+        break;
+      case 'templateUrl':
+        _populateTemplateUrl(node.expression);
+        break;
+      case 'styles':
+        _populateStyles(node.expression);
+        break;
+      case 'styleUrls':
+        _populateStyleUrls(node.expression);
+        break;
+    }
+    return null;
+  }
+
+  void _populateTemplate(Expression value) {
+    _template = _expressionToString(value, 'View#template');
+  }
+
+  void _populateTemplateUrl(Expression value) {
+    _templateUrl = _expressionToString(value, 'View#templateUrl');
+  }
+
+  void _populateStyles(Expression value) {
+    _styles = <String>[];
+    _populateList(value, _styles, 'View#styles');
+  }
+
+  void _populateStyleUrls(Expression value) {
+    _styleUrls = <String>[];
+    _populateList(value, _styleUrls, 'View#styleUrls');
+  }
+
+  void _populateEncapsulation(Expression value) {
+    _encapsulation = _viewEncapsulationMap[value.toSource()];
+  }
+
+  static final _viewEncapsulationMap =
+      new Map.fromIterable(ViewEncapsulation.values, key: (v) => v.toString());
+}
+
+/// Visitor responsible for processing a [Pipe] annotated
+/// [ClassDeclaration] and creating a [CompilePipeMetadata] object.
+class _PipeMetadataVisitor extends Object with RecursiveAstVisitor<Object> {
+  /// Tests [Annotation]s to determine if they deifne a [Directive],
+  /// [Component], [View], or none of these.
+  final AnnotationMatcher _annotationMatcher;
+
+  /// The [AssetId] we are currently processing.
+  AssetId _assetId;
+
+  _PipeMetadataVisitor(this._annotationMatcher) {
+    reset(null);
+  }
+
+  /// Whether the visitor has found a [Pipe] annotation
+  /// since the last call to `reset`.
+  bool _hasMetadata = false;
+
+  // Annotation fields
+  CompileTypeMetadata _type;
+  String _name;
+  bool _pure;
+
+  void reset(AssetId assetId) {
+    _assetId = assetId;
+
+    _hasMetadata = false;
+    _type = null;
+    _name = null;
+    _pure = null;
+  }
+
+  bool get hasMetadata => _hasMetadata;
+
+  CompilePipeMetadata createMetadata() {
+    return new CompilePipeMetadata(type: _type, name: _name, pure: _pure);
+  }
+
+  @override
+  Object visitAnnotation(Annotation node) {
+    var isPipe = _annotationMatcher.isPipe(node, _assetId);
+    if (isPipe) {
+      if (_hasMetadata) {
+        throw new FormatException(
+            'Only one Pipe is allowed per class. '
+            'Found unexpected "$node".',
+            '$node' /* source */);
+      }
+      _hasMetadata = true;
+      super.visitAnnotation(node);
+    }
+
+    // Annotation we do not recognize - no need to visit.
+    return null;
+  }
+
+  @override
+  Object visitClassDeclaration(ClassDeclaration node) {
+    node.metadata.accept(this);
+    if (this._hasMetadata) {
+      _type = new CompileTypeMetadata(
+          moduleUrl: toAssetUri(_assetId),
+          name: node.name.toString(),
+          runtime: null // Intentionally `null`, cannot be provided here.
+          );
+      node.members.accept(this);
+    }
+    return null;
+  }
+
+  @override
+  Object visitNamedExpression(NamedExpression node) {
+    // TODO(kegluneq): Remove this limitation.
+    if (node.name is! Label || node.name.label is! SimpleIdentifier) {
+      throw new FormatException(
+          'Angular 2 currently only supports simple identifiers in pipes.',
+          '$node' /* source */);
+    }
+    var keyString = '${node.name.label}';
+    switch (keyString) {
+      case 'name':
+        _popuplateName(node.expression);
+        break;
+      case 'pure':
+        _populatePure(node.expression);
+        break;
+    }
+    return null;
+  }
+
+  void _checkMeta() {
+    if (!_hasMetadata) {
+      throw new ArgumentError('Incorrect value passed to readTypeMetadata. '
+          'Expected type is ClassDeclaration');
+    }
+  }
+
+  void _popuplateName(Expression nameValue) {
+    _checkMeta();
+    _name = _expressionToString(nameValue, 'Pipe#name');
+  }
+
+  void _populatePure(Expression pureValue) {
+    _checkMeta();
+    _pure = _expressionToBool(pureValue, 'Pipe#pure');
+  }
+}
diff --git a/modules_dart/transform/lib/src/transform/directive_processor/rewriter.dart b/modules_dart/transform/lib/src/transform/directive_processor/rewriter.dart
index dda7db7..0645309 100644
--- a/modules_dart/transform/lib/src/transform/directive_processor/rewriter.dart
+++ b/modules_dart/transform/lib/src/transform/directive_processor/rewriter.dart
@@ -9,7 +9,7 @@ import 'package:angular2/src/compiler/template_compiler.dart';
 import 'package:angular2/src/transform/common/annotation_matcher.dart';
 import 'package:angular2/src/transform/common/asset_reader.dart';
 import 'package:angular2/src/transform/common/code/ng_deps_code.dart';
-import 'package:angular2/src/transform/common/directive_metadata_reader.dart';
+import 'package:angular2/src/transform/common/type_metadata_reader.dart';
 import 'package:angular2/src/transform/common/interface_matcher.dart';
 import 'package:angular2/src/transform/common/logging.dart';
 import 'package:angular2/src/transform/common/ng_compiler.dart';
@@ -64,12 +64,12 @@ class _NgMetaVisitor extends Object with SimpleAstVisitor<Object> {
   /// The [AssetId] we are currently processing.
   final AssetId assetId;
 
-  final DirectiveMetadataReader _reader;
+  final TypeMetadataReader _reader;
   final _normalizations = <Future>[];
 
   _NgMetaVisitor(this.ngMeta, this.assetId, AnnotationMatcher annotationMatcher,
       InterfaceMatcher interfaceMatcher, TemplateCompiler templateCompiler)
-      : _reader = new DirectiveMetadataReader(
+      : _reader = new TypeMetadataReader(
             annotationMatcher, interfaceMatcher, templateCompiler);
 
   Future whenDone() {
@@ -88,12 +88,11 @@ class _NgMetaVisitor extends Object with SimpleAstVisitor<Object> {
 
   @override
   Object visitClassDeclaration(ClassDeclaration node) {
-    _normalizations.add(_reader
-        .readDirectiveMetadata(node, assetId)
-        .then((compileDirectiveMetadata) {
-      if (compileDirectiveMetadata != null) {
-        ngMeta.types[compileDirectiveMetadata.type.name] =
-            compileDirectiveMetadata;
+    _normalizations.add(
+        _reader.readTypeMetadata(node, assetId).then((compileMetadataWithType) {
+      if (compileMetadataWithType != null) {
+        ngMeta.types[compileMetadataWithType.type.name] =
+            compileMetadataWithType;
       }
     }).catchError((err) {
       log.error('ERROR: $err', asset: assetId);
diff --git a/modules_dart/transform/lib/src/transform/template_compiler/change_detector_codegen.dart b/modules_dart/transform/lib/src/transform/template_compiler/change_detector_codegen.dart
index 99c8185..88f3d41 100644
--- a/modules_dart/transform/lib/src/transform/template_compiler/change_detector_codegen.dart
+++ b/modules_dart/transform/lib/src/transform/template_compiler/change_detector_codegen.dart
@@ -145,9 +145,9 @@ class _CodegenState {
       class $_changeDetectorTypeName extends ${_genPrefix}$_BASE_CLASS<$_contextTypeName> {
         ${_genDeclareFields()}
 
-        $_changeDetectorTypeName(dispatcher)
+        $_changeDetectorTypeName()
           : super(${codify(_changeDetectorDefId)},
-              dispatcher, ${_records.length},
+              ${_records.length},
               ${_changeDetectorTypeName}.${_GEN_PROPERTY_BINDING_TARGETS_NAME},
               ${_changeDetectorTypeName}.${_GEN_DIRECTIVE_INDICES_NAME},
               ${_changeDetectionStrategyAsCode}) {
@@ -177,8 +177,8 @@ class _CodegenState {
         ${_genDirectiveIndices()};
 
         static ${_genPrefix}ChangeDetector
-            $CHANGE_DETECTOR_FACTORY_METHOD(a) {
-          return new $_changeDetectorTypeName(a);
+            $CHANGE_DETECTOR_FACTORY_METHOD() {
+          return new $_changeDetectorTypeName();
         }
       }
     ''');
@@ -283,13 +283,19 @@ class _CodegenState {
   String _maybeGenDehydrateDirectives() {
     var destroyPipesParamName = 'destroyPipes';
     var destroyPipesCode = _names.genPipeOnDestroy();
-    if (destroyPipesCode.isNotEmpty) {
-      destroyPipesCode = 'if (${destroyPipesParamName}) {${destroyPipesCode}}';
-    }
     var dehydrateFieldsCode = _names.genDehydrateFields();
-    if (destroyPipesCode.isEmpty && dehydrateFieldsCode.isEmpty) return '';
-    return 'void dehydrateDirectives(${destroyPipesParamName}) '
-        '{ ${destroyPipesCode} ${dehydrateFieldsCode} }';
+    var destroyDirectivesCode =
+        _logic.genDirectivesOnDestroy(this._directiveRecords);
+    if (destroyPipesCode.isEmpty &&
+        dehydrateFieldsCode.isEmpty &&
+        destroyDirectivesCode.isEmpty) return '';
+    return '''void dehydrateDirectives(${destroyPipesParamName}) {
+      if (${destroyPipesParamName}) {
+        ${destroyPipesCode}
+        ${destroyDirectivesCode}
+      }
+      ${dehydrateFieldsCode}
+    }''';
   }
 
   String _maybeGenHydrateDirectives() {
diff --git a/modules_dart/transform/lib/src/transform/template_compiler/compile_data_creator.dart b/modules_dart/transform/lib/src/transform/template_compiler/compile_data_creator.dart
index 9ddee69..4436ba4 100644
--- a/modules_dart/transform/lib/src/transform/template_compiler/compile_data_creator.dart
+++ b/modules_dart/transform/lib/src/transform/template_compiler/compile_data_creator.dart
@@ -19,11 +19,14 @@ import 'package:barback/barback.dart';
 ///
 /// The returned value wraps the [NgDepsModel] at `assetId` as well as these
 /// created objects.
-Future<CompileDataResults> createCompileData(AssetReader reader,
-    AssetId assetId, List<String> platformDirectives) async {
+Future<CompileDataResults> createCompileData(
+    AssetReader reader,
+    AssetId assetId,
+    List<String> platformDirectives,
+    List<String> platformPipes) async {
   return logElapsedAsync(() async {
-    final creator =
-        await _CompileDataCreator.create(reader, assetId, platformDirectives);
+    final creator = await _CompileDataCreator.create(
+        reader, assetId, platformDirectives, platformPipes);
     return creator != null ? creator.createCompileData() : null;
   }, operationName: 'createCompileData', assetId: assetId);
 }
@@ -43,18 +46,20 @@ class _CompileDataCreator {
   final AssetId entryPoint;
   final NgMeta ngMeta;
   final List<String> platformDirectives;
+  final List<String> platformPipes;
 
-  _CompileDataCreator(
-      this.reader, this.entryPoint, this.ngMeta, this.platformDirectives);
+  _CompileDataCreator(this.reader, this.entryPoint, this.ngMeta,
+      this.platformDirectives, this.platformPipes);
 
   static Future<_CompileDataCreator> create(AssetReader reader, AssetId assetId,
-      List<String> platformDirectives) async {
+      List<String> platformDirectives, List<String> platformPipes) async {
     if (!(await reader.hasInput(assetId))) return null;
     final json = await reader.readAsString(assetId);
     if (json == null || json.isEmpty) return null;
 
     final ngMeta = new NgMeta.fromJson(JSON.decode(json));
-    return new _CompileDataCreator(reader, assetId, ngMeta, platformDirectives);
+    return new _CompileDataCreator(
+        reader, assetId, ngMeta, platformDirectives, platformPipes);
   }
 
   NgDepsModel get ngDeps => ngMeta.ngDeps;
@@ -67,39 +72,25 @@ class _CompileDataCreator {
     final compileData =
         <ReflectionInfoModel, NormalizedComponentWithViewDirectives>{};
     final ngMetaMap = await _extractNgMeta();
-    final platformDirectives = await _readPlatformDirectives();
+    final platformDirectives =
+        await _readPlatformTypes(this.platformDirectives, 'directives');
+    final platformPipes = await _readPlatformTypes(this.platformPipes, 'pipes');
 
     for (var reflectable in ngDeps.reflectables) {
       if (ngMeta.types.containsKey(reflectable.name)) {
         final compileDirectiveMetadata = ngMeta.types[reflectable.name];
-        if (compileDirectiveMetadata.template != null) {
+        if (compileDirectiveMetadata is CompileDirectiveMetadata &&
+            compileDirectiveMetadata.template != null) {
           final compileDatum = new NormalizedComponentWithViewDirectives(
-              compileDirectiveMetadata, <CompileDirectiveMetadata>[]);
+              compileDirectiveMetadata,
+              <CompileDirectiveMetadata>[],
+              <CompilePipeMetadata>[]);
           compileDatum.directives.addAll(platformDirectives);
-
-          for (var dep in reflectable.directives) {
-            if (!ngMetaMap.containsKey(dep.prefix)) {
-              log.warning(
-                  'Missing prefix "${dep.prefix}" '
-                  'needed by "${dep}" from metadata map',
-                  asset: entryPoint);
-              continue;
-            }
-            final depNgMeta = ngMetaMap[dep.prefix];
-
-            if (depNgMeta.types.containsKey(dep.name)) {
-              compileDatum.directives.add(depNgMeta.types[dep.name]);
-            } else if (depNgMeta.aliases.containsKey(dep.name)) {
-              compileDatum.directives.addAll(depNgMeta.flatten(dep.name));
-            } else {
-              log.warning(
-                  'Could not find Directive entry for $dep. '
-                  'Please be aware that Dart transformers have limited support for '
-                  'reusable, pre-defined lists of Directives (aka '
-                  '"directive aliases"). See https://goo.gl/d8XPt0 for details.',
-                  asset: entryPoint);
-            }
-          }
+          compileDatum.directives
+              .addAll(_resolveTypeMetadata(ngMetaMap, reflectable.directives));
+          compileDatum.pipes.addAll(platformPipes);
+          compileDatum.pipes
+              .addAll(_resolveTypeMetadata(ngMetaMap, reflectable.pipes));
           compileData[reflectable] = compileDatum;
         }
       }
@@ -107,46 +98,73 @@ class _CompileDataCreator {
     return new CompileDataResults._(ngMeta, compileData);
   }
 
-  Future<List<CompileDirectiveMetadata>> _readPlatformDirectives() async {
-    if (platformDirectives == null) return const [];
+  List<dynamic> _resolveTypeMetadata(
+      Map<String, NgMeta> ngMetaMap, List<PrefixedType> prefixedTypes) {
+    var resolvedMetadata = [];
+    for (var dep in prefixedTypes) {
+      if (!ngMetaMap.containsKey(dep.prefix)) {
+        log.warning(
+            'Missing prefix "${dep.prefix}" '
+            'needed by "${dep}" from metadata map',
+            asset: entryPoint);
+        continue;
+      }
+      final depNgMeta = ngMetaMap[dep.prefix];
+
+      if (depNgMeta.types.containsKey(dep.name)) {
+        resolvedMetadata.add(depNgMeta.types[dep.name]);
+      } else if (depNgMeta.aliases.containsKey(dep.name)) {
+        resolvedMetadata.addAll(depNgMeta.flatten(dep.name));
+      } else {
+        log.warning(
+            'Could not find Directive/Pipe entry for $dep. '
+            'Please be aware that Dart transformers have limited support for '
+            'reusable, pre-defined lists of Directives/Pipes (aka '
+            '"directive/pipe aliases"). See https://goo.gl/d8XPt0 for details.',
+            asset: entryPoint);
+      }
+    }
+    return resolvedMetadata;
+  }
+
+  Future<List<dynamic>> _readPlatformTypes(
+      List<String> inputPlatformTypes, String configOption) async {
+    if (inputPlatformTypes == null) return const [];
 
     final res = [];
-    for (var ad in platformDirectives) {
-      final parts = ad.split("#");
+    for (var pd in inputPlatformTypes) {
+      final parts = pd.split("#");
       if (parts.length != 2) {
         log.warning(
-            'The platform directives configuration option '
+            'The platform ${configOption} configuration option '
             'must be in the following format: "URI#TOKEN"',
             asset: entryPoint);
         return const [];
       }
-      res.addAll(await _readPlatformDirectivesFromUri(parts[0], parts[1]));
+      res.addAll(await _readPlatformTypesFromUri(parts[0], parts[1]));
     }
     return res;
   }
 
-  Future<List<CompileDirectiveMetadata>> _readPlatformDirectivesFromUri(
+  Future<List<dynamic>> _readPlatformTypesFromUri(
       String uri, String token) async {
     final metaAssetId = fromUri(toMetaExtension(uri));
-    if (await reader.hasInput(metaAssetId)) {
-      try {
-        var jsonString = await reader.readAsString(metaAssetId);
-        if (jsonString != null && jsonString.isNotEmpty) {
-          var newMetadata = new NgMeta.fromJson(JSON.decode(jsonString));
-
-          if (newMetadata.types.containsKey(token)) {
-            return [newMetadata.types[token]];
-          } else if (newMetadata.aliases.containsKey(token)) {
-            return newMetadata.flatten(token);
-          } else {
-            log.warning(
-                'Could not resolve platform directive ${token} in ${uri}',
-                asset: metaAssetId);
-          }
+    try {
+      var jsonString = await reader.readAsString(metaAssetId);
+      if (jsonString != null && jsonString.isNotEmpty) {
+        var newMetadata = new NgMeta.fromJson(JSON.decode(jsonString));
+
+        if (newMetadata.types.containsKey(token)) {
+          return [newMetadata.types[token]];
+        } else if (newMetadata.aliases.containsKey(token)) {
+          return newMetadata.flatten(token);
+        } else {
+          log.warning('Could not resolve platform type ${token} in ${uri}',
+              asset: metaAssetId);
         }
-      } catch (ex, stackTrace) {
-        log.warning('Failed to decode: $ex, $stackTrace', asset: metaAssetId);
       }
+    } catch (ex, stackTrace) {
+      log.warning('Failed to decode: $ex, $stackTrace', asset: metaAssetId);
     }
     return [];
   }
diff --git a/modules_dart/transform/lib/src/transform/template_compiler/generator.dart b/modules_dart/transform/lib/src/transform/template_compiler/generator.dart
index 960fbfc..161234a 100644
--- a/modules_dart/transform/lib/src/transform/template_compiler/generator.dart
+++ b/modules_dart/transform/lib/src/transform/template_compiler/generator.dart
@@ -30,14 +30,15 @@ import 'compile_data_creator.dart';
 Future<Outputs> processTemplates(AssetReader reader, AssetId assetId,
     {bool genChangeDetectionDebugInfo: false,
     bool reflectPropertiesAsAttributes: false,
-    List<String> platformDirectives}) async {
-  var viewDefResults =
-      await createCompileData(reader, assetId, platformDirectives);
+    List<String> platformDirectives,
+    List<String> platformPipes}) async {
+  var viewDefResults = await createCompileData(
+      reader, assetId, platformDirectives, platformPipes);
   if (viewDefResults == null) return null;
-  final directiveMetadatas = viewDefResults.ngMeta.types.values;
-  if (directiveMetadatas.isNotEmpty) {
+  final compileTypeMetadatas = viewDefResults.ngMeta.types.values;
+  if (compileTypeMetadatas.isNotEmpty) {
     var processor = new reg.Processor();
-    directiveMetadatas.forEach(processor.process);
+    compileTypeMetadatas.forEach(processor.process);
     viewDefResults.ngMeta.ngDeps.getters
         .addAll(processor.getterNames.map((e) => e.sanitizedName));
     viewDefResults.ngMeta.ngDeps.setters
@@ -71,7 +72,7 @@ Future<Outputs> processTemplates(AssetReader reader, AssetId assetId,
       ..prefix = '_templates');
     for (var reflectable in viewDefResults.viewDefinitions.keys) {
       reflectable.annotations.add(new AnnotationModel()
-        ..name = '_templates.Host${reflectable.name}Template'
+        ..name = '_templates.hostViewFactory_${reflectable.name}'
         ..isConstObject = true);
     }
   }
diff --git a/modules_dart/transform/lib/src/transform/template_compiler/reflection/model.dart b/modules_dart/transform/lib/src/transform/template_compiler/reflection/model.dart
index c590be9..8cd82f5 100644
--- a/modules_dart/transform/lib/src/transform/template_compiler/reflection/model.dart
+++ b/modules_dart/transform/lib/src/transform/template_compiler/reflection/model.dart
@@ -1,7 +1,6 @@
 library angular2.transform.template_compiler.reflection.model;
 
 import 'package:angular2/src/compiler/util.dart';
-import 'package:angular2/src/core/linker/event_config.dart';
 
 /// Defines the names of getters, setters, and methods which need to be
 /// available to Angular 2 via the `reflector` at runtime.
@@ -42,5 +41,15 @@ class ReflectiveAccessor {
 }
 
 String sanitizePropertyName(String name) {
-  return dashCaseToCamelCase(EventConfig.parse(name).fieldName);
+  // Angular supports renaming class property names
+  // when used in a template.
+  // Long syntax: 'classPropertyName: templateName'
+  // Short syntax: 'classPropertyName'
+  // This method always returns the 'classPropertyName'.
+  var fieldName = name;
+  var separatorIdx = name.indexOf(':');
+  if (separatorIdx > -1) {
+    fieldName = name.substring(0, separatorIdx).trim();
+  }
+  return dashCaseToCamelCase(fieldName);
 }
diff --git a/modules_dart/transform/lib/src/transform/template_compiler/reflection/processor.dart b/modules_dart/transform/lib/src/transform/template_compiler/reflection/processor.dart
index d51157e..404a3e2 100644
--- a/modules_dart/transform/lib/src/transform/template_compiler/reflection/processor.dart
+++ b/modules_dart/transform/lib/src/transform/template_compiler/reflection/processor.dart
@@ -14,16 +14,18 @@ class Processor implements CodegenModel {
   /// The names of all requested `method`s.
   final Set<ReflectiveAccessor> methodNames = new Set<ReflectiveAccessor>();
 
-  void process(CompileDirectiveMetadata meta) {
-    if (meta.outputs != null) {
-      meta.outputs.keys.forEach((eventName) {
-        getterNames.add(new ReflectiveAccessor(eventName));
-      });
-    }
-    if (meta.inputs != null) {
-      meta.inputs.keys.forEach((inputName) {
-        setterNames.add(new ReflectiveAccessor(inputName));
-      });
+  void process(CompileMetadataWithType meta) {
+    if (meta is CompileDirectiveMetadata) {
+      if (meta.outputs != null) {
+        meta.outputs.keys.forEach((eventName) {
+          getterNames.add(new ReflectiveAccessor(eventName));
+        });
+      }
+      if (meta.inputs != null) {
+        meta.inputs.keys.forEach((inputName) {
+          setterNames.add(new ReflectiveAccessor(inputName));
+        });
+      }
     }
   }
 }
diff --git a/modules_dart/transform/lib/src/transform/template_compiler/transformer.dart b/modules_dart/transform/lib/src/transform/template_compiler/transformer.dart
index 7928147..ad045c6 100644
--- a/modules_dart/transform/lib/src/transform/template_compiler/transformer.dart
+++ b/modules_dart/transform/lib/src/transform/template_compiler/transformer.dart
@@ -46,7 +46,8 @@ class TemplateCompiler extends Transformer implements LazyTransformer {
       var outputs = await processTemplates(reader, primaryId,
           genChangeDetectionDebugInfo: options.genChangeDetectionDebugInfo,
           reflectPropertiesAsAttributes: options.reflectPropertiesAsAttributes,
-          platformDirectives: options.platformDirectives);
+          platformDirectives: options.platformDirectives,
+          platformPipes: options.platformPipes);
       var ngDepsCode = _emptyNgDepsContents;
       var templatesCode = '';
       if (outputs != null) {
diff --git a/modules_dart/transform/test/transform/common/compile_directive_metadata/ng_for.ng_meta.dart b/modules_dart/transform/test/transform/common/compile_directive_metadata/ng_for.ng_meta.dart
index c2620df..20437d0 100644
--- a/modules_dart/transform/test/transform/common/compile_directive_metadata/ng_for.ng_meta.dart
+++ b/modules_dart/transform/test/transform/common/compile_directive_metadata/ng_for.ng_meta.dart
@@ -4,6 +4,7 @@ final ngFor = {
   "NgFor": {
     "kind": "type",
     "value": {
+      "class": "Directive",
       "isComponent": false,
       "dynamicLoadable": true,
       "selector": "[ngFor][ngForOf]",
diff --git a/modules_dart/transform/test/transform/common/ng_meta_helper.dart b/modules_dart/transform/test/transform/common/ng_meta_helper.dart
index cbc7475..6f13616 100644
--- a/modules_dart/transform/test/transform/common/ng_meta_helper.dart
+++ b/modules_dart/transform/test/transform/common/ng_meta_helper.dart
@@ -26,6 +26,17 @@ CompileDirectiveMetadata createComponentMetadataForTest(
           encapsulation: ViewEncapsulation.Emulated, template: template));
 }
 
+CompilePipeMetadata createPipeMetadataForTest(
+    {String name: 'TestPipe',
+    moduleUrl: 'asset:angular2/test/test.dart',
+    String pipeName: 'test',
+    bool pure: false}) {
+  return new CompilePipeMetadata(
+      type: new CompileTypeMetadata(name: name, moduleUrl: moduleUrl),
+      name: pipeName,
+      pure: pure);
+}
+
 CompileDirectiveMetadata createDirectiveMetadataForTest(
     {String name: 'TestMetadata',
     String moduleUrl: 'asset:angular2/test/test.dart',
@@ -59,6 +70,13 @@ CompileDirectiveMetadata createBar([String moduleBase = 'asset:a']) =>
         selector: 'bar',
         template: 'Bar');
 
+CompilePipeMetadata createBarPipe([String moduleBase = 'asset:a']) =>
+    createPipeMetadataForTest(
+        name: 'BarPipe',
+        pipeName: 'bar',
+        moduleUrl: '$moduleBase/export_cycle_files/bar.dart',
+        pure: false);
+
 CompileDirectiveMetadata createBaz([String moduleBase = 'asset:a']) =>
     createComponentMetadataForTest(
         name: 'BazComponent',
diff --git a/modules_dart/transform/test/transform/deferred_rewriter/complex_deferred_example/hello.ng_meta.json b/modules_dart/transform/test/transform/deferred_rewriter/complex_deferred_example/hello.ng_meta.json
index 5368afb..1d06b71 100644
--- a/modules_dart/transform/test/transform/deferred_rewriter/complex_deferred_example/hello.ng_meta.json
+++ b/modules_dart/transform/test/transform/deferred_rewriter/complex_deferred_example/hello.ng_meta.json
@@ -3,6 +3,7 @@
   {
     "kind": "type",
     "value": {
+      "class": "Directive",
       "isComponent": true,
       "dynamicLoadable": true,
       "selector":"hello-app",
@@ -29,4 +30,4 @@
       }
     }
   }
-}
\ No newline at end of file
+}
diff --git a/modules_dart/transform/test/transform/deferred_rewriter/simple_deferred_example/hello.ng_meta.json b/modules_dart/transform/test/transform/deferred_rewriter/simple_deferred_example/hello.ng_meta.json
index a4b890a..7bd5ce3 100644
--- a/modules_dart/transform/test/transform/deferred_rewriter/simple_deferred_example/hello.ng_meta.json
+++ b/modules_dart/transform/test/transform/deferred_rewriter/simple_deferred_example/hello.ng_meta.json
@@ -3,6 +3,7 @@
   {
     "kind": "type",
     "value": {
+      "class": "Directive",
       "isComponent": true,
       "dynamicLoadable": true,
       "selector":"hello-app",
@@ -29,4 +30,4 @@
       }
     }
   }
-}
\ No newline at end of file
+}
diff --git a/modules_dart/transform/test/transform/directive_processor/all_tests.dart b/modules_dart/transform/test/transform/directive_processor/all_tests.dart
index 5075ac2..3ab1785 100644
--- a/modules_dart/transform/test/transform/directive_processor/all_tests.dart
+++ b/modules_dart/transform/test/transform/directive_processor/all_tests.dart
@@ -460,8 +460,8 @@ void allTests() {
       expect(componentFirst.directives).toBeNotNull();
       expect(componentFirst.directives.length).toEqual(2);
       expect(componentFirst.directives.first)
-          .toEqual(new PrefixedDirective()..name = 'Dep');
-      expect(componentFirst.directives[1]).toEqual(new PrefixedDirective()
+          .toEqual(new PrefixedType()..name = 'Dep');
+      expect(componentFirst.directives[1]).toEqual(new PrefixedType()
         ..name = 'Dep'
         ..prefix = 'dep2');
     });
@@ -474,11 +474,10 @@ void allTests() {
       expect(viewFirst).toBeNotNull();
       expect(viewFirst.directives).toBeNotNull();
       expect(viewFirst.directives.length).toEqual(2);
-      expect(viewFirst.directives.first).toEqual(new PrefixedDirective()
+      expect(viewFirst.directives.first).toEqual(new PrefixedType()
         ..name = 'Dep'
         ..prefix = 'dep2');
-      expect(viewFirst.directives[1])
-          .toEqual(new PrefixedDirective()..name = 'Dep');
+      expect(viewFirst.directives[1]).toEqual(new PrefixedType()..name = 'Dep');
     });
 
     it('should populate `directives` from @Component value with no @View.',
@@ -490,12 +489,54 @@ void allTests() {
       expect(componentOnly.directives).toBeNotNull();
       expect(componentOnly.directives.length).toEqual(2);
       expect(componentOnly.directives.first)
-          .toEqual(new PrefixedDirective()..name = 'Dep');
-      expect(componentOnly.directives[1]).toEqual(new PrefixedDirective()
+          .toEqual(new PrefixedType()..name = 'Dep');
+      expect(componentOnly.directives[1]).toEqual(new PrefixedType()
         ..name = 'Dep'
         ..prefix = 'dep2');
     });
 
+    it('should populate `pipes` from @View value specified second.', () async {
+      var model =
+          (await _testCreateModel('directives_files/components.dart')).ngDeps;
+      final componentFirst = reflectableNamed(model, 'ComponentFirst');
+      expect(componentFirst).toBeNotNull();
+      expect(componentFirst.pipes).toBeNotNull();
+      expect(componentFirst.pipes.length).toEqual(2);
+      expect(componentFirst.pipes.first)
+          .toEqual(new PrefixedType()..name = 'PipeDep');
+      expect(componentFirst.pipes[1]).toEqual(new PrefixedType()
+        ..name = 'PipeDep'
+        ..prefix = 'dep2');
+    });
+
+    it('should populate `pipes` from @View value specified first.', () async {
+      var model =
+          (await _testCreateModel('directives_files/components.dart')).ngDeps;
+      final viewFirst = reflectableNamed(model, 'ViewFirst');
+      expect(viewFirst).toBeNotNull();
+      expect(viewFirst.pipes).toBeNotNull();
+      expect(viewFirst.pipes.length).toEqual(2);
+      expect(viewFirst.pipes.first).toEqual(new PrefixedType()
+        ..name = 'PipeDep'
+        ..prefix = 'dep2');
+      expect(viewFirst.pipes[1]).toEqual(new PrefixedType()..name = 'PipeDep');
+    });
+
+    it('should populate `pipes` from @Component value with no @View.',
+        () async {
+      var model =
+          (await _testCreateModel('directives_files/components.dart')).ngDeps;
+      final componentOnly = reflectableNamed(model, 'ComponentOnly');
+      expect(componentOnly).toBeNotNull();
+      expect(componentOnly.pipes).toBeNotNull();
+      expect(componentOnly.pipes.length).toEqual(2);
+      expect(componentOnly.pipes.first)
+          .toEqual(new PrefixedType()..name = 'PipeDep');
+      expect(componentOnly.pipes[1]).toEqual(new PrefixedType()
+        ..name = 'PipeDep'
+        ..prefix = 'dep2');
+    });
+
     it('should merge `outputs` from the annotation and fields.', () async {
       var model = await _testCreateModel('directives_files/components.dart');
       expect(model.types['ComponentWithOutputs'].outputs).toEqual(
@@ -560,6 +601,30 @@ void allTests() {
       expect(warning.toLowerCase())
           .toContain('cannot specify view parameters on @component');
     });
+
+    it('should warn if @Component has `pipes` and @View is present.', () async {
+      final logger = new RecordingLogger();
+      final model = await _testCreateModel('bad_directives_files/pipes.dart',
+          logger: logger);
+      var warning =
+          logger.logs.firstWhere((l) => l.contains('WARN'), orElse: () => null);
+      expect(warning).toBeNotNull();
+      expect(warning.toLowerCase())
+          .toContain('cannot specify view parameters on @component');
+    });
+  });
+
+  describe('pipes', () {
+    it('should read the pipe name', () async {
+      var model = await _testCreateModel('pipe_files/pipes.dart');
+      expect(model.types['NameOnlyPipe'].name).toEqual('nameOnly');
+      expect(model.types['NameOnlyPipe'].pure).toBe(false);
+    });
+
+    it('should read the pure flag', () async {
+      var model = await _testCreateModel('pipe_files/pipes.dart');
+      expect(model.types['NameAndPurePipe'].pure).toBe(true);
+    });
   });
 }
 
diff --git a/modules_dart/transform/test/transform/directive_processor/bad_directives_files/pipes.dart b/modules_dart/transform/test/transform/directive_processor/bad_directives_files/pipes.dart
new file mode 100644
index 0000000..c455922
--- /dev/null
+++ b/modules_dart/transform/test/transform/directive_processor/bad_directives_files/pipes.dart
@@ -0,0 +1,9 @@
+library angular2.test.transform.directive_processor.bad_directives_files.pipes;
+
+import 'package:angular2/angular2.dart'
+    show Component, Directive, View, NgElement;
+import 'dep1.dart';
+
+@Component(selector: 'component-first', pipes: [Dep])
+@View(template: '<div>Hi</div>')
+class BadDirectives {}
diff --git a/modules_dart/transform/test/transform/directive_processor/directives_files/components.dart b/modules_dart/transform/test/transform/directive_processor/directives_files/components.dart
index 31d27bd..28e3b8b 100644
--- a/modules_dart/transform/test/transform/directive_processor/directives_files/components.dart
+++ b/modules_dart/transform/test/transform/directive_processor/directives_files/components.dart
@@ -6,17 +6,24 @@ import 'dep1.dart';
 import 'dep2.dart' as dep2;
 
 @Component(selector: 'component-first')
-@View(template: '<dep1></dep1><dep2></dep2>', directives: [Dep, dep2.Dep])
+@View(
+    template: '<dep1></dep1><dep2></dep2>',
+    directives: [Dep, dep2.Dep],
+    pipes: [PipeDep, dep2.PipeDep])
 class ComponentFirst {}
 
-@View(template: '<dep1></dep1><dep2></dep2>', directives: [dep2.Dep, Dep])
+@View(
+    template: '<dep1></dep1><dep2></dep2>',
+    directives: [dep2.Dep, Dep],
+    pipes: [dep2.PipeDep, PipeDep])
 @Component(selector: 'view-first')
 class ViewFirst {}
 
 @Component(
     selector: 'component-only',
     template: '<dep1></dep1><dep2></dep2>',
-    directives: [Dep, dep2.Dep])
+    directives: [Dep, dep2.Dep],
+    pipes: [PipeDep, dep2.PipeDep])
 class ComponentOnly {}
 
 @Component(
diff --git a/modules_dart/transform/test/transform/directive_processor/directives_files/dep1.dart b/modules_dart/transform/test/transform/directive_processor/directives_files/dep1.dart
index 95b2819..ec5d81f 100644
--- a/modules_dart/transform/test/transform/directive_processor/directives_files/dep1.dart
+++ b/modules_dart/transform/test/transform/directive_processor/directives_files/dep1.dart
@@ -1,8 +1,10 @@
 library angular2.test.transform.directive_processor.directive_files.dep1;
 
-import 'package:angular2/angular2.dart'
-    show Component, Directive, View, NgElement;
+import 'package:angular2/angular2.dart' show Component, Directive, View, Pipe;
 
 @Component(selector: 'dep1')
 @View(template: 'Dep1')
 class Dep {}
+
+@Pipe(name: 'dep1')
+class PipeDep {}
diff --git a/modules_dart/transform/test/transform/directive_processor/directives_files/dep2.dart b/modules_dart/transform/test/transform/directive_processor/directives_files/dep2.dart
index a4eeb14..4d027c8 100644
--- a/modules_dart/transform/test/transform/directive_processor/directives_files/dep2.dart
+++ b/modules_dart/transform/test/transform/directive_processor/directives_files/dep2.dart
@@ -1,8 +1,10 @@
 library angular2.test.transform.directive_processor.directive_files.dep2;
 
-import 'package:angular2/angular2.dart'
-    show Component, Directive, View, NgElement;
+import 'package:angular2/angular2.dart' show Component, Directive, View, Pipe;
 
 @Component(selector: 'dep2')
 @View(template: 'Dep2')
 class Dep {}
+
+@Pipe(name: 'dep2')
+class PipeDep {}
diff --git a/modules_dart/transform/test/transform/directive_processor/pipe_files/pipes.dart b/modules_dart/transform/test/transform/directive_processor/pipe_files/pipes.dart
new file mode 100644
index 0000000..88d7617
--- /dev/null
+++ b/modules_dart/transform/test/transform/directive_processor/pipe_files/pipes.dart
@@ -0,0 +1,9 @@
+library angular2.test.transform.directive_processor.pipe_files.pipes;
+
+import 'package:angular2/angular2.dart' show Pipe;
+
+@Pipe(name: 'nameOnly')
+class NameOnlyPipe {}
+
+@Pipe(name: 'nameAndPure', pure: true)
+class NameAndPurePipe {}
diff --git a/modules_dart/transform/test/transform/integration/deferred_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/deferred_files/expected/bar.ng_deps.dart
index fb5036a..c4c438c 100644
--- a/modules_dart/transform/test/transform/integration/deferred_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/deferred_files/expected/bar.ng_deps.dart
@@ -17,7 +17,7 @@ void initReflector() {
         new _ngRef.ReflectionInfo(const [
           const Component(selector: '[soup]'),
           const View(template: ''),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [], () => new MyComponent()));
   i0.initReflector();
 }
diff --git a/modules_dart/transform/test/transform/integration/directive_chain_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/directive_chain_files/expected/bar.ng_deps.dart
index 79685a3..ef0233c 100644
--- a/modules_dart/transform/test/transform/integration/directive_chain_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/directive_chain_files/expected/bar.ng_deps.dart
@@ -19,7 +19,7 @@ void initReflector() {
         new _ngRef.ReflectionInfo(const [
           const Component(selector: 'soup'),
           const View(directives: [Foo], template: 'foo'),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [], () => new MyComponent()));
   i0.initReflector();
   i1.initReflector();
diff --git a/modules_dart/transform/test/transform/integration/directive_dep_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/directive_dep_files/expected/bar.ng_deps.dart
index a4042fda..a64aab4 100644
--- a/modules_dart/transform/test/transform/integration/directive_dep_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/directive_dep_files/expected/bar.ng_deps.dart
@@ -19,7 +19,7 @@ void initReflector() {
         new _ngRef.ReflectionInfo(const [
           const Component(selector: 'soup'),
           const View(directives: [prefix.Foo], template: 'foo'),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [], () => new MyComponent()));
   i0.initReflector();
   i1.initReflector();
diff --git a/modules_dart/transform/test/transform/integration/empty_ng_deps_files/expected/foo.ng_deps.dart b/modules_dart/transform/test/transform/integration/empty_ng_deps_files/expected/foo.ng_deps.dart
index 3dd525c..c2d7ce4 100644
--- a/modules_dart/transform/test/transform/integration/empty_ng_deps_files/expected/foo.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/empty_ng_deps_files/expected/foo.ng_deps.dart
@@ -19,7 +19,7 @@ void initReflector() {
         new _ngRef.ReflectionInfo(const [
           const Component(selector: '[soup]'),
           const View(directives: const [directiveAlias], template: ''),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [], () => new MyComponent()));
   i0.initReflector();
   i1.initReflector();
diff --git a/modules_dart/transform/test/transform/integration/event_getter_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/event_getter_files/expected/bar.ng_deps.dart
index 6e97777..d7e7b68 100644
--- a/modules_dart/transform/test/transform/integration/event_getter_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/event_getter_files/expected/bar.ng_deps.dart
@@ -19,7 +19,7 @@ void initReflector() {
               outputs: ['eventName1', 'eventName2: propName2'],
               selector: '[soup]'),
           const View(template: ''),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [], () => new MyComponent()))
     ..registerGetters(
         {'eventName1': (o) => o.eventName1, 'eventName2': (o) => o.eventName2});
diff --git a/modules_dart/transform/test/transform/integration/list_of_types_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/list_of_types_files/expected/bar.ng_deps.dart
index e218e06..f13458d 100644
--- a/modules_dart/transform/test/transform/integration/list_of_types_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/list_of_types_files/expected/bar.ng_deps.dart
@@ -18,7 +18,7 @@ void initReflector() {
         new _ngRef.ReflectionInfo(const [
           const Component(componentServices: const [MyContext]),
           const View(template: ''),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [
           const [MyContext]
         ], (MyContext c) => new MyComponent(c)));
diff --git a/modules_dart/transform/test/transform/integration/override_annotation_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/override_annotation_files/expected/bar.ng_deps.dart
index 53a0ddc..43fd420 100644
--- a/modules_dart/transform/test/transform/integration/override_annotation_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/override_annotation_files/expected/bar.ng_deps.dart
@@ -18,7 +18,7 @@ void initReflector() {
             const [
               const Component(selector: '[soup]'),
               const View(template: ''),
-              _templates.HostMyComponentTemplate
+              _templates.hostViewFactory_MyComponent
             ],
             const [],
             () => new MyComponent(),
diff --git a/modules_dart/transform/test/transform/integration/queries_class_annotation_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/queries_class_annotation_files/expected/bar.ng_deps.dart
index 95e6bb1..28b8e64 100644
--- a/modules_dart/transform/test/transform/integration/queries_class_annotation_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/queries_class_annotation_files/expected/bar.ng_deps.dart
@@ -19,7 +19,7 @@ void initReflector() {
               queries: const {'queryField': const ContentChild('child')},
               selector: '[soup]'),
           const View(template: ''),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [], () => new MyComponent()))
     ..registerSetters({'queryField': (o, v) => o.queryField = v});
   i0.initReflector();
diff --git a/modules_dart/transform/test/transform/integration/queries_prop_annotation_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/queries_prop_annotation_files/expected/bar.ng_deps.dart
index 13c6389..200405a 100644
--- a/modules_dart/transform/test/transform/integration/queries_prop_annotation_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/queries_prop_annotation_files/expected/bar.ng_deps.dart
@@ -18,7 +18,7 @@ void initReflector() {
             const [
               const Component(selector: '[soup]'),
               const View(template: ''),
-              _templates.HostMyComponentTemplate
+              _templates.hostViewFactory_MyComponent
             ],
             const [],
             () => new MyComponent(),
diff --git a/modules_dart/transform/test/transform/integration/simple_annotation_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/simple_annotation_files/expected/bar.ng_deps.dart
index 6db43dc..8b073ed 100644
--- a/modules_dart/transform/test/transform/integration/simple_annotation_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/simple_annotation_files/expected/bar.ng_deps.dart
@@ -16,7 +16,7 @@ void initReflector() {
         MyComponent,
         new _ngRef.ReflectionInfo(const [
           const Component(selector: '[soup]', template: 'aa'),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [], () => new MyComponent()));
   i0.initReflector();
 }
diff --git a/modules_dart/transform/test/transform/integration/simple_annotation_files/expected/bar.ng_meta.json b/modules_dart/transform/test/transform/integration/simple_annotation_files/expected/bar.ng_meta.json
deleted file mode 100644
index 313a65c..0000000
--- a/modules_dart/transform/test/transform/integration/simple_annotation_files/expected/bar.ng_meta.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-  "MyComponent": {
-    "kind": "type",
-    "value": {
-      "id": "MyComponent",
-      "selector": "[soup]",
-      "compileChildren": true,
-      "hostProperties": {},
-      "hostListeners": {},
-      "hostAttributes": {},
-      "inputs": [],
-      "readAttributes": [],
-      "type": 1,
-      "exportAs": null,
-      "callOnDestroy": false,
-      "callDoCheck": false,
-      "callOnInit": false,
-      "callOnChanges": false,
-      "callAfterContentInit": false,
-      "callAfterContentChecked": false,
-      "callAfterViewInit": false,
-      "callAfterViewChecked": false,
-      "outputs": [],
-      "changeDetection": null,
-      "version": 1
-    }
-  }
-}
diff --git a/modules_dart/transform/test/transform/integration/synthetic_ctor_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/synthetic_ctor_files/expected/bar.ng_deps.dart
index fb5036a..c4c438c 100644
--- a/modules_dart/transform/test/transform/integration/synthetic_ctor_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/synthetic_ctor_files/expected/bar.ng_deps.dart
@@ -17,7 +17,7 @@ void initReflector() {
         new _ngRef.ReflectionInfo(const [
           const Component(selector: '[soup]'),
           const View(template: ''),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [], () => new MyComponent()));
   i0.initReflector();
 }
diff --git a/modules_dart/transform/test/transform/integration/two_annotations_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/two_annotations_files/expected/bar.ng_deps.dart
index 35b3e52..5e81fad 100644
--- a/modules_dart/transform/test/transform/integration/two_annotations_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/two_annotations_files/expected/bar.ng_deps.dart
@@ -17,7 +17,7 @@ void initReflector() {
         new _ngRef.ReflectionInfo(const [
           const Component(selector: '[soup]'),
           const View(template: 'Salad: {{myNum}} is awesome'),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ], const [], () => new MyComponent()));
   i0.initReflector();
 }
diff --git a/modules_dart/transform/test/transform/integration/two_deps_files/expected/bar.ng_deps.dart b/modules_dart/transform/test/transform/integration/two_deps_files/expected/bar.ng_deps.dart
index e324223..551d9cd 100644
--- a/modules_dart/transform/test/transform/integration/two_deps_files/expected/bar.ng_deps.dart
+++ b/modules_dart/transform/test/transform/integration/two_deps_files/expected/bar.ng_deps.dart
@@ -19,7 +19,7 @@ void initReflector() {
             const [
           const Component(selector: 'soup'),
           const View(template: ''),
-          _templates.HostMyComponentTemplate
+          _templates.hostViewFactory_MyComponent
         ],
             const [
           const [prefix.MyContext],
diff --git a/modules_dart/transform/test/transform/template_compiler/all_tests.dart b/modules_dart/transform/test/transform/template_compiler/all_tests.dart
index b29ad38..80db146 100644
--- a/modules_dart/transform/test/transform/template_compiler/all_tests.dart
+++ b/modules_dart/transform/test/transform/template_compiler/all_tests.dart
@@ -26,7 +26,7 @@ RecordingLogger logger;
 main() => allTests();
 
 var fooComponentMeta, fooNgMeta, fooAssetId;
-var barComponentMeta, barNgMeta, barAssetId;
+var barComponentMeta, barPipeMeta, barNgMeta, barAssetId;
 var bazComponentMeta, bazNgMeta, bazAssetId;
 
 /// Call after making changes to `fooNgMeta`, `barNgMeta`, or `bazNgMeta` and
@@ -58,10 +58,13 @@ void allTests() {
     fooNgMeta.types[fooComponentMeta.type.name] = fooComponentMeta;
 
     barComponentMeta = createBar(moduleBase);
+    barPipeMeta = createBarPipe(moduleBase);
     barNgMeta = new NgMeta(ngDeps: new NgDepsModel()
       ..libraryUri = 'test.bar'
+      ..reflectables.add(new ReflectionInfoModel()..name = barPipeMeta.type.name)
       ..reflectables.add(new ReflectionInfoModel()..name = barComponentMeta.type.name));
     barNgMeta.types[barComponentMeta.type.name] = barComponentMeta;
+    barNgMeta.types[barPipeMeta.type.name] = barPipeMeta;
 
     bazComponentMeta = createBaz(moduleBase);
     bazNgMeta = new NgMeta(ngDeps: new NgDepsModel()
@@ -75,11 +78,13 @@ void allTests() {
     updateReader();
   });
 
-  Future<String> process(AssetId assetId, {List<String> platformDirectives}) {
+  Future<String> process(AssetId assetId,
+      {List<String> platformDirectives, List<String> platformPipes}) {
     logger = new RecordingLogger();
     return zone.exec(
         () => processTemplates(reader, assetId,
-            platformDirectives: platformDirectives),
+            platformDirectives: platformDirectives,
+            platformPipes: platformPipes),
         log: logger);
   }
 
@@ -93,7 +98,7 @@ void allTests() {
       ..isView = true;
     fooNgMeta.ngDeps.reflectables.first.annotations.add(viewAnnotation);
     fooNgMeta.ngDeps.reflectables.first.directives
-        .add(new PrefixedDirective()..name = 'NgFor');
+        .add(new PrefixedType()..name = 'NgFor');
     fooNgMeta.ngDeps.imports.add(
         new ImportModel()..uri = 'package:angular2/src/directives/ng_for.dart');
 
@@ -121,7 +126,7 @@ void allTests() {
       ..prefix = '_templates');
     expect(ngDeps.reflectables.first.annotations)
         .toContain(new AnnotationModel()
-          ..name = '_templates.HostFooComponentTemplate'
+          ..name = '_templates.hostViewFactory_FooComponent'
           ..isConstObject = true);
     expect(outputs.templatesCode)
       ..toContain('$CONTEXT_ACCESSOR.greeting')
@@ -142,7 +147,7 @@ void allTests() {
       ..prefix = '_templates');
     expect(ngDeps.reflectables.first.annotations)
         .toContain(new AnnotationModel()
-          ..name = '_templates.HostFooComponentTemplate'
+          ..name = '_templates.hostViewFactory_FooComponent'
           ..isConstObject = true);
     expect(outputs.templatesCode)..toContain('$CONTEXT_ACCESSOR.action()');
   });
@@ -158,7 +163,7 @@ void allTests() {
       ..value = 'const [${barComponentMeta.type.name}]');
     fooNgMeta.ngDeps.reflectables.first.annotations.add(viewAnnotation);
     fooNgMeta.ngDeps.reflectables.first.directives
-        .add(new PrefixedDirective()..name = barComponentMeta.type.name);
+        .add(new PrefixedType()..name = barComponentMeta.type.name);
     fooNgMeta.ngDeps.imports.add(new ImportModel()..uri = 'bar.dart');
     barComponentMeta.template =
         new CompileTemplateMetadata(template: 'BarTemplate');
@@ -172,7 +177,7 @@ void allTests() {
       ..prefix = '_templates');
     expect(ngDeps.reflectables.first.annotations)
         .toContain(new AnnotationModel()
-          ..name = '_templates.HostFooComponentTemplate'
+          ..name = '_templates.hostViewFactory_FooComponent'
           ..isConstObject = true);
 
     expect(outputs.templatesCode)
@@ -188,7 +193,7 @@ void allTests() {
       ..name = 'View'
       ..isView = true;
     fooNgMeta.ngDeps.reflectables.first.annotations.add(componentAnnotation);
-    fooNgMeta.ngDeps.reflectables.first.directives.add(new PrefixedDirective()
+    fooNgMeta.ngDeps.reflectables.first.directives.add(new PrefixedType()
       ..name = barComponentMeta.type.name
       ..prefix = 'prefix');
     fooNgMeta.ngDeps.imports.add(new ImportModel()
@@ -206,7 +211,7 @@ void allTests() {
       ..prefix = '_templates');
     expect(ngDeps.reflectables.first.annotations)
         .toContain(new AnnotationModel()
-          ..name = '_templates.HostFooComponentTemplate'
+          ..name = '_templates.hostViewFactory_FooComponent'
           ..isConstObject = true);
 
     expect(outputs.templatesCode)
@@ -222,7 +227,7 @@ void allTests() {
       ..isView = true;
     fooNgMeta.ngDeps.reflectables.first.annotations.add(componentAnnotation);
     fooNgMeta.ngDeps.reflectables.first.directives
-        .add(new PrefixedDirective()..name = 'directiveAlias');
+        .add(new PrefixedType()..name = 'directiveAlias');
     fooNgMeta.ngDeps.imports.add(new ImportModel()..uri = 'bar.dart');
 
     fooNgMeta.aliases['directiveAlias'] = [barComponentMeta.type.name];
@@ -238,7 +243,7 @@ void allTests() {
       ..prefix = '_templates');
     expect(ngDeps.reflectables.first.annotations)
         .toContain(new AnnotationModel()
-          ..name = '_templates.HostFooComponentTemplate'
+          ..name = '_templates.hostViewFactory_FooComponent'
           ..isConstObject = true);
 
     expect(outputs.templatesCode)
@@ -352,8 +357,8 @@ void allTests() {
   });
 
   it('should include platform directives.', () async {
-    fooComponentMeta.template = new CompileTemplateMetadata(
-        template: '<bar></bar>');
+    fooComponentMeta.template =
+        new CompileTemplateMetadata(template: '<bar></bar>');
     final viewAnnotation = new AnnotationModel()
       ..name = 'View'
       ..isView = true;
@@ -370,9 +375,9 @@ void allTests() {
       ..toContain(barComponentMeta.template.template);
   });
 
-  it('should include platform directives when it it a list.', () async {
-    fooComponentMeta.template = new CompileTemplateMetadata(
-        template: '<bar></bar>');
+  it('should include platform directives when it is a list.', () async {
+    fooComponentMeta.template =
+        new CompileTemplateMetadata(template: '<bar></bar>');
     final viewAnnotation = new AnnotationModel()
       ..name = 'View'
       ..isView = true;
@@ -417,6 +422,43 @@ void allTests() {
     final ngDeps = outputs.ngDeps;
     expect(ngDeps).toBeNotNull();
   });
+
+  it('should parse `View` pipes with a single dependency.', () async {
+    fooComponentMeta.template =
+        new CompileTemplateMetadata(template: '{{1 | bar}}');
+    final viewAnnotation = new AnnotationModel()
+      ..name = 'View'
+      ..isView = true;
+    viewAnnotation.namedParameters.add(new NamedParameter()
+      ..name = 'pipes'
+      ..value = 'const [${barPipeMeta.type.name}]');
+    fooNgMeta.ngDeps.reflectables.first.annotations.add(viewAnnotation);
+    fooNgMeta.ngDeps.reflectables.first.pipes
+        .add(new PrefixedType()..name = barPipeMeta.type.name);
+    fooNgMeta.ngDeps.imports.add(new ImportModel()..uri = 'bar.dart');
+    updateReader();
+
+    final outputs = await process(fooAssetId);
+
+    expect(outputs.templatesCode)
+      ..toContain("import 'bar.dart'")
+      ..toContain(barPipeMeta.name);
+  });
+
+  it('should include platform pipes.', () async {
+    fooComponentMeta.template =
+        new CompileTemplateMetadata(template: '{{1 | bar}}');
+
+    barNgMeta.aliases['PLATFORM'] = [barPipeMeta.type.name];
+    updateReader();
+
+    final outputs = await process(fooAssetId,
+        platformPipes: ['package:a/bar.dart#PLATFORM']);
+
+    expect(outputs.templatesCode)
+      ..toContain("import 'bar.dart'")
+      ..toContain(barPipeMeta.name);
+  });
 }
 
 void _formatThenExpectEquals(String actual, String expected) {

From 7ae4f55096326536b8985509c1c655cb1918ac91 Mon Sep 17 00:00:00 2001
From: usernamealreadyis <jayashipping@hotmail.com>
Date: Wed, 6 Jan 2016 04:41:24 +0700
Subject: [PATCH 09/12] Delete DEVELOPER.md

angular/DEVELOPER.md
2ce9e95  on Nov 14, 2015
@IgorMinar IgorMinar docs(DEVELOPER.md): update info about clang-format setup
---
 DEVELOPER.md | 356 -----------------------------------------------------------
 1 file changed, 356 deletions(-)
 delete mode 100644 DEVELOPER.md

diff --git a/DEVELOPER.md b/DEVELOPER.md
deleted file mode 100644
index aa162be..0000000
--- a/DEVELOPER.md
+++ /dev/null
@@ -1,356 +0,0 @@
-# Building and Testing Angular 2 for JS and Dart
-
-This document describes how to set up your development environment to build and test Angular, both
-JS and Dart versions. It also explains the basic mechanics of using `git`, `node`, and `npm`.
-
-* [Prerequisite Software](#prerequisite-software)
-* [Getting the Sources](#getting-the-sources)
-* [Environment Variable Setup](#environment-variable-setup)
-* [Installing NPM Modules and Dart Packages](#installing-npm-modules-and-dart-packages)
-* [Build commands](#build-commands)
-* [Running Tests Locally](#running-tests-locally)
-* [Formatting](#clang-format)
-* [Project Information](#project-information)
-* [CI using Travis](#ci-using-travis)
-* [Transforming Dart code](#transforming-dart-code)
-* [Debugging](#debugging)
-
-See the [contribution guidelines](https://github.com/angular/angular/blob/master/CONTRIBUTING.md)
-if you'd like to contribute to Angular.
-
-## Prerequisite Software
-
-Before you can build and test Angular, you must install and configure the
-following products on your development machine:
-
-* [Dart](https://www.dartlang.org) (version ` >=1.12.0 <2.0.0`), specifically the Dart-SDK and
-  Dartium (a version of [Chromium](http://www.chromium.org) with native support for Dart through
-  the Dart VM). One of the **simplest** ways to get both is to install the **Dart Editor bundle**,
-  which includes the editor, SDK and Dartium. See the [Dart tools](https://www.dartlang.org/tools)
-  download [page for instructions](https://www.dartlang.org/tools/download.html).  
-  You can also download both **stable** and **dev** channel versions from the [download
-  archive](https://www.dartlang.org/tools/download-archive). In that case, on Windows, Dart must be added
-  to the `Path` (e.g. `path-to-dart-sdk-folder\bin`) and a new `DARTIUM_BIN` environment variable must be
-  created, pointing to the executable (e.g. `path-to-dartium-folder\chrome.exe).`
-
-* [Git](http://git-scm.com) and/or the **GitHub app** (for [Mac](http://mac.github.com) or
-  [Windows](http://windows.github.com)); [GitHub's Guide to Installing
-  Git](https://help.github.com/articles/set-up-git) is a good source of information.
-
-* [Node.js](http://nodejs.org), (version `>=4.2.1 <5`) which is used to run a development web server,
-  run tests, and generate distributable files. We also use Node's Package Manager, `npm`
-  (version `>=2.14.7 <3.0`), which comes with Node. Depending on your system, you can install Node either from
-  source or as a pre-packaged bundle.
-
-* [Chrome Canary](https://www.google.com/chrome/browser/canary.html), a version of Chrome with
-  bleeding edge functionality, built especially for developers (and early adopters).
-
-* [Bower](http://bower.io/).
-
-
-## Getting the Sources
-
-Fork and clone the Angular repository:
-
-1. Login to your GitHub account or create one by following the instructions given
-   [here](https://github.com/signup/free).
-2. [Fork](http://help.github.com/forking) the [main Angular
-   repository](https://github.com/angular/angular).
-3. Clone your fork of the Angular repository and define an `upstream` remote pointing back to
-   the Angular repository that you forked in the first place.
-
-```shell
-# Clone your GitHub repository:
-git clone git@github.com:<github username>/angular.git
-
-# Go to the Angular directory:
-cd angular
-
-# Add the main Angular repository as an upstream remote to your repository:
-git remote add upstream https://github.com/angular/angular.git
-```
-
-## Environment Variable Setup
-
-Define the environment variables listed below. These are mainly needed for the testing. The
-notation shown here is for [`bash`](http://www.gnu.org/software/bash); adapt as appropriate for
-your favorite shell.
-
-Examples given below of possible values for initializing the environment variables assume **Mac OS
-X** and that you have installed the Dart Editor in the directory named by
-`DART_EDITOR_DIR=/Applications/dart`. This is only for illustrative purposes.
-
-```shell
-# DARTIUM_BIN: path to a Dartium browser executable; used by Karma to run Dart tests
-export DARTIUM_BIN="$DART_EDITOR_DIR/chromium/Chromium.app/Contents/MacOS/Chromium"
-```
-
-Add the Dart SDK `bin` directory to your path and/or define `DART_SDK` (this is also detailed
-[here](https://www.dartlang.org/tools/pub/installing.html)):
-
-```shell
-# DART_SDK: path to a Dart SDK directory
-export DART_SDK="$DART_EDITOR_DIR/dart-sdk"
-
-# Update PATH to include the Dart SDK bin directory
-PATH+=":$DART_SDK/bin"
-```
-
-And specify where the pubs dependencies are downloaded. By default, this directory is located under .pub_cache
-in your home directory (on Mac and Linux), or in AppData\Roaming\Pub\Cache (on Windows).
-
-```shell
-# PUB_CACHE: location of pub dependencies
-export PUB_CACHE="/Users/<user>/.pub-cache"
-```
-
-## Installing NPM Modules and Dart Packages
-
-Next, install the JavaScript modules and Dart packages needed to build and test Angular:
-
-```shell
-# Install Angular project dependencies (package.json)
-npm install
-```
-
-**Optional**: In this document, we make use of project local `npm` package scripts and binaries
-(stored under `./node_modules/.bin`) by prefixing these command invocations with `$(npm bin)`; in
-particular `gulp` and `protractor` commands. If you prefer, you can drop this path prefix by either:
-
-*Option 1*: globally installing these two packages as follows:
-
-* `npm install -g gulp` (you might need to prefix this command with `sudo`)
-* `npm install -g protractor` (you might need to prefix this command with `sudo`)
-
-Since global installs can become stale, and required versions can vary by project, we avoid their
-use in these instructions.
-
-*Option 2*: defining a bash alias like `alias nbin='PATH=$(npm bin):$PATH'` as detailed in this
-[Stackoverflow answer](http://stackoverflow.com/questions/9679932/how-to-use-package-installed-locally-in-node-modules/15157360#15157360) and used like this: e.g., `nbin gulp build`.
-
-## Build commands
-
-To build Angular and prepare tests, run:
-
-```shell
-$(npm bin)/gulp build
-```
-
-Notes:
-* Results are put in the `dist` folder.
-* This will also run `pub get` for the subfolders in `modules` and run `dartanalyzer` for
-  every file that matches `<module>/src/<module>.dart`, e.g. `di/src/di.dart`.
-
-You can selectively build either the JS or Dart versions as follows:
-
-* `$(npm bin)/gulp build.js`
-* `$(npm bin)/gulp build.dart`
-
-To clean out the `dist` folder, run:
-
-```shell
-$(npm bin)/gulp clean
-```
-
-## Running Tests Locally
-
-### Full test suite
-
-* `npm test`: full test suite for both JS and Dart versions of Angular. These are the same tests
-  that run on Travis.
-
-You can selectively run either the JS or Dart versions as follows:
-
-* `$(npm bin)/gulp test.all.js`
-* `$(npm bin)/gulp test.all.dart`
-
-### Unit tests
-
-You can run just the unit tests as follows:
-
-* `$(npm bin)/gulp test.unit.js`: JS tests in a browser; runs in **watch mode** (i.e.
-   watches the test files for changes and re-runs tests when files are updated).
-* `$(npm bin)/gulp test.unit.cjs`: JS tests in NodeJS; runs in **watch mode**.
-* `$(npm bin)/gulp test.unit.dart`: Dart tests in Dartium; runs in **watch mode**.
-
-If you prefer running tests in "single-run" mode rather than watch mode use:
-
-* `$(npm bin)/gulp test.unit.js/ci`
-* `$(npm bin)/gulp test.unit.cjs/ci`
-* `$(npm bin)/gulp test.unit.dart/ci`
-
-The task updates the dist folder with transpiled code whenever a source or test file changes, and
-Karma is run against the new output.
-
-**Note**: If you want to only run a single test you can alter the test you wish to run by changing
-`it` to `iit` or `describe` to `ddescribe`. This will only run that individual test and make it
-much easier to debug. `xit` and `xdescribe` can also be useful to exclude a test and a group of
-tests respectively.
-
-**Note**: **watch mode** needs symlinks to work, so if you're using windows, ensure you have the
-rights to built them in your operating system.
-
-### Unit tests with Sauce Labs or Browser Stack
-
-First, in a terminal, create a tunnel with [Sauce Connect](https://docs.saucelabs.com/reference/sauce-connect/) or [Browser Stack Local](https://www.browserstack.com/local-testing#command-line), and valid credentials.  
-
-Then, in another terminal:
- - Define the credentials as environment variables, e.g.:
-```
-export SAUCE_USERNAME='my_user'; export SAUCE_ACCESS_KEY='my_key';
-export BROWSER_STACK_USERNAME='my_user'; export BROWSER_STACK_ACCESS_KEY='my_key';
-```
- - Then run `gulp test.unit.js.(saucelabs|browserstack) --browsers=option1,option2,..,optionN`  
-The options are any mix of browsers and aliases which are defined in the [browser-providers.conf.js](https://github.com/angular/angular/blob/master/browser-providers.conf.js) file.  
-They are case insensitive, and the `SL_` or `BS_` prefix must not be added for browsers.
-
-Some examples of commands:
-```
-gulp test.unit.js.saucelabs --browsers=Safari8,ie11  //run in Sauce Labs with Safari 8 and IE11
-gulp test.unit.js.browserstack --browsers=Safari,IE  //run in Browser Stack with Safari 7, Safari 8, Safari 9, IE 9, IE 10 and IE 11
-gulp test.unit.js.saucelabs --browsers=IOS,safari8,android5.1  //run in Sauce Labs with iOS 7, iOS 8, iOs 9, Safari 8 and Android 5.1
-```
-
-### E2E tests
-
-1. `$(npm bin)/gulp build.js.cjs` (builds benchpress and tests into `dist/js/cjs` folder).
-2. `$(npm bin)/gulp serve.js.prod serve.dart` (runs a local webserver).
-3. `$(npm bin)/protractor protractor-js.conf.js`: JS e2e tests.
-4. `$(npm bin)/protractor protractor-dart2js.conf.js`: dart2js e2e tests.
-
-Angular specific command line options when running protractor:
-  - `$(npm bin)/protractor protractor-{js|dart2js}-conf.js --ng-help`
-
-### Performance tests
-
-1. `$(npm bin)/gulp build.js.cjs` (builds benchpress and tests into `dist/js/cjs` folder)
-2. `$(npm bin)/gulp serve.js.prod serve.dart` (runs a local webserver)
-3. `$(npm bin)/protractor protractor-js.conf.js --benchmark`: JS performance tests
-4. `$(npm bin)/protractor protractor-dart2js.conf.js --benchmark`: dart2js performance tests
-
-Angular specific command line options when running protractor (e.g. force gc, ...):
-`$(npm bin)/protractor protractor-{js|dart2js}-conf.js --ng-help`
-
-## Formatting with <a name="clang-format">clang-format</a>
-
-We use [clang-format](http://clang.llvm.org/docs/ClangFormat.html) to automatically enforce code
-style for our TypeScript code. This allows us to focus our code reviews more on the content, and
-less on style nit-picking. It also lets us encode our style guide in the `.clang-format` file in the
-repository, allowing many tools and editors to share our settings.
-
-To check the formatting of your code, run
-
-    gulp check-format
-
-Note that the continuous build on Travis runs `gulp enforce-format`. Unlike the `check-format` task,
-this will actually fail the build if files aren't formatted according to the style guide.
-
-Your life will be easier if you include the formatter in your standard workflow. Otherwise, you'll
-likely forget to check the formatting, and waste time waiting for a build on Travis that fails due
-to some whitespace difference.
-
-* Use `$(npm bin)/clang-format -i [file name]` to format a file (or multiple).
-* Use `gulp enforce-format` to check if your code is `clang-format` clean. This also gives
-  you a command line to format your code.
-* `clang-format` also includes a git hook, run `git clang-format` to format all files you
-  touched.
-* You can run this as a **git pre-commit hook** to automatically format your delta regions when you
-  commit a change. In the angular repo, run
-
-```
-    $ echo -e '#!/bin/sh\nexec git clang-format' > .git/hooks/pre-commit
-    $ chmod u+x !$
-```
-
-* **WebStorm** can run clang-format on the current file.
-  1. Under Preferences, open Tools > External Tools.
-  1. Plus icon to Create Tool
-  1. Fill in the form:
-    - Name: clang-format
-    - Description: Format
-    - Synchronize files after execution: checked
-    - Open console: not checked
-    - Show in: Editor menu
-    - Program: `$ProjectFileDir$/node_modules/.bin/clang-format`
-    - Parameters: `-i -style=file $FilePath$`
-    - Working directory: `$ProjectFileDir$`
-* `clang-format` integrations are also available for many popular editors (`vim`, `emacs`,
-  `Sublime Text`, etc.).
-
-## Generating the API documentation
-
-The following gulp task will generate the API docs in the `dist/angular.io/partials/api/angular2`:  
-
-```shell
-$(npm bin)/gulp docs/angular.io
-```
-
-You can serve the generated documentation to check how it would render on [angular.io](https://angular.io/):
-- check out the [angular.io repo](https://github.com/angular/angular.io) locally,
-- install dependencies as described in the [angular.io README](https://github.com/angular/angular.io/blob/master/README.md),
-- copy the generated documentation from your local angular repo at `angular/dist/angular.io/partials/api/angular2` to your local angular.io repo at `angular.io/public/docs/js/latest/api`,
-- run `harp compile` at the root of the angular.io repo to check the generated documentation for errors,
-- run `harp server` and open a browser at `http://localhost:9000/docs/js/latest/api/` to check the rendered documentation.
-
-## Project Information
-
-### Folder structure
-
-* `modules/*`: modules that will be loaded in the browser
-* `tools/*`: tools that are needed to build Angular
-* `dist/*`: build files are placed here.
-
-### File suffixes
-
-* `*.ts`: TypeScript files that get transpiled to Dart and EcmaScript 5/6
-* `*.dart`: Dart files that don't get transpiled
-
-## CI using Travis
-
-For instructions on setting up Continuous Integration using Travis, see the instructions given
-[here](https://github.com/angular/angular.dart/blob/master/travis.md).
-
-## Transforming Dart code
-
-See the [wiki](//github.com/angular/angular/wiki/Angular-2-Dart-Transformer).
-
-## Debugging
-
-### Debug the transpiler
-
-If you need to debug the transpiler:
-
-- add a `debugger;` statement in the transpiler code,
-- from the root folder, execute `node debug $(npm bin)/gulp build` to enter the node
-  debugger
-- press "c" to execute the program until you reach the `debugger;` statement,
-- you can then type "repl" to enter the REPL and inspect variables in the context.
-
-See the [Node.js manual](http://nodejs.org/api/debugger.html) for more information.
-
-Notes:
-- You can also execute `node $(npm bin)/karma start karma-dart.conf.js` depending on which
-  code you want to debug (the former will process the "modules" folder while the later processes
-  the transpiler specs).
-- You can also add `debugger;` statements in the specs (JavaScript). The execution will halt when
-  the developer tools are opened in the browser running Karma.
-
-### Debug the tests
-
-If you need to debug the tests:
-
-- add a `debugger;` statement to the test you want to debug (or the source code),
-- execute karma `$(npm bin)/gulp test.js`,
-- press the top right "DEBUG" button,
-- open the DevTools and press F5,
-- the execution halts at the `debugger;` statement
-
-**Note (WebStorm users)**:
-
-1. Create a Karma run config from WebStorm.
-2. Then in the "Run" menu, press "Debug 'karma-js.conf.js'", and WebStorm will stop in the generated
-   code on the `debugger;` statement.
-3. You can then step into the code and add watches.
-
-The `debugger;` statement is needed because WebStorm will stop in a transpiled file. Breakpoints in
-the original source files are not supported at the moment.

From 9f12d77771d89cba8812a61d6f13989a00531291 Mon Sep 17 00:00:00 2001
From: usernamealreadyis <jayashipping@hotmail.com>
Date: Wed, 6 Jan 2016 05:16:17 +0700
Subject: [PATCH 10/12] Create DEVELOPER.MD

---
 DEVELOPER.MD | 358 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 358 insertions(+)
 create mode 100644 DEVELOPER.MD

diff --git a/DEVELOPER.MD b/DEVELOPER.MD
new file mode 100644
index 0000000..5b077fb
--- /dev/null
+++ b/DEVELOPER.MD
@@ -0,0 +1,358 @@
+# Building and Testing Angular 2 for JS and Dart
+
+This document describes how to set up your development environment to build and test Angular, both
+JS and Dart versions. It also explains the basic mechanics of using `git`, `node`, and `npm`.
+
+* [Prerequisite Software](#prerequisite-software)
+* [Getting the Sources](#getting-the-sources)
+* [Environment Variable Setup](#environment-variable-setup)
+* [Installing NPM Modules and Dart Packages](#installing-npm-modules-and-dart-packages)
+* [Build commands](#build-commands)
+* [Running Tests Locally](#running-tests-locally)
+* [Formatting](#clang-format)
+* [Project Information](#project-information)
+* [CI using Travis](#ci-using-travis)
+* [Transforming Dart code](#transforming-dart-code)
+* [Debugging](#debugging)
+
+See the [contribution guidelines](https://github.com/angular/angular/blob/master/CONTRIBUTING.md)
+if you'd like to contribute to Angular.
+
+## Prerequisite Software
+
+Before you can build and test Angular, you must install and configure the
+following products on your development machine:
+
+* [Dart](https://www.dartlang.org) (version ` >=1.12.0 <2.0.0`), specifically the Dart-SDK and
+  Dartium (a version of [Chromium](http://www.chromium.org) with native support for Dart through
+  the Dart VM). One of the **simplest** ways to get both is to install the **Dart Editor bundle**,
+  which includes the editor, SDK and Dartium. See the [Dart tools](https://www.dartlang.org/tools)
+  download [page for instructions](https://www.dartlang.org/tools/download.html).  
+  You can also download both **stable** and **dev** channel versions from the [download
+  archive](https://www.dartlang.org/tools/download-archive). In that case, on Windows, Dart must be added
+  to the `Path` (e.g. `path-to-dart-sdk-folder\bin`) and a new `DARTIUM_BIN` environment variable must be
+  created, pointing to the executable (e.g. `path-to-dartium-folder\chrome.exe).`
+
+* [Git](http://git-scm.com) and/or the **GitHub app** (for [Mac](http://mac.github.com) or
+  [Windows](http://windows.github.com)); [GitHub's Guide to Installing
+  Git](https://help.github.com/articles/set-up-git) is a good source of information.
+
+* [Node.js](http://nodejs.org), (version `>=4.2.1 <5`) which is used to run a development web server,
+  run tests, and generate distributable files. We also use Node's Package Manager, `npm`
+  (version `>=2.14.7 <3.0`), which comes with Node. Depending on your system, you can install Node either from
+  source or as a pre-packaged bundle.
+
+* [Chrome Canary](https://www.google.com/chrome/browser/canary.html), a version of Chrome with
+  bleeding edge functionality, built especially for developers (and early adopters).
+
+* [Bower](http://bower.io/).
+
+
+## Getting the Sources
+
+Fork and clone the Angular repository:
+
+1. Login to your GitHub account or create one by following the instructions given
+   [here](https://github.com/signup/free).
+2. [Fork](http://help.github.com/forking) the [main Angular
+   repository](https://github.com/angular/angular).
+3. Clone your fork of the Angular repository and define an `upstream` remote pointing back to
+   the Angular repository that you forked in the first place.
+
+```shell
+# Clone your GitHub repository:
+git clone git@github.com:<github username>/angular.git
+
+# Go to the Angular directory:
+cd angular
+
+# Add the main Angular repository as an upstream remote to your repository:
+git remote add upstream https://github.com/angular/angular.git
+```
+
+## Environment Variable Setup
+
+Define the environment variables listed below. These are mainly needed for the testing. The
+notation shown here is for [`bash`](http://www.gnu.org/software/bash); adapt as appropriate for
+your favorite shell.
+
+Examples given below of possible values for initializing the environment variables assume **Mac OS
+X** and that you have installed the Dart Editor in the directory named by
+`DART_EDITOR_DIR=/Applications/dart`. This is only for illustrative purposes.
+
+```shell
+# DARTIUM_BIN: path to a Dartium browser executable; used by Karma to run Dart tests
+export DARTIUM_BIN="$DART_EDITOR_DIR/chromium/Chromium.app/Contents/MacOS/Chromium"
+```
+
+Add the Dart SDK `bin` directory to your path and/or define `DART_SDK` (this is also detailed
+[here](https://www.dartlang.org/tools/pub/installing.html)):
+
+```shell
+# DART_SDK: path to a Dart SDK directory
+export DART_SDK="$DART_EDITOR_DIR/dart-sdk"
+
+# Update PATH to include the Dart SDK bin directory
+PATH+=":$DART_SDK/bin"
+```
+
+And specify where the pubs dependencies are downloaded. By default, this directory is located under .pub_cache
+in your home directory (on Mac and Linux), or in AppData\Roaming\Pub\Cache (on Windows).
+
+```shell
+# PUB_CACHE: location of pub dependencies
+export PUB_CACHE="/Users/<user>/.pub-cache"
+```
+
+## Installing NPM Modules and Dart Packages
+
+Next, install the JavaScript modules and Dart packages needed to build and test Angular:
+
+```shell
+# Install Angular project dependencies (package.json)
+npm install
+```
+
+**Optional**: In this document, we make use of project local `npm` package scripts and binaries
+(stored under `./node_modules/.bin`) by prefixing these command invocations with `$(npm bin)`; in
+particular `gulp` and `protractor` commands. If you prefer, you can drop this path prefix by either:
+
+*Option 1*: globally installing these two packages as follows:
+
+* `npm install -g gulp` (you might need to prefix this command with `sudo`)
+* `npm install -g protractor` (you might need to prefix this command with `sudo`)
+
+Since global installs can become stale, and required versions can vary by project, we avoid their
+use in these instructions.
+
+*Option 2*: defining a bash alias like `alias nbin='PATH=$(npm bin):$PATH'` as detailed in this
+[Stackoverflow answer](http://stackoverflow.com/questions/9679932/how-to-use-package-installed-locally-in-node-modules/15157360#15157360) and used like this: e.g., `nbin gulp build`.
+
+## Build commands
+
+To build Angular and prepare tests, run:
+
+```shell
+$(npm bin)/gulp build
+```
+
+Notes:
+* Results are put in the `dist` folder.
+* This will also run `pub get` for the subfolders in `modules` and run `dartanalyzer` for
+  every file that matches `<module>/src/<module>.dart`, e.g. `di/src/di.dart`.
+
+You can selectively build either the JS or Dart versions as follows:
+
+* `$(npm bin)/gulp build.js`
+* `$(npm bin)/gulp build.dart`
+
+To clean out the `dist` folder, run:
+
+```shell
+$(npm bin)/gulp clean
+```
+
+## Running Tests Locally
+
+### Full test suite
+
+* `npm test`: full test suite for both JS and Dart versions of Angular. These are the same tests
+  that run on Travis.
+
+You can selectively run either the JS or Dart versions as follows:
+
+* `$(npm bin)/gulp test.all.js`
+* `$(npm bin)/gulp test.all.dart`
+
+### Unit tests
+
+You can run just the unit tests as follows:
+
+* `$(npm bin)/gulp test.unit.js`: JS tests in a browser; runs in **watch mode** (i.e.
+   watches the test files for changes and re-runs tests when files are updated).
+* `$(npm bin)/gulp test.unit.cjs`: JS tests in NodeJS; runs in **watch mode**.
+* `$(npm bin)/gulp test.unit.dart`: Dart tests in Dartium; runs in **watch mode**.
+
+If you prefer running tests in "single-run" mode rather than watch mode use:
+
+* `$(npm bin)/gulp test.unit.js/ci`
+* `$(npm bin)/gulp test.unit.cjs/ci`
+* `$(npm bin)/gulp test.unit.dart/ci`
+
+The task updates the dist folder with transpiled code whenever a source or test file changes, and
+Karma is run against the new output.
+
+**Note**: If you want to only run a single test you can alter the test you wish to run by changing
+`it` to `iit` or `describe` to `ddescribe`. This will only run that individual test and make it
+much easier to debug. `xit` and `xdescribe` can also be useful to exclude a test and a group of
+tests respectively.
+
+**Note**: **watch mode** needs symlinks to work, so if you're using windows, ensure you have the
+rights to built them in your operating system.
+
+### Unit tests with Sauce Labs or Browser Stack
+
+First, in a terminal, create a tunnel with [Sauce Connect](https://docs.saucelabs.com/reference/sauce-connect/) or [Browser Stack Local](https://www.browserstack.com/local-testing#command-line), and valid credentials.  
+
+Then, in another terminal:
+ - Define the credentials as environment variables, e.g.:
+```
+export SAUCE_USERNAME='my_user'; export SAUCE_ACCESS_KEY='my_key';
+export BROWSER_STACK_USERNAME='my_user'; export BROWSER_STACK_ACCESS_KEY='my_key';
+```
+ - Then run `gulp test.unit.js.(saucelabs|browserstack) --browsers=option1,option2,..,optionN`  
+The options are any mix of browsers and aliases which are defined in the [browser-providers.conf.js](https://github.com/angular/angular/blob/master/browser-providers.conf.js) file.  
+They are case insensitive, and the `SL_` or `BS_` prefix must not be added for browsers.
+
+Some examples of commands:
+```
+gulp test.unit.js.saucelabs --browsers=Safari8,ie11  //run in Sauce Labs with Safari 8 and IE11
+gulp test.unit.js.browserstack --browsers=Safari,IE  //run in Browser Stack with Safari 7, Safari 8, Safari 9, IE 9, IE 10 and IE 11
+gulp test.unit.js.saucelabs --browsers=IOS,safari8,android5.1  //run in Sauce Labs with iOS 7, iOS 8, iOs 9, Safari 8 and Android 5.1
+```
+
+### E2E tests
+
+1. `$(npm bin)/gulp build.js.cjs` (builds benchpress and tests into `dist/js/cjs` folder).
+2. `$(npm bin)/gulp serve.js.prod serve.dart` (runs a local webserver).
+3. `$(npm bin)/protractor protractor-js.conf.js`: JS e2e tests.
+4. `$(npm bin)/protractor protractor-dart2js.conf.js`: dart2js e2e tests.
+
+Angular specific command line options when running protractor:
+  - `$(npm bin)/protractor protractor-{js|dart2js}-conf.js --ng-help`
+
+### Performance tests
+
+1. `$(npm bin)/gulp build.js.cjs` (builds benchpress and tests into `dist/js/cjs` folder)
+2. `$(npm bin)/gulp serve.js.prod serve.dart` (runs a local webserver)
+3. `$(npm bin)/protractor protractor-js.conf.js --benchmark`: JS performance tests
+4. `$(npm bin)/protractor protractor-dart2js.conf.js --benchmark`: dart2js performance tests
+
+Angular specific command line options when running protractor (e.g. force gc, ...):
+`$(npm bin)/protractor protractor-{js|dart2js}-conf.js --ng-help`
+
+## Formatting with <a name="clang-format">clang-format</a>
+
+We use [clang-format](http://clang.llvm.org/docs/ClangFormat.html) to automatically enforce code
+style for our TypeScript code. This allows us to focus our code reviews more on the content, and
+less on style nit-picking. It also lets us encode our style guide in the `.clang-format` file in the
+repository, allowing many tools and editors to share our settings.
+
+To check the formatting of your code, run
+
+    gulp check-format
+
+Note that the continuous build on Travis runs `gulp enforce-format`. Unlike the `check-format` task,
+this will actually fail the build if files aren't formatted according to the style guide.
+
+Your life will be easier if you include the formatter in your standard workflow. Otherwise, you'll
+likely forget to check the formatting, and waste time waiting for a build on Travis that fails due
+to some whitespace difference.
+
+* Use `$(npm bin)/clang-format -i [file name]` to format a file (or multiple).
+* Use `gulp enforce-format` to check if your code is `clang-format` clean. This also gives
+  you a command line to format your code.
+* `clang-format` also includes a git hook, run `git clang-format` to format all files you
+  touched.
+* You can run this as a **git pre-commit hook** to automatically format your delta regions when you
+  commit a change. In the angular repo, run
+
+```
+    $ echo -e '#!/bin/sh\nexec git clang-format' > .git/hooks/pre-commit
+    $ chmod u+x !$
+```
+
+* **WebStorm** can run clang-format on the current file.
+  1. Under Preferences, open Tools > External Tools.
+  1. Plus icon to Create Tool
+  1. Fill in the form:
+    - Name: clang-format
+    - Description: Format
+    - Synchronize files after execution: checked
+    - Open console: not checked
+    - Show in: Editor menu
+    - Program: `$ProjectFileDir$/node_modules/.bin/clang-format`
+    - Parameters: `-i -style=file $FilePath$`
+    - Working directory: `$ProjectFileDir$`
+* `clang-format` integrations are also available for many popular editors (`vim`, `emacs`,
+  `Sublime Text`, etc.).
+
+## Generating the API documentation
+
+The following gulp task will generate the API docs in the `dist/angular.io/partials/api/angular2`:  
+
+```shell
+$(npm bin)/gulp docs/angular.io
+```
+
+You can serve the generated documentation to check how it would render on [angular.io](https://angular.io/):
+- check out the [angular.io repo](https://github.com/angular/angular.io) locally,
+- install dependencies as described in the [angular.io README](https://github.com/angular/angular.io/blob/master/README.md),
+- copy the generated documentation from your local angular repo at `angular/dist/angular.io/partials/api/angular2` to your local angular.io repo at `angular.io/public/docs/js/latest/api`,
+- run `harp compile` at the root of the angular.io repo to check the generated documentation for errors,
+- run `harp server` and open a browser at `http://localhost:9000/docs/js/latest/api/` to check the rendered documentation.
+
+## Project Information
+
+### Folder structure
+
+* `modules/*`: modules that will be loaded in the browser
+* `tools/*`: tools that are needed to build Angular
+* `dist/*`: build files are placed here.
+
+### File suffixes
+
+* `*.ts`: TypeScript files that get transpiled to Dart and EcmaScript 5/6
+* `*.dart`: Dart files that don't get transpiled
+
+## CI using Travis
+
+For instructions on setting up Continuous Integration using Travis, see the instructions given
+[here](https://github.com/angular/angular.dart/blob/master/travis.md).
+
+## Transforming Dart code
+
+See the [wiki](//github.com/angular/angular/wiki/Angular-2-Dart-Transformer).
+
+## Debugging
+
+### Debug the transpiler
+
+If you need to debug the transpiler:
+
+- add a `debugger;` statement in the transpiler code,
+- from the root folder, execute `node debug $(npm bin)/gulp build` to enter the node
+  debugger
+- press "c" to execute the program until you reach the `debugger;` statement,
+- you can then type "repl" to enter the REPL and inspect variables in the context.
+
+See the [Node.js manual](http://nodejs.org/api/debugger.html) for more information.
+
+Notes:
+- You can also execute `node $(npm bin)/karma start karma-dart.conf.js` depending on which
+  code you want to debug (the former will process the "modules" folder while the later processes
+  the transpiler specs).
+- You can also add `debugger;` statements in the specs (JavaScript). The execution will halt when
+  the developer tools are opened in the browser running Karma.
+
+### Debug the tests
+
+If you need to debug the tests:
+
+- add a `debugger;` statement to the test you want to debug (or the source code),
+- execute karma `$(npm bin)/gulp test.js`,
+- press the top right "DEBUG" button,
+- open the DevTools and press F5,
+- the execution halts at the `debugger;` statement
+
+**Note (WebStorm users)**:
+
+1. Create a Karma run config from WebStorm.
+2. Then in the "Run" menu, press "Debug 'karma-js.conf.js'", and WebStorm will stop in the generated
+   code on the `debugger;` statement.
+3. You can then step into the code and add watches.
+
+The `debugger;` statement is needed because WebStorm will stop in a transpiled file. Breakpoints in
+the original source files are not supported at the moment.
+
+#### wants to merge 7 commits into GistIcon:usernamealreadyis-patch-100000000 from angular:master

From 4ff506d772af771cf277456ea4332a9a53b9e178 Mon Sep 17 00:00:00 2001
From: usernamealreadyis <usernamealreadyis@users.noreply.github.com>
Date: Sun, 14 Feb 2016 20:22:52 +0700
Subject: [PATCH 11/12] .api

6.1.1 beforecopy event

If the implementation has user interface controls that users can use to initiate a copy operation, the user agent should determine what state such controls should be in by firing a beforecopy event before the control is shown to the user (i.e. in a menu). If the event is canceled, the control's state is set to enabled. If the event is not canceled, the implementation uses its built-in logic to set the control's state, for example by disabling any 'copy'-related UI controls if there is no selection. The event bubbles and is cancelable.

7.2 Processing model for event dispatch

To fire a clipboard event of type e,

Let clear-was-called be false
Let types-to-clear be an empty list
Let clipboard-entry be the sequence number of the current clipboard content, or null if the OS clipboard does not support sequence numbers
Let trusted be true if the event is generated by the user agent, false otherwise
Set target as follows:
If the context is editable:
Let target be the element that contains the start of the selection in document order, or the body element if there is no selection or cursor.
Else, if the context is not editable
Let target be the focused node, or the body element if no node has focus.
If e is paste
Set the associated DataTransfer object's drag data store mode flag to read-only

If trusted is true, or the implementation is configured to give script-generated events read access to the OS clipboard
For each part on the OS clipboard, carry out these steps:

If the current clipboard part contains plain text:
Ensure the text is in the encoding the scripting engine uses internally
Add one entry for the text to the DataTransferItemList with drag data item kind set to string and drag data item type string set to text/plain
If the current clipboard part represents file references:
Determine MIME type of referenced files
Add one entry per file reference to the DataTransferItemList with drag data item kind set to file and drag data item type string set to the corresponding MIME type, or application/octet-stream if the file's type is unknown.
If the current clipboard part contains HTML- or XHTML-formatted text, according to the operating system's convention for describing such clipboard formats
If the implementation supports pasting HTML, the implementation must process the markup according to the following steps:

Add one entry to the DataTransferItemList with drag data item kind set to Plain Unicode string, drag data item type string set to text/html or application/xhtml+xml accordingly. Let mainPartIndex be the index of this entry in the DataTransferItemList.
Extract the markup from the clipboard and use the relevant parser to construct a DOM tree
If the markup's source URL is known, resolve all relative URLs in HREF and SRC attributes using the source URL as base URL, and set the respective attributes to the resolved absolute URL
If the markup's origin is from a local application, check whether there are references to local files and/or other parts of the OS clipboard's contents. If such references are found, references to sub-parts must be replaced by content-id references using the cid: URL scheme [RFC2392]. To do so, process each attribute referencing a local file or clipboard part according to the following steps:
---
 clone/.api | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)
 create mode 100644 clone/.api

diff --git a/clone/.api b/clone/.api
new file mode 100644
index 0000000..0a204a2
--- /dev/null
+++ b/clone/.api
@@ -0,0 +1,19 @@
+// Appends <b>hello</b>:
+$( "<b>hello</b>" ).appendTo( "body" );
+ 
+// Appends <b>hello</b>:
+$( "<b>hello</b>bye" ).appendTo( "body" );
+ 
+// Syntax error, unrecognized expression: bye<b>hello</b>
+$( "bye<b>hello</b>" ).appendTo( "body" );
+ 
+// Appends bye<b>hello</b>:
+$( $.parseHTML( "bye<b>hello</b>" ) ).appendTo( "body" );
+ 
+// Appends <b>hello</b>wait<b>bye</b>:
+$( "<b>hello</b>wait<b>bye</b>" ).appendTo( "body" );
+document.addEventListener('beforecopy', function(e){
+    if(weHaveDataToCopy()){ // use your web app's internal logic to determine if something can be copied
+        e.preventDefault(); // enable copy UI and events
+    }
+});

From 231b4c04997ccf94600f333d67d2254f80a89fa3 Mon Sep 17 00:00:00 2001
From: AndisthermalFindLasthree
 <AndisthermalFindLasthree@users.noreply.github.com>
Date: Thu, 18 Feb 2016 08:08:09 +0700
Subject: [PATCH 12/12] Configure

#cipher:key:iv:plaintext:ciphertext:0/1(decrypt/encrypt)
#digest:::input:output

# SHA(1) tests (from shatest.c)
SHA1:::616263:a9993e364706816aba3e25717850c26c9cd0d89d

# MD5 tests (from md5test.c)
MD5::::d41d8cd98f00b204e9800998ecf8427e
MD5:::61:0cc175b9c0f1b6a831c399e269772661
MD5:::616263:900150983cd24fb0d6963f7d28e17f72
MD5:::6d65737361676520646967657374:f96b697d7cb7938d525a2f31aaf161d0
MD5:::6162636465666768696a6b6c6d6e6f707172737475767778797a:c3fcd3d76192e4007dfb496cca67e13b
MD5:::4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a30313233343536373839:d174ab98d277d9f5a5611c2c9f419d9f
MD5:::3132333435363738393031323334353637383930313233343536373839303132333435363738393031323334353637383930313233343536373839303132333435363738393031323334353637383930:57edf4a22be3c955ac49da2e2107b67a

# AES 128 ECB tests (from FIPS-197 test vectors, encrypt)

AES-128-ECB:000102030405060708090A0B0C0D0E0F::00112233445566778899AABBCCDDEEFF:69C4E0D86A7B0430D8CDB78070B4C55A:1

# AES 192 ECB tests (from FIPS-197 test vectors, encrypt)

AES-192-ECB:000102030405060708090A0B0C0D0E0F1011121314151617::00112233445566778899AABBCCDDEEFF:DDA97CA4864CDFE06EAF70A0EC0D7191:1

# AES 256 ECB tests (from FIPS-197 test vectors, encrypt)

AES-256-ECB:000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F::00112233445566778899AABBCCDDEEFF:8EA2B7CA516745BFEAFC49904B496089:1

# AES 128 ECB tests (from NIST test vectors, encrypt)

#AES-128-ECB:00000000000000000000000000000000::00000000000000000000000000000000:C34C052CC0DA8D73451AFE5F03BE297F:1

# AES 128 ECB tests (from NIST test vectors, decrypt)

#AES-128-ECB:00000000000000000000000000000000::44416AC2D1F53C583303917E6BE9EBE0:00000000000000000000000000000000:0

# AES 192 ECB tests (from NIST test vectors, decrypt)

#AES-192-ECB:000000000000000000000000000000000000000000000000::48E31E9E256718F29229319C19F15BA4:00000000000000000000000000000000:0

# AES 256 ECB tests (from NIST test vectors, decrypt)

#AES-256-ECB:0000000000000000000000000000000000000000000000000000000000000000::058CCFFDBBCB382D1F6F56585D8A4ADE:00000000000000000000000000000000:0

# AES 128 CBC tests (from NIST test vectors, encrypt)

#AES-128-CBC:00000000000000000000000000000000:00000000000000000000000000000000:00000000000000000000000000000000:8A05FC5E095AF4848A08D328D3688E3D:1

# AES 192 CBC tests (from NIST test vectors, encrypt)

#AES-192-CBC:000000000000000000000000000000000000000000000000:00000000000000000000000000000000:00000000000000000000000000000000:7BD966D53AD8C1BB85D2ADFAE87BB104:1

# AES 256 CBC tests (from NIST test vectors, encrypt)

#AES-256-CBC:0000000000000000000000000000000000000000000000000000000000000000:00000000000000000000000000000000:00000000000000000000000000000000:FE3C53653E2F45B56FCD88B2CC898FF0:1

# AES 128 CBC tests (from NIST test vectors, decrypt)

#AES-128-CBC:00000000000000000000000000000000:00000000000000000000000000000000:FACA37E0B0C85373DF706E73F7C9AF86:00000000000000000000000000000000:0

# AES tests from NIST document SP800-38A
# For all ECB encrypts and decrypts, the transformed sequence is
#   AES-bits-ECB:key::plaintext:ciphertext:encdec
# ECB-AES128.Encrypt and ECB-AES128.Decrypt
AES-128-ECB:2B7E151628AED2A6ABF7158809CF4F3C::6BC1BEE22E409F96E93D7E117393172A:3AD77BB40D7A3660A89ECAF32466EF97
AES-128-ECB:2B7E151628AED2A6ABF7158809CF4F3C::AE2D8A571E03AC9C9EB76FAC45AF8E51:F5D3D58503B9699DE785895A96FDBAAF
AES-128-ECB:2B7E151628AED2A6ABF7158809CF4F3C::30C81C46A35CE411E5FBC1191A0A52EF:43B1CD7F598ECE23881B00E3ED030688
AES-128-ECB:2B7E151628AED2A6ABF7158809CF4F3C::F69F2445DF4F9B17AD2B417BE66C3710:7B0C785E27E8AD3F8223207104725DD4
# ECB-AES192.Encrypt and ECB-AES192.Decrypt
AES-192-ECB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B::6BC1BEE22E409F96E93D7E117393172A:BD334F1D6E45F25FF712A214571FA5CC
AES-192-ECB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B::AE2D8A571E03AC9C9EB76FAC45AF8E51:974104846D0AD3AD7734ECB3ECEE4EEF
AES-192-ECB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B::30C81C46A35CE411E5FBC1191A0A52EF:EF7AFD2270E2E60ADCE0BA2FACE6444E
AES-192-ECB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B::F69F2445DF4F9B17AD2B417BE66C3710:9A4B41BA738D6C72FB16691603C18E0E
# ECB-AES256.Encrypt and ECB-AES256.Decrypt
AES-256-ECB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4::6BC1BEE22E409F96E93D7E117393172A:F3EED1BDB5D2A03C064B5A7E3DB181F8
AES-256-ECB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4::AE2D8A571E03AC9C9EB76FAC45AF8E51:591CCB10D410ED26DC5BA74A31362870
AES-256-ECB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4::30C81C46A35CE411E5FBC1191A0A52EF:B6ED21B99CA6F4F9F153E7B1BEAFED1D
AES-256-ECB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4::F69F2445DF4F9B17AD2B417BE66C3710:23304B7A39F9F3FF067D8D8F9E24ECC7
# For all CBC encrypts and decrypts, the transformed sequence is
#   AES-bits-CBC:key:IV/ciphertext':plaintext:ciphertext:encdec
# CBC-AES128.Encrypt and CBC-AES128.Decrypt
AES-128-CBC:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:7649ABAC8119B246CEE98E9B12E9197D
AES-128-CBC:2B7E151628AED2A6ABF7158809CF4F3C:7649ABAC8119B246CEE98E9B12E9197D:AE2D8A571E03AC9C9EB76FAC45AF8E51:5086CB9B507219EE95DB113A917678B2
AES-128-CBC:2B7E151628AED2A6ABF7158809CF4F3C:5086CB9B507219EE95DB113A917678B2:30C81C46A35CE411E5FBC1191A0A52EF:73BED6B8E3C1743B7116E69E22229516
AES-128-CBC:2B7E151628AED2A6ABF7158809CF4F3C:73BED6B8E3C1743B7116E69E22229516:F69F2445DF4F9B17AD2B417BE66C3710:3FF1CAA1681FAC09120ECA307586E1A7
# CBC-AES192.Encrypt and CBC-AES192.Decrypt
AES-192-CBC:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:4F021DB243BC633D7178183A9FA071E8
AES-192-CBC:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:4F021DB243BC633D7178183A9FA071E8:AE2D8A571E03AC9C9EB76FAC45AF8E51:B4D9ADA9AD7DEDF4E5E738763F69145A
AES-192-CBC:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:B4D9ADA9AD7DEDF4E5E738763F69145A:30C81C46A35CE411E5FBC1191A0A52EF:571B242012FB7AE07FA9BAAC3DF102E0
AES-192-CBC:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:571B242012FB7AE07FA9BAAC3DF102E0:F69F2445DF4F9B17AD2B417BE66C3710:08B0E27988598881D920A9E64F5615CD
# CBC-AES256.Encrypt and CBC-AES256.Decrypt
AES-256-CBC:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:F58C4C04D6E5F1BA779EABFB5F7BFBD6
AES-256-CBC:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:F58C4C04D6E5F1BA779EABFB5F7BFBD6:AE2D8A571E03AC9C9EB76FAC45AF8E51:9CFC4E967EDB808D679F777BC6702C7D
AES-256-CBC:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:9CFC4E967EDB808D679F777BC6702C7D:30C81C46A35CE411E5FBC1191A0A52EF:39F23369A9D9BACFA530E26304231461
AES-256-CBC:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:39F23369A9D9BACFA530E26304231461:F69F2445DF4F9B17AD2B417BE66C3710:B2EB05E2C39BE9FCDA6C19078C6A9D1B
# We don't support CFB{1,8}-AESxxx.{En,De}crypt
# For all CFB128 encrypts and decrypts, the transformed sequence is
#   AES-bits-CFB:key:IV/ciphertext':plaintext:ciphertext:encdec
# CFB128-AES128.Encrypt
AES-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:3B3FD92EB72DAD20333449F8E83CFB4A:1
AES-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:3B3FD92EB72DAD20333449F8E83CFB4A:AE2D8A571E03AC9C9EB76FAC45AF8E51:C8A64537A0B3A93FCDE3CDAD9F1CE58B:1
AES-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:C8A64537A0B3A93FCDE3CDAD9F1CE58B:30C81C46A35CE411E5FBC1191A0A52EF:26751F67A3CBB140B1808CF187A4F4DF:1
AES-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:26751F67A3CBB140B1808CF187A4F4DF:F69F2445DF4F9B17AD2B417BE66C3710:C04B05357C5D1C0EEAC4C66F9FF7F2E6:1
# CFB128-AES128.Decrypt
AES-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:3B3FD92EB72DAD20333449F8E83CFB4A:0
AES-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:3B3FD92EB72DAD20333449F8E83CFB4A:AE2D8A571E03AC9C9EB76FAC45AF8E51:C8A64537A0B3A93FCDE3CDAD9F1CE58B:0
AES-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:C8A64537A0B3A93FCDE3CDAD9F1CE58B:30C81C46A35CE411E5FBC1191A0A52EF:26751F67A3CBB140B1808CF187A4F4DF:0
AES-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:26751F67A3CBB140B1808CF187A4F4DF:F69F2445DF4F9B17AD2B417BE66C3710:C04B05357C5D1C0EEAC4C66F9FF7F2E6:0
# CFB128-AES192.Encrypt
AES-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:CDC80D6FDDF18CAB34C25909C99A4174:1
AES-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:CDC80D6FDDF18CAB34C25909C99A4174:AE2D8A571E03AC9C9EB76FAC45AF8E51:67CE7F7F81173621961A2B70171D3D7A:1
AES-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:67CE7F7F81173621961A2B70171D3D7A:30C81C46A35CE411E5FBC1191A0A52EF:2E1E8A1DD59B88B1C8E60FED1EFAC4C9:1
AES-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:2E1E8A1DD59B88B1C8E60FED1EFAC4C9:F69F2445DF4F9B17AD2B417BE66C3710:C05F9F9CA9834FA042AE8FBA584B09FF:1
# CFB128-AES192.Decrypt
AES-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:CDC80D6FDDF18CAB34C25909C99A4174:0
AES-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:CDC80D6FDDF18CAB34C25909C99A4174:AE2D8A571E03AC9C9EB76FAC45AF8E51:67CE7F7F81173621961A2B70171D3D7A:0
AES-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:67CE7F7F81173621961A2B70171D3D7A:30C81C46A35CE411E5FBC1191A0A52EF:2E1E8A1DD59B88B1C8E60FED1EFAC4C9:0
AES-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:2E1E8A1DD59B88B1C8E60FED1EFAC4C9:F69F2445DF4F9B17AD2B417BE66C3710:C05F9F9CA9834FA042AE8FBA584B09FF:0
# CFB128-AES256.Encrypt
AES-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:DC7E84BFDA79164B7ECD8486985D3860:1
AES-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:DC7E84BFDA79164B7ECD8486985D3860:AE2D8A571E03AC9C9EB76FAC45AF8E51:39FFED143B28B1C832113C6331E5407B:1
AES-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:39FFED143B28B1C832113C6331E5407B:30C81C46A35CE411E5FBC1191A0A52EF:DF10132415E54B92A13ED0A8267AE2F9:1
AES-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:DF10132415E54B92A13ED0A8267AE2F9:F69F2445DF4F9B17AD2B417BE66C3710:75A385741AB9CEF82031623D55B1E471:1
# CFB128-AES256.Decrypt
AES-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:DC7E84BFDA79164B7ECD8486985D3860:0
AES-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:DC7E84BFDA79164B7ECD8486985D3860:AE2D8A571E03AC9C9EB76FAC45AF8E51:39FFED143B28B1C832113C6331E5407B:0
AES-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:39FFED143B28B1C832113C6331E5407B:30C81C46A35CE411E5FBC1191A0A52EF:DF10132415E54B92A13ED0A8267AE2F9:0
AES-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:DF10132415E54B92A13ED0A8267AE2F9:F69F2445DF4F9B17AD2B417BE66C3710:75A385741AB9CEF82031623D55B1E471:0
# For all OFB encrypts and decrypts, the transformed sequence is
#   AES-bits-CFB:key:IV/output':plaintext:ciphertext:encdec
# OFB-AES128.Encrypt
AES-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:3B3FD92EB72DAD20333449F8E83CFB4A:1
AES-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:50FE67CC996D32B6DA0937E99BAFEC60:AE2D8A571E03AC9C9EB76FAC45AF8E51:7789508D16918F03F53C52DAC54ED825:1
AES-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:D9A4DADA0892239F6B8B3D7680E15674:30C81C46A35CE411E5FBC1191A0A52EF:9740051E9C5FECF64344F7A82260EDCC:1
AES-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:A78819583F0308E7A6BF36B1386ABF23:F69F2445DF4F9B17AD2B417BE66C3710:304C6528F659C77866A510D9C1D6AE5E:1
# OFB-AES128.Decrypt
AES-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:3B3FD92EB72DAD20333449F8E83CFB4A:0
AES-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:50FE67CC996D32B6DA0937E99BAFEC60:AE2D8A571E03AC9C9EB76FAC45AF8E51:7789508D16918F03F53C52DAC54ED825:0
AES-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:D9A4DADA0892239F6B8B3D7680E15674:30C81C46A35CE411E5FBC1191A0A52EF:9740051E9C5FECF64344F7A82260EDCC:0
AES-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:A78819583F0308E7A6BF36B1386ABF23:F69F2445DF4F9B17AD2B417BE66C3710:304C6528F659C77866A510D9C1D6AE5E:0
# OFB-AES192.Encrypt
AES-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:CDC80D6FDDF18CAB34C25909C99A4174:1
AES-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:A609B38DF3B1133DDDFF2718BA09565E:AE2D8A571E03AC9C9EB76FAC45AF8E51:FCC28B8D4C63837C09E81700C1100401:1
AES-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:52EF01DA52602FE0975F78AC84BF8A50:30C81C46A35CE411E5FBC1191A0A52EF:8D9A9AEAC0F6596F559C6D4DAF59A5F2:1
AES-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:BD5286AC63AABD7EB067AC54B553F71D:F69F2445DF4F9B17AD2B417BE66C3710:6D9F200857CA6C3E9CAC524BD9ACC92A:1
# OFB-AES192.Decrypt
AES-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:CDC80D6FDDF18CAB34C25909C99A4174:0
AES-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:A609B38DF3B1133DDDFF2718BA09565E:AE2D8A571E03AC9C9EB76FAC45AF8E51:FCC28B8D4C63837C09E81700C1100401:0
AES-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:52EF01DA52602FE0975F78AC84BF8A50:30C81C46A35CE411E5FBC1191A0A52EF:8D9A9AEAC0F6596F559C6D4DAF59A5F2:0
AES-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:BD5286AC63AABD7EB067AC54B553F71D:F69F2445DF4F9B17AD2B417BE66C3710:6D9F200857CA6C3E9CAC524BD9ACC92A:0
# OFB-AES256.Encrypt
AES-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:DC7E84BFDA79164B7ECD8486985D3860:1
AES-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:B7BF3A5DF43989DD97F0FA97EBCE2F4A:AE2D8A571E03AC9C9EB76FAC45AF8E51:4FEBDC6740D20B3AC88F6AD82A4FB08D:1
AES-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:E1C656305ED1A7A6563805746FE03EDC:30C81C46A35CE411E5FBC1191A0A52EF:71AB47A086E86EEDF39D1C5BBA97C408:1
AES-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:41635BE625B48AFC1666DD42A09D96E7:F69F2445DF4F9B17AD2B417BE66C3710:0126141D67F37BE8538F5A8BE740E484:1
# OFB-AES256.Decrypt
AES-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:DC7E84BFDA79164B7ECD8486985D3860:0
AES-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:B7BF3A5DF43989DD97F0FA97EBCE2F4A:AE2D8A571E03AC9C9EB76FAC45AF8E51:4FEBDC6740D20B3AC88F6AD82A4FB08D:0
AES-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:E1C656305ED1A7A6563805746FE03EDC:30C81C46A35CE411E5FBC1191A0A52EF:71AB47A086E86EEDF39D1C5BBA97C408:0
AES-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:41635BE625B48AFC1666DD42A09D96E7:F69F2445DF4F9B17AD2B417BE66C3710:0126141D67F37BE8538F5A8BE740E484:0

# DES ECB tests (from destest)

DES-ECB:0000000000000000::0000000000000000:8CA64DE9C1B123A7
DES-ECB:FFFFFFFFFFFFFFFF::FFFFFFFFFFFFFFFF:7359B2163E4EDC58
DES-ECB:3000000000000000::1000000000000001:958E6E627A05557B
DES-ECB:1111111111111111::1111111111111111:F40379AB9E0EC533
DES-ECB:0123456789ABCDEF::1111111111111111:17668DFC7292532D
DES-ECB:1111111111111111::0123456789ABCDEF:8A5AE1F81AB8F2DD
DES-ECB:FEDCBA9876543210::0123456789ABCDEF:ED39D950FA74BCC4

# DESX-CBC tests (from destest)
DESX-CBC:0123456789abcdeff1e0d3c2b5a49786fedcba9876543210:fedcba9876543210:37363534333231204E6F77206973207468652074696D6520666F722000000000:846B2914851E9A2954732F8AA0A611C115CDC2D7951B1053A63C5E03B21AA3C4

# DES EDE3 CBC tests (from destest)
DES-EDE3-CBC:0123456789abcdeff1e0d3c2b5a49786fedcba9876543210:fedcba9876543210:37363534333231204E6F77206973207468652074696D6520666F722000000000:3FE301C962AC01D02213763C1CBD4CDC799657C064ECF5D41C673812CFDE9675

# RC4 tests (from rc4test)
RC4:0123456789abcdef0123456789abcdef::0123456789abcdef:75b7878099e0c596
RC4:0123456789abcdef0123456789abcdef::0000000000000000:7494c2e7104b0879
RC4:00000000000000000000000000000000::0000000000000000:de188941a3375d3a
RC4:ef012345ef012345ef012345ef012345::0000000000000000000000000000000000000000:d6a141a7ec3c38dfbd615a1162e1c7ba36b67858
RC4:0123456789abcdef0123456789abcdef::123456789ABCDEF0123456789ABCDEF0123456789ABCDEF012345678:66a0949f8af7d6891f7f832ba833c00c892ebe30143ce28740011ecf
RC4:ef012345ef012345ef012345ef012345::00000000000000000000:d6a141a7ec3c38dfbd61


# Camellia tests from RFC3713
# For all ECB encrypts and decrypts, the transformed sequence is
#   CAMELLIA-bits-ECB:key::plaintext:ciphertext:encdec
CAMELLIA-128-ECB:0123456789abcdeffedcba9876543210::0123456789abcdeffedcba9876543210:67673138549669730857065648eabe43
CAMELLIA-192-ECB:0123456789abcdeffedcba98765432100011223344556677::0123456789abcdeffedcba9876543210:b4993401b3e996f84ee5cee7d79b09b9
CAMELLIA-256-ECB:0123456789abcdeffedcba987654321000112233445566778899aabbccddeeff::0123456789abcdeffedcba9876543210:9acc237dff16d76c20ef7c919e3a7509

# ECB-CAMELLIA128.Encrypt
CAMELLIA-128-ECB:000102030405060708090A0B0C0D0E0F::00112233445566778899AABBCCDDEEFF:77CF412067AF8270613529149919546F:1
CAMELLIA-192-ECB:000102030405060708090A0B0C0D0E0F1011121314151617::00112233445566778899AABBCCDDEEFF:B22F3C36B72D31329EEE8ADDC2906C68:1
CAMELLIA-256-ECB:000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F::00112233445566778899AABBCCDDEEFF:2EDF1F3418D53B88841FC8985FB1ECF2:1

# ECB-CAMELLIA128.Encrypt and ECB-CAMELLIA128.Decrypt
CAMELLIA-128-ECB:2B7E151628AED2A6ABF7158809CF4F3C::6BC1BEE22E409F96E93D7E117393172A:432FC5DCD628115B7C388D770B270C96
CAMELLIA-128-ECB:2B7E151628AED2A6ABF7158809CF4F3C::AE2D8A571E03AC9C9EB76FAC45AF8E51:0BE1F14023782A22E8384C5ABB7FAB2B
CAMELLIA-128-ECB:2B7E151628AED2A6ABF7158809CF4F3C::30C81C46A35CE411E5FBC1191A0A52EF:A0A1ABCD1893AB6FE0FE5B65DF5F8636
CAMELLIA-128-ECB:2B7E151628AED2A6ABF7158809CF4F3C::F69F2445DF4F9B17AD2B417BE66C3710:E61925E0D5DFAA9BB29F815B3076E51A

# ECB-CAMELLIA192.Encrypt and ECB-CAMELLIA192.Decrypt
CAMELLIA-192-ECB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B::6BC1BEE22E409F96E93D7E117393172A:CCCC6C4E138B45848514D48D0D3439D3
CAMELLIA-192-ECB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B::AE2D8A571E03AC9C9EB76FAC45AF8E51:5713C62C14B2EC0F8393B6AFD6F5785A
CAMELLIA-192-ECB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B::30C81C46A35CE411E5FBC1191A0A52EF:B40ED2B60EB54D09D030CF511FEEF366
CAMELLIA-192-ECB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B::F69F2445DF4F9B17AD2B417BE66C3710:909DBD95799096748CB27357E73E1D26

# ECB-CAMELLIA256.Encrypt and ECB-CAMELLIA256.Decrypt
CAMELLIA-256-ECB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4::6BC1BEE22E409F96E93D7E117393172A:BEFD219B112FA00098919CD101C9CCFA
CAMELLIA-256-ECB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4::AE2D8A571E03AC9C9EB76FAC45AF8E51:C91D3A8F1AEA08A9386CF4B66C0169EA
CAMELLIA-256-ECB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4::30C81C46A35CE411E5FBC1191A0A52EF:A623D711DC5F25A51BB8A80D56397D28
CAMELLIA-256-ECB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4::F69F2445DF4F9B17AD2B417BE66C3710:7960109FB6DC42947FCFE59EA3C5EB6B

# For all CBC encrypts and decrypts, the transformed sequence is
#   CAMELLIA-bits-CBC:key:IV/ciphertext':plaintext:ciphertext:encdec
# CBC-CAMELLIA128.Encrypt and CBC-CAMELLIA128.Decrypt
CAMELLIA-128-CBC:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:1607CF494B36BBF00DAEB0B503C831AB
CAMELLIA-128-CBC:2B7E151628AED2A6ABF7158809CF4F3C:1607CF494B36BBF00DAEB0B503C831AB:AE2D8A571E03AC9C9EB76FAC45AF8E51:A2F2CF671629EF7840C5A5DFB5074887
CAMELLIA-128-CBC:2B7E151628AED2A6ABF7158809CF4F3C:A2F2CF671629EF7840C5A5DFB5074887:30C81C46A35CE411E5FBC1191A0A52EF:0F06165008CF8B8B5A63586362543E54
CAMELLIA-128-CBC:2B7E151628AED2A6ABF7158809CF4F3C:36A84CDAFD5F9A85ADA0F0A993D6D577:F69F2445DF4F9B17AD2B417BE66C3710:74C64268CDB8B8FAF5B34E8AF3732980

# CBC-CAMELLIA192.Encrypt and CBC-CAMELLIA192.Decrypt
CAMELLIA-192-CBC:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:2A4830AB5AC4A1A2405955FD2195CF93
CAMELLIA-192-CBC:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:2A4830AB5AC4A1A2405955FD2195CF93:AE2D8A571E03AC9C9EB76FAC45AF8E51:5D5A869BD14CE54264F892A6DD2EC3D5
CAMELLIA-192-CBC:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:5D5A869BD14CE54264F892A6DD2EC3D5:30C81C46A35CE411E5FBC1191A0A52EF:37D359C3349836D884E310ADDF68C449
CAMELLIA-192-CBC:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:37D359C3349836D884E310ADDF68C449:F69F2445DF4F9B17AD2B417BE66C3710:01FAAA930B4AB9916E9668E1428C6B08

# CBC-CAMELLIA256.Encrypt and CBC-CAMELLIA256.Decrypt
CAMELLIA-256-CBC:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:E6CFA35FC02B134A4D2C0B6737AC3EDA
CAMELLIA-256-CBC:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:E6CFA35FC02B134A4D2C0B6737AC3EDA:AE2D8A571E03AC9C9EB76FAC45AF8E51:36CBEB73BD504B4070B1B7DE2B21EB50
CAMELLIA-256-CBC:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:36CBEB73BD504B4070B1B7DE2B21EB50:30C81C46A35CE411E5FBC1191A0A52EF:E31A6055297D96CA3330CDF1B1860A83
CAMELLIA-256-CBC:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:E31A6055297D96CA3330CDF1B1860A83:F69F2445DF4F9B17AD2B417BE66C3710:5D563F6D1CCCF236051C0C5C1C58F28F

# We don't support CFB{1,8}-CAMELLIAxxx.{En,De}crypt
# For all CFB128 encrypts and decrypts, the transformed sequence is
#   CAMELLIA-bits-CFB:key:IV/ciphertext':plaintext:ciphertext:encdec
# CFB128-CAMELLIA128.Encrypt
CAMELLIA-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:14F7646187817EB586599146B82BD719:1
CAMELLIA-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:14F7646187817EB586599146B82BD719:AE2D8A571E03AC9C9EB76FAC45AF8E51:A53D28BB82DF741103EA4F921A44880B:1
CAMELLIA-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:A53D28BB82DF741103EA4F921A44880B:30C81C46A35CE411E5FBC1191A0A52EF:9C2157A664626D1DEF9EA420FDE69B96:1
CAMELLIA-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:9C2157A664626D1DEF9EA420FDE69B96:F69F2445DF4F9B17AD2B417BE66C3710:742A25F0542340C7BAEF24CA8482BB09:1

# CFB128-CAMELLIA128.Decrypt
CAMELLIA-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:14F7646187817EB586599146B82BD719:0
CAMELLIA-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:14F7646187817EB586599146B82BD719:AE2D8A571E03AC9C9EB76FAC45AF8E51:A53D28BB82DF741103EA4F921A44880B:0
CAMELLIA-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:A53D28BB82DF741103EA4F921A44880B:30C81C46A35CE411E5FBC1191A0A52EF:9C2157A664626D1DEF9EA420FDE69B96:0
CAMELLIA-128-CFB:2B7E151628AED2A6ABF7158809CF4F3C:9C2157A664626D1DEF9EA420FDE69B96:F69F2445DF4F9B17AD2B417BE66C3710:742A25F0542340C7BAEF24CA8482BB09:0

# CFB128-CAMELLIA192.Encrypt
CAMELLIA-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:C832BB9780677DAA82D9B6860DCD565E:1
CAMELLIA-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:C832BB9780677DAA82D9B6860DCD565E:AE2D8A571E03AC9C9EB76FAC45AF8E51:86F8491627906D780C7A6D46EA331F98:1
CAMELLIA-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:86F8491627906D780C7A6D46EA331F98:30C81C46A35CE411E5FBC1191A0A52EF:69511CCE594CF710CB98BB63D7221F01:1
CAMELLIA-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:69511CCE594CF710CB98BB63D7221F01:F69F2445DF4F9B17AD2B417BE66C3710:D5B5378A3ABED55803F25565D8907B84:1

# CFB128-CAMELLIA192.Decrypt
CAMELLIA-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:C832BB9780677DAA82D9B6860DCD565E:0
CAMELLIA-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:C832BB9780677DAA82D9B6860DCD565E:AE2D8A571E03AC9C9EB76FAC45AF8E51:86F8491627906D780C7A6D46EA331F98:0
CAMELLIA-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:86F8491627906D780C7A6D46EA331F98:30C81C46A35CE411E5FBC1191A0A52EF:69511CCE594CF710CB98BB63D7221F01:0
CAMELLIA-192-CFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:69511CCE594CF710CB98BB63D7221F01:F69F2445DF4F9B17AD2B417BE66C3710:D5B5378A3ABED55803F25565D8907B84:0

# CFB128-CAMELLIA256.Encrypt
CAMELLIA-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:CF6107BB0CEA7D7FB1BD31F5E7B06C93:1
CAMELLIA-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:CF6107BB0CEA7D7FB1BD31F5E7B06C93:AE2D8A571E03AC9C9EB76FAC45AF8E51:89BEDB4CCDD864EA11BA4CBE849B5E2B:1
CAMELLIA-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:89BEDB4CCDD864EA11BA4CBE849B5E2B:30C81C46A35CE411E5FBC1191A0A52EF:555FC3F34BDD2D54C62D9E3BF338C1C4:1
CAMELLIA-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:555FC3F34BDD2D54C62D9E3BF338C1C4:F69F2445DF4F9B17AD2B417BE66C3710:5953ADCE14DB8C7F39F1BD39F359BFFA:1

# CFB128-CAMELLIA256.Decrypt
CAMELLIA-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:CF6107BB0CEA7D7FB1BD31F5E7B06C93:0
CAMELLIA-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:CF6107BB0CEA7D7FB1BD31F5E7B06C93:AE2D8A571E03AC9C9EB76FAC45AF8E51:89BEDB4CCDD864EA11BA4CBE849B5E2B:0
CAMELLIA-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:89BEDB4CCDD864EA11BA4CBE849B5E2B:30C81C46A35CE411E5FBC1191A0A52EF:555FC3F34BDD2D54C62D9E3BF338C1C4:0
CAMELLIA-256-CFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:555FC3F34BDD2D54C62D9E3BF338C1C4:F69F2445DF4F9B17AD2B417BE66C3710:5953ADCE14DB8C7F39F1BD39F359BFFA:0

# For all OFB encrypts and decrypts, the transformed sequence is
#   CAMELLIA-bits-OFB:key:IV/output':plaintext:ciphertext:encdec
# OFB-CAMELLIA128.Encrypt
CAMELLIA-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:14F7646187817EB586599146B82BD719:1
CAMELLIA-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:50FE67CC996D32B6DA0937E99BAFEC60:AE2D8A571E03AC9C9EB76FAC45AF8E51:25623DB569CA51E01482649977E28D84:1
CAMELLIA-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:D9A4DADA0892239F6B8B3D7680E15674:30C81C46A35CE411E5FBC1191A0A52EF:C776634A60729DC657D12B9FCA801E98:1
CAMELLIA-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:A78819583F0308E7A6BF36B1386ABF23:F69F2445DF4F9B17AD2B417BE66C3710:D776379BE0E50825E681DA1A4C980E8E:1

# OFB-CAMELLIA128.Decrypt
CAMELLIA-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:14F7646187817EB586599146B82BD719:0
CAMELLIA-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:50FE67CC996D32B6DA0937E99BAFEC60:AE2D8A571E03AC9C9EB76FAC45AF8E51:25623DB569CA51E01482649977E28D84:0
CAMELLIA-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:D9A4DADA0892239F6B8B3D7680E15674:30C81C46A35CE411E5FBC1191A0A52EF:C776634A60729DC657D12B9FCA801E98:0
CAMELLIA-128-OFB:2B7E151628AED2A6ABF7158809CF4F3C:A78819583F0308E7A6BF36B1386ABF23:F69F2445DF4F9B17AD2B417BE66C3710:D776379BE0E50825E681DA1A4C980E8E:0

# OFB-CAMELLIA192.Encrypt
CAMELLIA-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:C832BB9780677DAA82D9B6860DCD565E:1
CAMELLIA-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:A609B38DF3B1133DDDFF2718BA09565E:AE2D8A571E03AC9C9EB76FAC45AF8E51:8ECEB7D0350D72C7F78562AEBDF99339:1
CAMELLIA-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:52EF01DA52602FE0975F78AC84BF8A50:30C81C46A35CE411E5FBC1191A0A52EF:BDD62DBBB9700846C53B507F544696F0:1
CAMELLIA-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:BD5286AC63AABD7EB067AC54B553F71D:F69F2445DF4F9B17AD2B417BE66C3710:E28014E046B802F385C4C2E13EAD4A72:1

# OFB-CAMELLIA192.Decrypt
CAMELLIA-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:C832BB9780677DAA82D9B6860DCD565E:0
CAMELLIA-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:A609B38DF3B1133DDDFF2718BA09565E:AE2D8A571E03AC9C9EB76FAC45AF8E51:8ECEB7D0350D72C7F78562AEBDF99339:0
CAMELLIA-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:52EF01DA52602FE0975F78AC84BF8A50:30C81C46A35CE411E5FBC1191A0A52EF:BDD62DBBB9700846C53B507F544696F0:0
CAMELLIA-192-OFB:8E73B0F7DA0E6452C810F32B809079E562F8EAD2522C6B7B:BD5286AC63AABD7EB067AC54B553F71D:F69F2445DF4F9B17AD2B417BE66C3710:E28014E046B802F385C4C2E13EAD4A72:0

# OFB-CAMELLIA256.Encrypt
CAMELLIA-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:CF6107BB0CEA7D7FB1BD31F5E7B06C93:1
CAMELLIA-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:B7BF3A5DF43989DD97F0FA97EBCE2F4A:AE2D8A571E03AC9C9EB76FAC45AF8E51:127AD97E8E3994E4820027D7BA109368:1
CAMELLIA-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:E1C656305ED1A7A6563805746FE03EDC:30C81C46A35CE411E5FBC1191A0A52EF:6BFF6265A6A6B7A535BC65A80B17214E:1
CAMELLIA-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:41635BE625B48AFC1666DD42A09D96E7:F69F2445DF4F9B17AD2B417BE66C3710:0A4A0404E26AA78A27CB271E8BF3CF20:1

# OFB-CAMELLIA256.Decrypt
CAMELLIA-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:000102030405060708090A0B0C0D0E0F:6BC1BEE22E409F96E93D7E117393172A:CF6107BB0CEA7D7FB1BD31F5E7B06C93:0
CAMELLIA-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:B7BF3A5DF43989DD97F0FA97EBCE2F4A:AE2D8A571E03AC9C9EB76FAC45AF8E51:127AD97E8E3994E4820027D7BA109368:0
CAMELLIA-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:E1C656305ED1A7A6563805746FE03EDC:30C81C46A35CE411E5FBC1191A0A52EF:6BFF6265A6A6B7A535BC65A80B17214E:0
CAMELLIA-256-OFB:603DEB1015CA71BE2B73AEF0857D77811F352C073B6108D72D9810A30914DFF4:41635BE625B48AFC1666DD42A09D96E7:F69F2445DF4F9B17AD2B417BE66C3710:0A4A0404E26AA78A27CB271E8BF3CF20:0

# SEED test vectors from RFC4269
SEED-ECB:00000000000000000000000000000000::000102030405060708090A0B0C0D0E0F:5EBAC6E0054E166819AFF1CC6D346CDB:0
SEED-ECB:000102030405060708090A0B0C0D0E0F::00000000000000000000000000000000:C11F22F20140505084483597E4370F43:0
SEED-ECB:4706480851E61BE85D74BFB3FD956185::83A2F8A288641FB9A4E9A5CC2F131C7D:EE54D13EBCAE706D226BC3142CD40D4A:0
SEED-ECB:28DBC3BC49FFD87DCFA509B11D422BE7::B41E6BE2EBA84A148E2EED84593C5EC7:9B9B7BFCD1813CB95D0B3618F40F5122:0
SEED-ECB:00000000000000000000000000000000::000102030405060708090A0B0C0D0E0F:5EBAC6E0054E166819AFF1CC6D346CDB:1
SEED-ECB:000102030405060708090A0B0C0D0E0F::00000000000000000000000000000000:C11F22F20140505084483597E4370F43:1
SEED-ECB:4706480851E61BE85D74BFB3FD956185::83A2F8A288641FB9A4E9A5CC2F131C7D:EE54D13EBCAE706D226BC3142CD40D4A:1
SEED-ECB:28DBC3BC49FFD87DCFA509B11D422BE7::B41E6BE2EBA84A148E2EED84593C5EC7:9B9B7BFCD1813CB95D0B3618F40F5122:1
---
 modules/Configure | 1888 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 1888 insertions(+)
 create mode 100644 modules/Configure

diff --git a/modules/Configure b/modules/Configure
new file mode 100644
index 0000000..6f5fae3
--- /dev/null
+++ b/modules/Configure
@@ -0,0 +1,1888 @@
+:
+eval 'exec perl -S $0 ${1+"$@"}'
+    if $running_under_some_shell;
+##
+##  Configure -- OpenSSL source tree configuration script
+##
+
+require 5.000;
+use strict;
+
+# see INSTALL for instructions.
+
+my $usage="Usage: Configure [no-<cipher> ...] [enable-<cipher> ...] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [no-hw-xxx|no-hw] [[no-]threads] [[no-]shared] [[no-]zlib|zlib-dynamic] [enable-montasm] [no-asm] [no-dso] [no-krb5] [386] [--prefix=DIR] [--openssldir=OPENSSLDIR] [--with-xxx[=vvv]] [--test-sanity] os/compiler[:flags]\n";
+
+# Options:
+#
+# --openssldir  install OpenSSL in OPENSSLDIR (Default: DIR/ssl if the
+#               --prefix option is given; /usr/local/ssl otherwise)
+# --prefix      prefix for the OpenSSL include, lib and bin directories
+#               (Default: the OPENSSLDIR directory)
+#
+# --install_prefix  Additional prefix for package builders (empty by
+#               default).  This needn't be set in advance, you can
+#               just as well use "make INSTALL_PREFIX=/whatever install".
+#
+# --with-krb5-dir  Declare where Kerberos 5 lives.  The libraries are expected
+#		to live in the subdirectory lib/ and the header files in
+#		include/.  A value is required.
+# --with-krb5-lib  Declare where the Kerberos 5 libraries live.  A value is
+#		required.
+#		(Default: KRB5_DIR/lib)
+# --with-krb5-include  Declare where the Kerberos 5 header files live.  A
+#		value is required.
+#		(Default: KRB5_DIR/include)
+# --with-krb5-flavor  Declare what flavor of Kerberos 5 is used.  Currently
+#		supported values are "MIT" and "Heimdal".  A value is required.
+#
+# --test-sanity Make a number of sanity checks on the data in this file.
+#               This is a debugging tool for OpenSSL developers.
+#
+# no-hw-xxx     do not compile support for specific crypto hardware.
+#               Generic OpenSSL-style methods relating to this support
+#               are always compiled but return NULL if the hardware
+#               support isn't compiled.
+# no-hw         do not compile support for any crypto hardware.
+# [no-]threads  [don't] try to create a library that is suitable for
+#               multithreaded applications (default is "threads" if we
+#               know how to do it)
+# [no-]shared	[don't] try to create shared libraries when supported.
+# no-asm        do not use assembler
+# no-dso        do not compile in any native shared-library methods. This
+#               will ensure that all methods just return NULL.
+# no-krb5       do not compile in any KRB5 library or code.
+# [no-]zlib     [don't] compile support for zlib compression.
+# zlib-dynamic	Like "zlib", but the zlib library is expected to be a shared
+#		library and will be loaded in run-time by the OpenSSL library.
+# enable-montasm 0.9.8 branch only: enable Montgomery x86 assembler backport
+#               from 0.9.9
+# 386           generate 80386 code
+# no-sse2	disables IA-32 SSE2 code, above option implies no-sse2
+# no-<cipher>   build without specified algorithm (rsa, idea, rc5, ...)
+# -<xxx> +<xxx> compiler options are passed through 
+#
+# DEBUG_SAFESTACK use type-safe stacks to enforce type-safety on stack items
+#		provided to stack calls. Generates unique stack functions for
+#		each possible stack type.
+# DES_PTR	use pointer lookup vs arrays in the DES in crypto/des/des_locl.h
+# DES_RISC1	use different DES_ENCRYPT macro that helps reduce register
+#		dependancies but needs to more registers, good for RISC CPU's
+# DES_RISC2	A different RISC variant.
+# DES_UNROLL	unroll the inner DES loop, sometimes helps, somtimes hinders.
+# DES_INT	use 'int' instead of 'long' for DES_LONG in crypto/des/des.h
+#		This is used on the DEC Alpha where long is 8 bytes
+#		and int is 4
+# BN_LLONG	use the type 'long long' in crypto/bn/bn.h
+# MD2_CHAR	use 'char' instead of 'int' for MD2_INT in crypto/md2/md2.h
+# MD2_LONG	use 'long' instead of 'int' for MD2_INT in crypto/md2/md2.h
+# IDEA_SHORT	use 'short' instead of 'int' for IDEA_INT in crypto/idea/idea.h
+# IDEA_LONG	use 'long' instead of 'int' for IDEA_INT in crypto/idea/idea.h
+# RC2_SHORT	use 'short' instead of 'int' for RC2_INT in crypto/rc2/rc2.h
+# RC2_LONG	use 'long' instead of 'int' for RC2_INT in crypto/rc2/rc2.h
+# RC4_CHAR	use 'char' instead of 'int' for RC4_INT in crypto/rc4/rc4.h
+# RC4_LONG	use 'long' instead of 'int' for RC4_INT in crypto/rc4/rc4.h
+# RC4_INDEX	define RC4_INDEX in crypto/rc4/rc4_locl.h.  This turns on
+#		array lookups instead of pointer use.
+# RC4_CHUNK	enables code that handles data aligned at long (natural CPU
+#		word) boundary.
+# RC4_CHUNK_LL	enables code that handles data aligned at long long boundary
+#		(intended for 64-bit CPUs running 32-bit OS).
+# BF_PTR	use 'pointer arithmatic' for Blowfish (unsafe on Alpha).
+# BF_PTR2	intel specific version (generic version is more efficient).
+#
+# Following are set automatically by this script
+#
+# MD5_ASM	use some extra md5 assember,
+# SHA1_ASM	use some extra sha1 assember, must define L_ENDIAN for x86
+# RMD160_ASM	use some extra ripemd160 assember,
+# SHA256_ASM	sha256_block is implemented in assembler
+# SHA512_ASM	sha512_block is implemented in assembler
+# AES_ASM	ASE_[en|de]crypt is implemented in assembler
+
+my $x86_gcc_des="DES_PTR DES_RISC1 DES_UNROLL";
+
+# MD2_CHAR slags pentium pros
+my $x86_gcc_opts="RC4_INDEX MD2_INT";
+
+# MODIFY THESE PARAMETERS IF YOU ARE GOING TO USE THE 'util/speed.sh SCRIPT
+# Don't worry about these normally
+
+my $tcc="cc";
+my $tflags="-fast -Xa";
+my $tbn_mul="";
+my $tlib="-lnsl -lsocket";
+#$bits1="SIXTEEN_BIT ";
+#$bits2="THIRTY_TWO_BIT ";
+my $bits1="THIRTY_TWO_BIT ";
+my $bits2="SIXTY_FOUR_BIT ";
+
+my $x86_elf_asm="x86cpuid-elf.o:bn86-elf.o co86-elf.o MAYBE-MO86-elf.o:dx86-elf.o yx86-elf.o:ax86-elf.o:bx86-elf.o:mx86-elf.o:sx86-elf.o s512sse2-elf.o:cx86-elf.o:rx86-elf.o rc4_skey.o:rm86-elf.o:r586-elf.o";
+my $x86_coff_asm="x86cpuid-cof.o:bn86-cof.o co86-cof.o MAYBE-MO86-cof.o:dx86-cof.o yx86-cof.o:ax86-cof.o:bx86-cof.o:mx86-cof.o:sx86-cof.o s512sse2-cof.o:cx86-cof.o:rx86-cof.o rc4_skey.o:rm86-cof.o:r586-cof.o";
+my $x86_out_asm="x86cpuid-out.o:bn86-out.o co86-out.o MAYBE-MO86-out.o:dx86-out.o yx86-out.o:ax86-out.o:bx86-out.o:mx86-out.o:sx86-out.o s512sse2-out.o:cx86-out.o:rx86-out.o rc4_skey.o:rm86-out.o:r586-out.o";
+
+my $x86_64_asm="x86_64cpuid.o:x86_64-gcc.o x86_64-mont.o::aes-x86_64.o::md5-x86_64.o:sha1-x86_64.o sha256-x86_64.o sha512-x86_64.o::rc4-x86_64.o::";
+my $ia64_asm=":bn-ia64.o::aes_core.o aes_cbc.o aes-ia64.o:::sha1-ia64.o sha256-ia64.o sha512-ia64.o::rc4-ia64.o rc4_skey.o::";
+
+my $no_asm="::::::::::";
+
+# As for $BSDthreads. Idea is to maintain "collective" set of flags,
+# which would cover all BSD flavors. -pthread applies to them all, 
+# but is treated differently. OpenBSD expands is as -D_POSIX_THREAD
+# -lc_r, which is sufficient. FreeBSD 4.x expands it as -lc_r,
+# which has to be accompanied by explicit -D_THREAD_SAFE and
+# sometimes -D_REENTRANT. FreeBSD 5.x expands it as -lc_r, which
+# seems to be sufficient?
+my $BSDthreads="-pthread -D_THREAD_SAFE -D_REENTRANT";
+
+#config-string	$cc : $cflags : $unistd : $thread_cflag : $sys_id : $lflags : $bn_ops : $cpuid_obj : $bn_obj : $des_obj : $aes_obj : $bf_obj : $md5_obj : $sha1_obj : $cast_obj : $rc4_obj : $rmd160_obj : $rc5_obj : $dso_scheme : $shared_target : $shared_cflag : $shared_ldflag : $shared_extension : $ranlib : $arflags
+
+my %table=(
+# File 'TABLE' (created by 'make TABLE') contains the data from this list,
+# formatted for better readability.
+
+
+#"b",		"${tcc}:${tflags}::${tlib}:${bits1}:${tbn_mul}::",
+#"bl-4c-2c",	"${tcc}:${tflags}::${tlib}:${bits1}BN_LLONG RC4_CHAR MD2_CHAR:${tbn_mul}::",
+#"bl-4c-ri",	"${tcc}:${tflags}::${tlib}:${bits1}BN_LLONG RC4_CHAR RC4_INDEX:${tbn_mul}::",
+#"b2-is-ri-dp",	"${tcc}:${tflags}::${tlib}:${bits2}IDEA_SHORT RC4_INDEX DES_PTR:${tbn_mul}::",
+
+# Our development configs
+"purify",	"purify gcc:-g -DPURIFY -Wall::(unknown)::-lsocket -lnsl::::",
+"debug",	"gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DOPENSSL_NO_ASM -ggdb -g2 -Wformat -Wshadow -Wmissing-prototypes -Wmissing-declarations -Werror::(unknown)::-lefence::::",
+"debug-ben",	"gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DPEDANTIC -DDEBUG_SAFESTACK -O2 -pedantic -Wall -Wshadow -Werror -pipe::(unknown):::::bn86-elf.o co86-elf.o",
+"debug-ben-openbsd","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DPEDANTIC -DDEBUG_SAFESTACK -DOPENSSL_OPENBSD_DEV_CRYPTO -DOPENSSL_NO_ASM -O2 -pedantic -Wall -Wshadow -Werror -pipe::(unknown)::::",
+"debug-ben-openbsd-debug","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DPEDANTIC -DDEBUG_SAFESTACK -DOPENSSL_OPENBSD_DEV_CRYPTO -DOPENSSL_NO_ASM -g3 -O2 -pedantic -Wall -Wshadow -Werror -pipe::(unknown)::::",
+"debug-ben-debug",	"gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DPEDANTIC -DDEBUG_SAFESTACK -g3 -O2 -pedantic -Wall -Wshadow -Werror -pipe::(unknown)::::::",
+"debug-ben-strict",	"gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DCONST_STRICT -O2 -Wall -Wshadow -Werror -Wpointer-arith -Wcast-qual -Wwrite-strings -pipe::(unknown)::::::",
+"debug-rse","cc:-DTERMIOS -DL_ENDIAN -pipe -O -g -ggdb3 -Wall::(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}",
+"debug-bodo",	"gcc:-DL_ENDIAN -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBIO_PAIR_DEBUG -DPEDANTIC -g -march=i486 -pedantic -Wshadow -Wall::-D_REENTRANT:::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}",
+"debug-ulf", "gcc:-DTERMIOS -DL_ENDIAN -march=i486 -Wall -DBN_DEBUG -DBN_DEBUG_RAND -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DOPENSSL_NO_ASM -g -Wformat -Wshadow -Wmissing-prototypes -Wmissing-declarations:::CYGWIN32:::${no_asm}:win32:cygwin-shared:::.dll",
+"debug-steve64", "gcc:-m64 -DL_ENDIAN -DTERMIO -DREF_CHECK -DCONF_DEBUG -DDEBUG_SAFESTACK -DCRYPTO_MDEBUG_ALL -DPEDANTIC -DOPENSSL_NO_DEPRECATED -g -pedantic -Wall -Werror -Wno-long-long -DMD32_REG_T=int::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK BF_PTR2 DES_INT DES_UNROLL:${x86_64_asm}:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-steve32", "gcc:-m32 -DL_ENDIAN -DREF_CHECK -DCONF_DEBUG -DDEBUG_SAFESTACK -DCRYPTO_MDEBUG_ALL -DPEDANTIC -DOPENSSL_NO_DEPRECATED -g -pedantic -Wno-long-long -Wall -Werror -Wshadow -pipe::-D_REENTRANT::-rdynamic -ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC:-m32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-steve",	"gcc:-DL_ENDIAN -DREF_CHECK -DCONF_DEBUG -DDEBUG_SAFESTACK -DCRYPTO_MDEBUG_ALL -DPEDANTIC -m32 -g -pedantic -Wno-long-long -Wall -Werror -Wshadow -pipe::-D_REENTRANT::-rdynamic -ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared",
+"debug-steve-opt",	"gcc:-DL_ENDIAN -DREF_CHECK -DCONF_DEBUG -DDEBUG_SAFESTACK -DCRYPTO_MDEBUG_ALL -DPEDANTIC -m32 -O3 -g -pedantic -Wno-long-long -Wall -Werror -Wshadow -pipe::-D_REENTRANT::-rdynamic -ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared",
+"debug-steve-linux-pseudo64",	"gcc:-DL_ENDIAN -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DDEBUG_SAFESTACK -DCRYPTO_MDEBUG_ALL -DOPENSSL_NO_ASM -g -mcpu=i486 -Wall -Werror -Wshadow -pipe::-D_REENTRANT::-rdynamic -ldl:SIXTY_FOUR_BIT:${no_asm}:dlfcn:linux-shared",
+"debug-levitte-linux-elf","gcc:-DLEVITTE_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_DEBUG -DBN_DEBUG_RAND -DCRYPTO_MDEBUG -DENGINE_CONF_DEBUG -DL_ENDIAN -DTERMIO -D_POSIX_SOURCE -DPEDANTIC -ggdb -g3 -mcpu=i486 -pedantic -ansi -Wall -Wshadow -Wcast-align -Wstrict-prototypes -Wmissing-prototypes -Wno-long-long -Wundef -Wconversion -pipe::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-levitte-linux-noasm","gcc:-DLEVITTE_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_DEBUG -DBN_DEBUG_RAND -DCRYPTO_MDEBUG -DENGINE_CONF_DEBUG -DOPENSSL_NO_ASM -DL_ENDIAN -DTERMIO -D_POSIX_SOURCE -DPEDANTIC -ggdb -g3 -mcpu=i486 -pedantic -ansi -Wall -Wshadow -Wcast-align -Wstrict-prototypes -Wmissing-prototypes -Wno-long-long -Wundef -Wconversion -pipe::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-levitte-linux-elf-extreme","gcc:-DLEVITTE_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_DEBUG -DBN_DEBUG_RAND -DCRYPTO_MDEBUG -DENGINE_CONF_DEBUG -DL_ENDIAN -DTERMIO -D_POSIX_SOURCE -DPEDANTIC -ggdb -g3 -mcpu=i486 -pedantic -ansi -Wall -W -Wundef -Wshadow -Wcast-align -Wstrict-prototypes -Wmissing-prototypes -Wno-long-long -Wundef -Wconversion -pipe::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-levitte-linux-noasm-extreme","gcc:-DLEVITTE_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_DEBUG -DBN_DEBUG_RAND -DCRYPTO_MDEBUG -DENGINE_CONF_DEBUG -DOPENSSL_NO_ASM -DL_ENDIAN -DTERMIO -D_POSIX_SOURCE -DPEDANTIC -ggdb -g3 -mcpu=i486 -pedantic -ansi -Wall -W -Wundef -Wshadow -Wcast-align -Wstrict-prototypes -Wmissing-prototypes -Wno-long-long -Wundef -Wconversion -pipe::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-geoff","gcc:-DBN_DEBUG -DBN_DEBUG_RAND -DBN_STRICT -DPURIFY -DOPENSSL_NO_DEPRECATED -DOPENSSL_NO_ASM -DOPENSSL_NO_INLINE_ASM -DL_ENDIAN -DTERMIO -DPEDANTIC -O1 -ggdb2 -Wall -Werror -Wundef -pedantic -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-align -Wsign-compare -Wmissing-prototypes -Wmissing-declarations -Wno-long-long::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-linux-pentium","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DL_ENDIAN -DTERMIO -g -mcpu=pentium -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn",
+"debug-linux-ppro","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DL_ENDIAN -DTERMIO -g -mcpu=pentiumpro -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn",
+"debug-linux-elf","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DL_ENDIAN -DTERMIO -g -march=i486 -Wall::-D_REENTRANT::-lefence -ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-linux-elf-noefence","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DL_ENDIAN -DTERMIO -g -march=i486 -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"dist",		"cc:-O::(unknown)::::::",
+
+# Basic configs that should work on any (32 and less bit) box
+"gcc",		"gcc:-O3::(unknown):::BN_LLONG:::",
+"cc",		"cc:-O::(unknown)::::::",
+
+####VOS Configurations
+"vos-gcc","gcc:-O3 -Wall -D_POSIX_C_SOURCE=200112L -D_BSD -DB_ENDIAN::(unknown):VOS:-Wl,-map:BN_LLONG:${no_asm}:::::.so:",
+"debug-vos-gcc","gcc:-O0 -g -Wall -D_POSIX_C_SOURCE=200112L -D_BSD -DB_ENDIAN -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG::(unknown):VOS:-Wl,-map:BN_LLONG:${no_asm}:::::.so:",
+
+#### Solaris x86 with GNU C setups
+# -DOPENSSL_NO_INLINE_ASM switches off inline assembler. We have to do it
+# here because whenever GNU C instantiates an assembler template it
+# surrounds it with #APP #NO_APP comment pair which (at least Solaris
+# 7_x86) /usr/ccs/bin/as fails to assemble with "Illegal mnemonic"
+# error message.
+"solaris-x86-gcc","gcc:-O3 -fomit-frame-pointer -march=pentium -Wall -DL_ENDIAN -DOPENSSL_NO_INLINE_ASM::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# -shared -static-libgcc might appear controversial, but modules taken
+# from static libgcc do not have relocations and linking them into our
+# shared objects doesn't have any negative side-effects. On the contrary,
+# doing so makes it possible to use gcc shared build with Sun C. Given
+# that gcc generates faster code [thanks to inline assembler], I would
+# actually recommend to consider using gcc shared build even with vendor
+# compiler:-)
+#						<appro@fy.chalmers.se>
+"solaris64-x86_64-gcc","gcc:-m64 -O3 -Wall -DL_ENDIAN -DMD32_REG_T=int::-D_REENTRANT::-lsocket -lnsl -ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK BF_PTR2 DES_INT DES_UNROLL:${x86_64_asm}:dlfcn:solaris-shared:-fPIC:-m64 -shared -static-libgcc:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+ 
+#### Solaris x86 with Sun C setups
+"solaris-x86-cc","cc:-fast -O -Xa::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_UNROLL BF_PTR:${no_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris64-x86_64-cc","cc:-fast -xarch=amd64 -xstrconst -Xa -DL_ENDIAN::-D_REENTRANT::-lsocket -lnsl -ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK BF_PTR2 DES_INT DES_UNROLL:${x86_64_asm}:dlfcn:solaris-shared:-KPIC:-xarch=amd64 -G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#### SPARC Solaris with GNU C setups
+"solaris-sparcv7-gcc","gcc:-O3 -fomit-frame-pointer -Wall -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${no_asm}:dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris-sparcv8-gcc","gcc:-mv8 -O3 -fomit-frame-pointer -Wall -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR::sparcv8.o:des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# -m32 should be safe to add as long as driver recognizes -mcpu=ultrasparc
+"solaris-sparcv9-gcc","gcc:-m32 -mcpu=ultrasparc -O3 -fomit-frame-pointer -Wall -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR::sparcv8plus.o:des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris64-sparcv9-gcc","gcc:-m64 -mcpu=ultrasparc -O3 -Wall -DB_ENDIAN::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL BF_PTR:::des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:solaris-shared:-fPIC:-m64 -shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+####
+"debug-solaris-sparcv8-gcc","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG_ALL -O -g -mv8 -Wall -DB_ENDIAN::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR::sparcv8.o::::::::::dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-solaris-sparcv9-gcc","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG_ALL -DPEDANTIC -O -g -mcpu=ultrasparc -pedantic -ansi -Wall -Wshadow -Wno-long-long -D__EXTENSIONS__ -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR::sparcv8plus.o:des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#### SPARC Solaris with Sun C setups
+# SC4.0 doesn't pass 'make test', upgrade to SC5.0 or SC4.2.
+# SC4.2 is ok, better than gcc even on bn as long as you tell it -xarch=v8
+# SC5.0 note: Compiler common patch 107357-01 or later is required!
+"solaris-sparcv7-cc","cc:-xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${no_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris-sparcv8-cc","cc:-xarch=v8 -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR::sparcv8.o:des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris-sparcv9-cc","cc:-xtarget=ultra -xarch=v8plus -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK_LL DES_PTR DES_RISC1 DES_UNROLL BF_PTR::sparcv8plus.o:des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris64-sparcv9-cc","cc:-xtarget=ultra -xarch=v9 -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL BF_PTR:::des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:solaris-shared:-KPIC:-xarch=v9 -G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):/usr/ccs/bin/ar rs",
+####
+"debug-solaris-sparcv8-cc","cc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG_ALL -xarch=v8 -g -O -xstrconst -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR::sparcv8.o::::::::::dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-solaris-sparcv9-cc","cc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG_ALL -xtarget=ultra -xarch=v8plus -g -O -xstrconst -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK_LL DES_PTR DES_RISC1 DES_UNROLL BF_PTR::sparcv8plus.o::::::::::dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)", 
+
+#### SunOS configs, assuming sparc for the gcc one.
+#"sunos-cc", "cc:-O4 -DNOPROTO -DNOCONST::(unknown):SUNOS::DES_UNROLL:${no_asm}::",
+"sunos-gcc","gcc:-O3 -mv8 -Dssize_t=int::(unknown):SUNOS::BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL DES_PTR DES_RISC1:${no_asm}::",
+
+#### IRIX 5.x configs
+# -mips2 flag is added by ./config when appropriate.
+"irix-gcc","gcc:-O3 -DTERMIOS -DB_ENDIAN::(unknown):::BN_LLONG MD2_CHAR RC4_INDEX RC4_CHAR RC4_CHUNK DES_UNROLL DES_RISC2 DES_PTR BF_PTR:${no_asm}:dlfcn:irix-shared:::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"irix-cc", "cc:-O2 -use_readonly_const -DTERMIOS -DB_ENDIAN::(unknown):::BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC2 DES_UNROLL BF_PTR:${no_asm}:dlfcn:irix-shared:::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+#### IRIX 6.x configs
+# Only N32 and N64 ABIs are supported. If you need O32 ABI build, invoke
+# './Configure irix-cc -o32' manually.
+"irix-mips3-gcc","gcc:-mabi=n32 -O3 -DTERMIOS -DB_ENDIAN -DBN_DIV3W::-D_SGI_MP_SOURCE:::MD2_CHAR RC4_INDEX RC4_CHAR RC4_CHUNK_LL DES_UNROLL DES_RISC2 DES_PTR BF_PTR SIXTY_FOUR_BIT::bn-mips3.o::::::::::dlfcn:irix-shared::-mabi=n32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"irix-mips3-cc", "cc:-n32 -mips3 -O2 -use_readonly_const -G0 -rdata_shared -DTERMIOS -DB_ENDIAN -DBN_DIV3W::-D_SGI_MP_SOURCE:::DES_PTR RC4_CHAR RC4_CHUNK_LL DES_RISC2 DES_UNROLL BF_PTR SIXTY_FOUR_BIT::bn-mips3.o::::::::::dlfcn:irix-shared::-n32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# N64 ABI builds.
+"irix64-mips4-gcc","gcc:-mabi=64 -mips4 -O3 -DTERMIOS -DB_ENDIAN -DBN_DIV3W::-D_SGI_MP_SOURCE:::RC4_CHAR RC4_CHUNK DES_RISC2 DES_UNROLL SIXTY_FOUR_BIT_LONG::bn-mips3.o::::::::::dlfcn:irix-shared::-mabi=64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"irix64-mips4-cc", "cc:-64 -mips4 -O2 -use_readonly_const -G0 -rdata_shared -DTERMIOS -DB_ENDIAN -DBN_DIV3W::-D_SGI_MP_SOURCE:::RC4_CHAR RC4_CHUNK DES_RISC2 DES_UNROLL SIXTY_FOUR_BIT_LONG::bn-mips3.o::::::::::dlfcn:irix-shared::-64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#### Unified HP-UX ANSI C configs.
+# Special notes:
+# - Originally we were optimizing at +O4 level. It should be noted
+#   that the only difference between +O3 and +O4 is global inter-
+#   procedural analysis. As it has to be performed during the link
+#   stage the compiler leaves behind certain pseudo-code in lib*.a
+#   which might be release or even patch level specific. Generating
+#   the machine code for and analyzing the *whole* program appears
+#   to be *extremely* memory demanding while the performance gain is
+#   actually questionable. The situation is intensified by the default
+#   HP-UX data set size limit (infamous 'maxdsiz' tunable) of 64MB
+#   which is way too low for +O4. In other words, doesn't +O3 make
+#   more sense?
+# - Keep in mind that the HP compiler by default generates code
+#   suitable for execution on the host you're currently compiling at.
+#   If the toolkit is ment to be used on various PA-RISC processors
+#   consider './config +DAportable'.
+# - +DD64 is chosen in favour of +DA2.0W because it's meant to be
+#   compatible with *future* releases.
+# - If you run ./Configure hpux-parisc-[g]cc manually don't forget to
+#   pass -D_REENTRANT on HP-UX 10 and later.
+# - -DMD32_XARRAY triggers workaround for compiler bug we ran into in
+#   32-bit message digests. (For the moment of this writing) HP C
+#   doesn't seem to "digest" too many local variables (they make "him"
+#   chew forever:-). For more details look-up MD32_XARRAY comment in
+#   crypto/sha/sha_lcl.h.
+#					<appro@fy.chalmers.se>
+#
+# Since there is mention of this in shlib/hpux10-cc.sh
+"hpux-parisc-cc-o4","cc:-Ae +O4 +ESlit -z -DB_ENDIAN -DBN_DIV2W -DMD32_XARRAY::-D_REENTRANT::-ldld:BN_LLONG DES_PTR DES_UNROLL DES_RISC1:${no_asm}:dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux-parisc-gcc","gcc:-O3 -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-Wl,+s -ldld:BN_LLONG DES_PTR DES_UNROLL DES_RISC1:${no_asm}:dl:hpux-shared:-fPIC:-shared:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux-parisc2-gcc","gcc:-march=2.0 -O3 -DB_ENDIAN -D_REENTRANT::::-Wl,+s -ldld:SIXTY_FOUR_BIT RC4_CHAR RC4_CHUNK DES_PTR DES_UNROLL DES_RISC1::pa-risc2.o::::::::::dl:hpux-shared:-fPIC:-shared:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux64-parisc2-gcc","gcc:-O3 -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT_LONG MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT::pa-risc2W.o::::::::::dlfcn:hpux-shared:-fpic:-shared:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+# More attempts at unified 10.X and 11.X targets for HP C compiler.
+#
+# Chris Ruemmler <ruemmler@cup.hp.com>
+# Kevin Steves <ks@hp.se>
+"hpux-parisc-cc","cc:+O3 +Optrs_strongly_typed -Ae +ESlit -DB_ENDIAN -DBN_DIV2W -DMD32_XARRAY::-D_REENTRANT::-Wl,+s -ldld:MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT:${no_asm}:dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux-parisc1_0-cc","cc:+DAportable +O3 +Optrs_strongly_typed -Ae +ESlit -DB_ENDIAN -DMD32_XARRAY::-D_REENTRANT::-Wl,+s -ldld:MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT:${no_asm}:dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux-parisc2-cc","cc:+DA2.0 +DS2.0 +O3 +Optrs_strongly_typed -Ae +ESlit -DB_ENDIAN -DMD32_XARRAY -D_REENTRANT::::-Wl,+s -ldld:SIXTY_FOUR_BIT MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT::pa-risc2.o::::::::::dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux64-parisc2-cc","cc:+DD64 +O3 +Optrs_strongly_typed -Ae +ESlit -DB_ENDIAN -DMD32_XARRAY -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT_LONG MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT::pa-risc2W.o::::::::::dlfcn:hpux-shared:+Z:+DD64 -b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+# HP/UX IA-64 targets
+"hpux-ia64-cc","cc:-Ae +DD32 +O2 +Olit=all -z -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT MD2_CHAR RC4_INDEX DES_UNROLL DES_RISC1 DES_INT:${ia64_asm}:dlfcn:hpux-shared:+Z:+DD32 -b:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# Frank Geurts <frank.geurts@nl.abnamro.com> has patiently assisted with
+# with debugging of the following config.
+"hpux64-ia64-cc","cc:-Ae +DD64 +O3 +Olit=all -z -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT_LONG MD2_CHAR RC4_INDEX DES_UNROLL DES_RISC1 DES_INT:${ia64_asm}:dlfcn:hpux-shared:+Z:+DD64 -b:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# GCC builds...
+"hpux-ia64-gcc","gcc:-O3 -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT MD2_CHAR RC4_INDEX DES_UNROLL DES_RISC1 DES_INT:${ia64_asm}:dlfcn:hpux-shared:-fpic:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux64-ia64-gcc","gcc:-mlp64 -O3 -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT_LONG MD2_CHAR RC4_INDEX DES_UNROLL DES_RISC1 DES_INT:${ia64_asm}:dlfcn:hpux-shared:-fpic:-mlp64 -shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)", 
+
+# Legacy HPUX 9.X configs...
+"hpux-cc",	"cc:-DB_ENDIAN -DBN_DIV2W -DMD32_XARRAY -Ae +ESlit +O2 -z::(unknown)::-Wl,+s -ldld:DES_PTR DES_UNROLL DES_RISC1:${no_asm}:dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux-gcc",	"gcc:-DB_ENDIAN -DBN_DIV2W -O3::(unknown)::-Wl,+s -ldld:DES_PTR DES_UNROLL DES_RISC1:${no_asm}:dl:hpux-shared:-fPIC:-shared:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#### HP MPE/iX http://jazz.external.hp.com/src/openssl/
+"MPE/iX-gcc",	"gcc:-D_ENDIAN -DBN_DIV2W -O3 -D_POSIX_SOURCE -D_SOCKET_SOURCE -I/SYSLOG/PUB::(unknown):MPE:-L/SYSLOG/PUB -lsyslog -lsocket -lcurses:BN_LLONG DES_PTR DES_UNROLL DES_RISC1:::",
+
+# DEC Alpha OSF/1/Tru64 targets.
+#
+#	"What's in a name? That which we call a rose
+#	 By any other word would smell as sweet."
+#
+# - William Shakespeare, "Romeo & Juliet", Act II, scene II.
+#
+# For gcc, the following gave a %50 speedup on a 164 over the 'DES_INT' version
+#
+"osf1-alpha-gcc", "gcc:-O3::(unknown):::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_UNROLL DES_RISC1:${no_asm}:dlfcn:alpha-osf1-shared:::.so",
+"osf1-alpha-cc",  "cc:-std1 -tune host -O4 -readonly_strings::(unknown):::SIXTY_FOUR_BIT_LONG RC4_CHUNK:${no_asm}:dlfcn:alpha-osf1-shared:::.so",
+"tru64-alpha-cc", "cc:-std1 -tune host -fast -readonly_strings::-pthread:::SIXTY_FOUR_BIT_LONG RC4_CHUNK:${no_asm}:dlfcn:alpha-osf1-shared::-msym:.so",
+
+####
+#### Variety of LINUX:-)
+####
+# *-generic* is endian-neutral target, but ./config is free to
+# throw in -D[BL]_ENDIAN, whichever appropriate...
+"linux-generic32","gcc:-DTERMIO -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-ppc",	"gcc:-DB_ENDIAN -DTERMIO -O3 -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL::linux_ppc32.o::::::::::dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+#### IA-32 targets...
+"linux-ia32-icc",	"icc:-DL_ENDIAN -DTERMIO -O2 -no_cpprt::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-KPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-elf",	"gcc:-DL_ENDIAN -DTERMIO -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-aout",	"gcc:-DL_ENDIAN -DTERMIO -O3 -fomit-frame-pointer -march=i486 -Wall::(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_out_asm}",
+####
+"linux-generic64","gcc:-DTERMIO -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-ppc64",	"gcc:-m64 -DB_ENDIAN -DTERMIO -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL::linux_ppc64.o::::::::::dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-ia64",	"gcc:-DL_ENDIAN -DTERMIO -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK:${ia64_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-ia64-ecc","ecc:-DL_ENDIAN -DTERMIO -O2 -Wall -no_cpprt::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK:${ia64_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-ia64-icc","icc:-DL_ENDIAN -DTERMIO -O2 -Wall -no_cpprt::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK:${ia64_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-x86_64",	"gcc:-m64 -DL_ENDIAN -DTERMIO -O3 -Wall -DMD32_REG_T=int::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK BF_PTR2 DES_INT DES_UNROLL:${x86_64_asm}:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+#### SPARC Linux setups
+# Ray Miller <ray.miller@computing-services.oxford.ac.uk> has patiently
+# assisted with debugging of following two configs.
+"linux-sparcv8","gcc:-mv8 -DB_ENDIAN -DTERMIO -O3 -fomit-frame-pointer -Wall -DBN_DIV2W::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR::sparcv8.o:des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# it's a real mess with -mcpu=ultrasparc option under Linux, but
+# -Wa,-Av8plus should do the trick no matter what.
+"linux-sparcv9","gcc:-m32 -mcpu=ultrasparc -DB_ENDIAN -DTERMIO -O3 -fomit-frame-pointer -Wall -Wa,-Av8plus -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR::sparcv8plus.o:des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:linux-shared:-fPIC:-m32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# GCC 3.1 is a requirement
+"linux64-sparcv9","gcc:-m64 -mcpu=ultrasparc -DB_ENDIAN -DTERMIO -O3 -fomit-frame-pointer -Wall::-D_REENTRANT:ULTRASPARC:-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR::::::::::::dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+#### Alpha Linux with GNU C and Compaq C setups
+# Special notes:
+# - linux-alpha+bwx-gcc is ment to be used from ./config only. If you
+#   ought to run './Configure linux-alpha+bwx-gcc' manually, do
+#   complement the command line with -mcpu=ev56, -mcpu=ev6 or whatever
+#   which is appropriate.
+# - If you use ccc keep in mind that -fast implies -arch host and the
+#   compiler is free to issue instructions which gonna make elder CPU
+#   choke. If you wish to build "blended" toolkit, add -arch generic
+#   *after* -fast and invoke './Configure linux-alpha-ccc' manually.
+#
+#					<appro@fy.chalmers.se>
+#
+"linux-alpha-gcc","gcc:-O3 -DL_ENDIAN -DTERMIO::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_RISC1 DES_UNROLL:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-alpha+bwx-gcc","gcc:-O3 -DL_ENDIAN -DTERMIO::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-alpha-ccc","ccc:-fast -readonly_strings -DL_ENDIAN -DTERMIO::-D_REENTRANT:::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL:${no_asm}",
+"linux-alpha+bwx-ccc","ccc:-fast -readonly_strings -DL_ENDIAN -DTERMIO::-D_REENTRANT:::SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL:${no_asm}",
+
+#### *BSD [do see comment about ${BSDthreads} above!]
+"BSD-generic32","gcc:-DTERMIOS -O3 -fomit-frame-pointer -Wall::${BSDthreads}:::BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-x86",	"gcc:-DL_ENDIAN -DTERMIOS -O3 -fomit-frame-pointer -Wall::${BSDthreads}:::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_out_asm}:dlfcn:bsd-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-x86-elf",	"gcc:-DL_ENDIAN -DTERMIOS -O3 -fomit-frame-pointer -Wall::${BSDthreads}:::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:bsd-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-BSD-x86-elf",	"gcc:-DL_ENDIAN -DTERMIOS -O3 -Wall -g::${BSDthreads}:::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:bsd-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-sparcv8",	"gcc:-DB_ENDIAN -DTERMIOS -O3 -mv8 -Wall::${BSDthreads}:::BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL::sparcv8.o:des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+"BSD-generic64","gcc:-DTERMIOS -O3 -Wall::${BSDthreads}:::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# -DMD32_REG_T=int doesn't actually belong in sparc64 target, it
+# simply *happens* to work around a compiler bug in gcc 3.3.3,
+# triggered by RIPEMD160 code.
+"BSD-sparc64",	"gcc:-DB_ENDIAN -DTERMIOS -O3 -DMD32_REG_T=int -Wall::${BSDthreads}:::SIXTY_FOUR_BIT_LONG RC2_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC2 BF_PTR:::des_enc-sparc.o fcrypt_b.o:::::::::dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-ia64",	"gcc:-DL_ENDIAN -DTERMIOS -O3 -Wall::${BSDthreads}:::SIXTY_FOUR_BIT_LONG RC4_CHUNK:${ia64_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-x86_64",	"gcc:-DL_ENDIAN -DTERMIOS -O3 -DMD32_REG_T=int -Wall::${BSDthreads}:::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+"bsdi-elf-gcc",     "gcc:-DPERL5 -DL_ENDIAN -fomit-frame-pointer -O3 -march=i486 -Wall::(unknown)::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+"nextstep",	"cc:-O -Wall:<libc.h>:(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:::",
+"nextstep3.3",	"cc:-O3 -Wall:<libc.h>:(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:::",
+
+# NCR MP-RAS UNIX ver 02.03.01
+"ncr-scde","cc:-O6 -Xa -Hoff=BEHAVED -686 -Hwide -Hiw::(unknown)::-lsocket -lnsl -lc89:${x86_gcc_des} ${x86_gcc_opts}:::",
+
+# QNX
+"qnx4",	"cc:-DL_ENDIAN -DTERMIO::(unknown):::${x86_gcc_des} ${x86_gcc_opts}:",
+"qnx6",	"cc:-DL_ENDIAN -DTERMIOS::(unknown)::-lsocket:${x86_gcc_des} ${x86_gcc_opts}:",
+
+#### SCO/Caldera targets.
+#
+# Originally we had like unixware-*, unixware-*-pentium, unixware-*-p6, etc.
+# Now we only have blended unixware-* as it's the only one used by ./config.
+# If you want to optimize for particular microarchitecture, bypass ./config
+# and './Configure unixware-7 -Kpentium_pro' or whatever appropriate.
+# Note that not all targets include assembler support. Mostly because of
+# lack of motivation to support out-of-date platforms with out-of-date
+# compiler drivers and assemblers. Tim Rice <tim@multitalents.net> has
+# patiently assisted to debug most of it.
+#
+# UnixWare 2.0x fails destest with -O.
+"unixware-2.0","cc:-DFILIO_H -DNO_STRINGS_H::-Kthread::-lsocket -lnsl -lresolv -lx:${x86_gcc_des} ${x86_gcc_opts}:::",
+"unixware-2.1","cc:-O -DFILIO_H::-Kthread::-lsocket -lnsl -lresolv -lx:${x86_gcc_des} ${x86_gcc_opts}:::",
+"unixware-7","cc:-O -DFILIO_H -Kalloca::-Kthread::-lsocket -lnsl:BN_LLONG MD2_CHAR RC4_INDEX ${x86_gcc_des}:${x86_elf_asm}:dlfcn:svr5-shared:-Kpic::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"unixware-7-gcc","gcc:-DL_ENDIAN -DFILIO_H -O3 -fomit-frame-pointer -march=pentium -Wall::-D_REENTRANT::-lsocket -lnsl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:gnu-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# SCO 5 - Ben Laurie <ben@algroup.co.uk> says the -O breaks the SCO cc.
+"sco5-cc",  "cc:-belf::(unknown)::-lsocket -lnsl:${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:svr3-shared:-Kpic::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"sco5-gcc",  "gcc:-O3 -fomit-frame-pointer::(unknown)::-lsocket -lnsl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:svr3-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#### IBM's AIX.
+"aix3-cc",  "cc:-O -DB_ENDIAN -qmaxmem=16384::(unknown):AIX::BN_LLONG RC4_CHAR:::",
+"aix-gcc",  "gcc:-O -DB_ENDIAN::-D_THREAD_SAFE:AIX::BN_LLONG RC4_CHAR::aix_ppc32.o::::::::::dlfcn:aix-shared:::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)::-X 32",
+"aix64-gcc","gcc:-maix64 -O -DB_ENDIAN::-D_THREAD_SAFE:AIX::SIXTY_FOUR_BIT_LONG RC4_CHAR::aix_ppc64.o::::::::::dlfcn:aix-shared::-maix64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)::-X64",
+# Below targets assume AIX 5. Idea is to effectively disregard $OBJECT_MODE
+# at build time. $OBJECT_MODE is respected at ./config stage!
+"aix-cc",   "cc:-q32 -O -DB_ENDIAN -qmaxmem=16384 -qro -qroconst::-qthreaded:AIX::BN_LLONG RC4_CHAR::aix_ppc32.o::::::::::dlfcn:aix-shared::-q32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)::-X 32",
+"aix64-cc", "cc:-q64 -O -DB_ENDIAN -qmaxmem=16384 -qro -qroconst::-qthreaded:AIX::SIXTY_FOUR_BIT_LONG RC4_CHAR::aix_ppc64.o::::::::::dlfcn:aix-shared::-q64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)::-X 64",
+
+#
+# Cray T90 and similar (SDSC)
+# It's Big-endian, but the algorithms work properly when B_ENDIAN is NOT
+# defined.  The T90 ints and longs are 8 bytes long, and apparently the
+# B_ENDIAN code assumes 4 byte ints.  Fortunately, the non-B_ENDIAN and
+# non L_ENDIAN code aligns the bytes in each word correctly.
+#
+# The BIT_FIELD_LIMITS define is to avoid two fatal compiler errors:
+#'Taking the address of a bit field is not allowed. '
+#'An expression with bit field exists as the operand of "sizeof" '
+# (written by Wayne Schroeder <schroede@SDSC.EDU>)
+#
+# j90 is considered the base machine type for unicos machines,
+# so this configuration is now called "cray-j90" ...
+"cray-j90", "cc: -DBIT_FIELD_LIMITS -DTERMIOS::(unknown):CRAY::SIXTY_FOUR_BIT_LONG DES_INT:::",
+
+#
+# Cray T3E (Research Center Juelich, beckman@acl.lanl.gov)
+#
+# The BIT_FIELD_LIMITS define was written for the C90 (it seems).  I added
+# another use.  Basically, the problem is that the T3E uses some bit fields
+# for some st_addr stuff, and then sizeof and address-of fails
+# I could not use the ams/alpha.o option because the Cray assembler, 'cam'
+# did not like it.
+"cray-t3e", "cc: -DBIT_FIELD_LIMITS -DTERMIOS::(unknown):CRAY::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT:::",
+
+# DGUX, 88100.
+"dgux-R3-gcc",	"gcc:-O3 -fomit-frame-pointer::(unknown):::RC4_INDEX DES_UNROLL:::",
+"dgux-R4-gcc",	"gcc:-O3 -fomit-frame-pointer::(unknown)::-lnsl -lsocket:RC4_INDEX DES_UNROLL:::",
+"dgux-R4-x86-gcc",	"gcc:-O3 -fomit-frame-pointer -DL_ENDIAN::(unknown)::-lnsl -lsocket:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}",
+
+# Sinix/ReliantUNIX RM400
+# NOTE: The CDS++ Compiler up to V2.0Bsomething has the IRIX_CC_BUG optimizer problem. Better use -g  */
+"ReliantUNIX","cc:-KPIC -g -DTERMIOS -DB_ENDIAN::-Kthread:SNI:-lsocket -lnsl -lc -L/usr/ucblib -lucb:BN_LLONG DES_PTR DES_RISC2 DES_UNROLL BF_PTR:${no_asm}:dlfcn:reliantunix-shared:::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"SINIX","cc:-O::(unknown):SNI:-lsocket -lnsl -lc -L/usr/ucblib -lucb:RC4_INDEX RC4_CHAR:::",
+"SINIX-N","/usr/ucb/cc:-O2 -misaligned::(unknown)::-lucb:RC4_INDEX RC4_CHAR:::",
+
+# SIEMENS BS2000/OSD: an EBCDIC-based mainframe
+"BS2000-OSD","c89:-O -XLLML -XLLMK -XL -DB_ENDIAN -DTERMIOS -DCHARSET_EBCDIC::(unknown)::-lsocket -lnsl:THIRTY_TWO_BIT DES_PTR DES_UNROLL MD2_CHAR RC4_INDEX RC4_CHAR BF_PTR:::",
+
+# OS/390 Unix an EBCDIC-based Unix system on IBM mainframe
+# You need to compile using the c89.sh wrapper in the tools directory, because the
+# IBM compiler does not like the -L switch after any object modules.
+#
+"OS390-Unix","c89.sh:-O -DB_ENDIAN -DCHARSET_EBCDIC -DNO_SYS_PARAM_H  -D_ALL_SOURCE::(unknown):::THIRTY_TWO_BIT DES_PTR DES_UNROLL MD2_CHAR RC4_INDEX RC4_CHAR BF_PTR:::",
+
+# Win64 targets, WIN64I denotes IA-64 and WIN64A - AMD64
+"VC-WIN64I","cl::::WIN64I::SIXTY_FOUR_BIT RC4_CHUNK_LL DES_INT EXPORT_VAR_AS_FN:${no_asm}:win32",
+"VC-WIN64A","cl::::WIN64A::SIXTY_FOUR_BIT RC4_CHUNK_LL DES_INT EXPORT_VAR_AS_FN:${no_asm}:win32",
+
+# Visual C targets
+"VC-NT","cl::::WINNT::BN_LLONG RC4_INDEX EXPORT_VAR_AS_FN ${x86_gcc_opts}:${no_asm}:win32",
+"VC-CE","cl::::WINCE::BN_LLONG RC4_INDEX EXPORT_VAR_AS_FN ${x86_gcc_opts}:${no_asm}:win32",
+"VC-WIN32","cl::::WIN32::BN_LLONG RC4_INDEX EXPORT_VAR_AS_FN ${x86_gcc_opts}:${no_asm}:win32",
+
+# Borland C++ 4.5
+"BC-32","bcc32::::WIN32::BN_LLONG DES_PTR RC4_INDEX EXPORT_VAR_AS_FN:${no_asm}:win32",
+
+# MinGW
+"mingw", "gcc:-mno-cygwin -DL_ENDIAN -fomit-frame-pointer -O3 -march=i486 -Wall -D_WIN32_WINNT=0x333:::MINGW32:-lwsock32 -lgdi32:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts} EXPORT_VAR_AS_FN:${x86_coff_asm}:win32:cygwin-shared:-D_WINDLL -DOPENSSL_USE_APPLINK:-mno-cygwin -shared:.dll.a",
+
+# UWIN 
+"UWIN", "cc:-DTERMIOS -DL_ENDIAN -O -Wall:::UWIN::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:win32",
+
+# Cygwin
+"Cygwin-pre1.3", "gcc:-DTERMIOS -DL_ENDIAN -fomit-frame-pointer -O3 -m486 -Wall::(unknown):CYGWIN32::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:win32",
+"Cygwin", "gcc:-DTERMIOS -DL_ENDIAN -fomit-frame-pointer -O3 -march=i486 -Wall:::CYGWIN32::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_coff_asm}:dlfcn:cygwin-shared:-D_WINDLL:-shared:.dll.a",
+"debug-Cygwin", "gcc:-DTERMIOS -DL_ENDIAN -march=i486 -Wall -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DOPENSSL_NO_ASM -g -Wformat -Wshadow -Wmissing-prototypes -Wmissing-declarations -Werror:::CYGWIN32:::${no_asm}:dlfcn:cygwin-shared:-D_WINDLL:-shared:.dll.a",
+
+# NetWare from David Ward (dsward@novell.com)
+# requires either MetroWerks NLM development tools, or gcc / nlmconv
+# NetWare defaults socket bio to WinSock sockets. However,
+# the builds can be configured to use BSD sockets instead.
+# netware-clib => legacy CLib c-runtime support
+"netware-clib", "mwccnlm::::::${x86_gcc_opts}::",
+"netware-clib-bsdsock", "mwccnlm::::::${x86_gcc_opts}::",
+"netware-clib-gcc", "i586-netware-gcc:-nostdinc -I/ndk/nwsdk/include/nlm -I/ndk/ws295sdk/include -DL_ENDIAN -DNETWARE_CLIB -DOPENSSL_SYSNAME_NETWARE -O2 -Wall:::::${x86_gcc_opts}::",
+"netware-clib-bsdsock-gcc", "i586-netware-gcc:-nostdinc -I/ndk/nwsdk/include/nlm -DNETWARE_BSDSOCK -DNETDB_USE_INTERNET -DL_ENDIAN -DNETWARE_CLIB -DOPENSSL_SYSNAME_NETWARE -O2 -Wall:::::${x86_gcc_opts}::",
+# netware-libc => LibC/NKS support
+"netware-libc", "mwccnlm::::::BN_LLONG ${x86_gcc_opts}::",
+"netware-libc-bsdsock", "mwccnlm::::::BN_LLONG ${x86_gcc_opts}::",
+"netware-libc-gcc", "i586-netware-gcc:-nostdinc -I/ndk/libc/include -I/ndk/libc/include/winsock -DL_ENDIAN -DNETWARE_LIBC -DOPENSSL_SYSNAME_NETWARE -DTERMIO -O2 -Wall:::::BN_LLONG ${x86_gcc_opts}::",
+"netware-libc-bsdsock-gcc", "i586-netware-gcc:-nostdinc -I/ndk/libc/include -DNETWARE_BSDSOCK -DL_ENDIAN -DNETWARE_LIBC -DOPENSSL_SYSNAME_NETWARE -DTERMIO -O2 -Wall:::::BN_LLONG ${x86_gcc_opts}::",
+
+# DJGPP
+"DJGPP", "gcc:-I/dev/env/WATT_ROOT/inc -DTERMIOS -DL_ENDIAN -fomit-frame-pointer -O2 -Wall:::MSDOS:-L/dev/env/WATT_ROOT/lib -lwatt:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_out_asm}:",
+
+# Ultrix from Bernhard Simon <simon@zid.tuwien.ac.at>
+"ultrix-cc","cc:-std1 -O -Olimit 2500 -DL_ENDIAN::(unknown):::::::",
+"ultrix-gcc","gcc:-O3 -DL_ENDIAN::(unknown):::BN_LLONG::::",
+# K&R C is no longer supported; you need gcc on old Ultrix installations
+##"ultrix","cc:-O2 -DNOPROTO -DNOCONST -DL_ENDIAN::(unknown):::::::",
+
+##### MacOS X (a.k.a. Rhapsody or Darwin) setup
+"rhapsody-ppc-cc","cc:-O3 -DB_ENDIAN::(unknown):MACOSX_RHAPSODY::BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${no_asm}::",
+"darwin-ppc-cc","cc:-arch ppc -O3 -DB_ENDIAN::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR::osx_ppc32.o::::::::::dlfcn:darwin-shared:-fPIC -fno-common:-arch ppc -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"darwin64-ppc-cc","cc:-arch ppc64 -O3 -DB_ENDIAN::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:ppccpuid_osx64.o:osx_ppc64.o osx_ppc64-mont.o:::::sha1-ppc_osx64.o sha256-ppc_osx64.o sha512-ppc_osx64.o:::::dlfcn:darwin-shared:-fPIC -fno-common:-arch ppc64 -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"darwin-i386-cc","cc:-arch i386 -O3 -fomit-frame-pointer -fno-common::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${no_asm}:dlfcn:darwin-shared:-fPIC -fno-common:-arch i386 -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"darwin64-x86_64-cc","cc:-arch x86_64 -O3 -fomit-frame-pointer -DL_ENDIAN -DMD32_REG_T=int -Wall::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK BF_PTR2 DES_INT DES_UNROLL:${no_asm}:dlfcn:darwin-shared:-fPIC -fno-common:-arch x86_64 -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"debug-darwin-ppc-cc","cc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DB_ENDIAN -g -Wall -O::-D_REENTRANT:MACOSX::BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR::osx_ppc32.o::::::::::dlfcn:darwin-shared:-fPIC -fno-common:-dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+
+##### A/UX
+"aux3-gcc","gcc:-O2 -DTERMIO::(unknown):AUX:-lbsd:RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:::",
+
+##### Sony NEWS-OS 4.x
+"newsos4-gcc","gcc:-O -DB_ENDIAN::(unknown):NEWS4:-lmld -liberty:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR::::",
+
+##### GNU Hurd
+"hurd-x86",  "gcc:-DL_ENDIAN -DTERMIOS -O3 -fomit-frame-pointer -march=i486 -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC",
+
+##### OS/2 EMX
+"OS2-EMX", "gcc::::::::",
+
+##### VxWorks for various targets
+"vxworks-ppc405","ccppc:-g -msoft-float -mlongcall -DCPU=PPC405 -I\$(WIND_BASE)/target/h:::VXWORKS:-r:::::",
+"vxworks-ppc750","ccppc:-ansi -nostdinc -DPPC750 -D_REENTRANT -fvolatile -fno-builtin -fno-for-scope -fsigned-char -Wall -msoft-float -mlongcall -DCPU=PPC604 -I\$(WIND_BASE)/target/h \$(DEBUG_FLAG):::VXWORKS:-r:::::",
+"vxworks-ppc750-debug","ccppc:-ansi -nostdinc -DPPC750 -D_REENTRANT -fvolatile -fno-builtin -fno-for-scope -fsigned-char -Wall -msoft-float -mlongcall -DCPU=PPC604 -I\$(WIND_BASE)/target/h -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DPEDANTIC -DDEBUG_SAFESTACK -DDEBUG -g:::VXWORKS:-r:::::",
+"vxworks-ppc860","ccppc:-nostdinc -msoft-float -DCPU=PPC860 -DNO_STRINGS_H -I\$(WIND_BASE)/target/h:::VXWORKS:-r:::::",
+"vxworks-mipsle","ccmips:-B\$(WIND_BASE)/host/\$(WIND_HOST_TYPE)/lib/gcc-lib/ -DL_ENDIAN -EL -Wl,-EL -mips2 -mno-branch-likely -G 0 -fno-builtin -msoft-float -DCPU=MIPS32 -DMIPSEL -DNO_STRINGS_H -I\$(WIND_BASE)/target/h:::VXWORKS:-r::${no_asm}::::::ranlibmips:",
+
+##### Compaq Non-Stop Kernel (Tandem)
+"tandem-c89","c89:-Ww -D__TANDEM -D_XOPEN_SOURCE -D_XOPEN_SOURCE_EXTENDED=1 -D_TANDEM_SOURCE -DB_ENDIAN::(unknown):::THIRTY_TWO_BIT:::",
+
+);
+
+my @MK1MF_Builds=qw(VC-WIN64I VC-WIN64A
+		    VC-NT VC-CE VC-WIN32
+		    BC-32 OS2-EMX
+		    netware-clib netware-clib-bsdsock
+		    netware-libc netware-libc-bsdsock);
+
+my $idx = 0;
+my $idx_cc = $idx++;
+my $idx_cflags = $idx++;
+my $idx_unistd = $idx++;
+my $idx_thread_cflag = $idx++;
+my $idx_sys_id = $idx++;
+my $idx_lflags = $idx++;
+my $idx_bn_ops = $idx++;
+my $idx_cpuid_obj = $idx++;
+my $idx_bn_obj = $idx++;
+my $idx_des_obj = $idx++;
+my $idx_aes_obj = $idx++;
+my $idx_bf_obj = $idx++;
+my $idx_md5_obj = $idx++;
+my $idx_sha1_obj = $idx++;
+my $idx_cast_obj = $idx++;
+my $idx_rc4_obj = $idx++;
+my $idx_rmd160_obj = $idx++;
+my $idx_rc5_obj = $idx++;
+my $idx_dso_scheme = $idx++;
+my $idx_shared_target = $idx++;
+my $idx_shared_cflag = $idx++;
+my $idx_shared_ldflag = $idx++;
+my $idx_shared_extension = $idx++;
+my $idx_ranlib = $idx++;
+my $idx_arflags = $idx++;
+
+my $prefix="";
+my $openssldir="";
+my $exe_ext="";
+my $install_prefix="";
+my $no_threads=0;
+my $threads=0;
+my $no_shared=0; # but "no-shared" is default
+my $zlib=1;      # but "no-zlib" is default
+my $no_krb5=0;   # but "no-krb5" is implied unless "--with-krb5-..." is used
+my $no_rfc3779=1; # but "no-rfc3779" is default
+my $montasm=1;   # but "no-montasm" is default
+my $no_asm=0;
+my $no_dso=0;
+my $no_gmp=0;
+my @skip=();
+my $Makefile="Makefile";
+my $des_locl="crypto/des/des_locl.h";
+my $des	="crypto/des/des.h";
+my $bn	="crypto/bn/bn.h";
+my $md2	="crypto/md2/md2.h";
+my $rc4	="crypto/rc4/rc4.h";
+my $rc4_locl="crypto/rc4/rc4_locl.h";
+my $idea	="crypto/idea/idea.h";
+my $rc2	="crypto/rc2/rc2.h";
+my $bf	="crypto/bf/bf_locl.h";
+my $bn_asm	="bn_asm.o";
+my $des_enc="des_enc.o fcrypt_b.o";
+my $aes_enc="aes_core.o aes_cbc.o";
+my $bf_enc	="bf_enc.o";
+my $cast_enc="c_enc.o";
+my $rc4_enc="rc4_enc.o rc4_skey.o";
+my $rc5_enc="rc5_enc.o";
+my $md5_obj="";
+my $sha1_obj="";
+my $rmd160_obj="";
+my $processor="";
+my $default_ranlib;
+my $perl;
+
+
+# All of the following is disabled by default (RC5 was enabled before 0.9.8):
+
+my %disabled = ( # "what"         => "comment"
+                 "camellia"       => "default",
+                 "cms"            => "default",
+                 "gmp"            => "default",
+                 "mdc2"           => "default",
+                 "montasm"        => "default", # explicit option in 0.9.8 only (implicitly enabled in 0.9.9)
+                 "rc5"            => "default",
+                 "rfc3779"        => "default",
+                 "seed"           => "default",
+                 "shared"         => "default",
+                 "tlsext"         => "default",
+                 "zlib"           => "default",
+                 "zlib-dynamic"   => "default"
+               );
+
+# Additional "no-..." options will be collected in %disabled.
+# To remove something from %disabled, use e.g. "enable-rc5".
+# For symmetry, "disable-..." is a synonym for "no-...".
+
+# This is what $depflags will look like with the above default:
+my $default_depflags = "-DOPENSSL_NO_CAMELLIA -DOPENSSL_NO_CMS -DOPENSSL_NO_GMP -DOPENSSL_NO_MDC2 -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SEED -DOPENSSL_NO_TLSEXT ";
+
+
+my $no_sse2=0;
+
+&usage if ($#ARGV < 0);
+
+my $flags;
+my $depflags;
+my $openssl_algorithm_defines;
+my $openssl_thread_defines;
+my $openssl_sys_defines="";
+my $openssl_other_defines;
+my $libs;
+my $libkrb5="";
+my $target;
+my $options;
+my $symlink;
+my $make_depend=0;
+my %withargs=();
+
+my @argvcopy=@ARGV;
+my $argvstring="";
+my $argv_unprocessed=1;
+
+while($argv_unprocessed)
+	{
+	$flags="";
+	$depflags="";
+	$openssl_algorithm_defines="";
+	$openssl_thread_defines="";
+	$openssl_sys_defines="";
+	$openssl_other_defines="";
+	$libs="";
+	$target="";
+	$options="";
+	$symlink=1;
+
+	$argv_unprocessed=0;
+	$argvstring=join(' ',@argvcopy);
+
+PROCESS_ARGS:
+	foreach (@argvcopy)
+		{
+		s /^-no-/no-/; # some people just can't read the instructions
+
+		# rewrite some options in "enable-..." form
+		s /^-?-?shared$/enable-shared/;
+		s /^threads$/enable-threads/;
+		s /^zlib$/enable-zlib/;
+		s /^zlib-dynamic$/enable-zlib-dynamic/;
+
+		if (/^no-(.+)$/ || /^disable-(.+)$/)
+			{
+			if ($1 eq "ssl")
+				{
+				$disabled{"ssl2"} = "option(ssl)";
+				$disabled{"ssl3"} = "option(ssl)";
+				}
+			elsif ($1 eq "tls")
+				{
+				$disabled{"tls1"} = "option(tls)"
+				}
+			else
+				{
+				$disabled{$1} = "option";
+				}
+			}			
+		elsif (/^enable-(.+)$/)
+			{
+			delete $disabled{$1};
+
+			$threads = 1 if ($1 eq "threads");
+			}
+		elsif (/^--test-sanity$/)
+			{
+			exit(&test_sanity());
+			}
+		elsif (/^reconfigure/ || /^reconf/)
+			{
+			if (open(IN,"<$Makefile"))
+				{
+				while (<IN>)
+					{
+					chomp;
+					if (/^CONFIGURE_ARGS=(.*)/)
+						{
+						$argvstring=$1;
+						@argvcopy=split(' ',$argvstring);
+						die "Incorrect data to reconfigure, please do a normal configuration\n"
+							if (grep(/^reconf/,@argvcopy));
+						print "Reconfiguring with: $argvstring\n";
+						$argv_unprocessed=1;
+						close(IN);
+						last PROCESS_ARGS;
+						}
+					}
+				close(IN);
+				}
+			die "Insufficient data to reconfigure, please do a normal configuration\n";
+			}
+		elsif (/^386$/)
+			{ $processor=386; }
+		elsif (/^rsaref$/)
+			{
+			# No RSAref support any more since it's not needed.
+			# The check for the option is there so scripts aren't
+			# broken
+			}
+		elsif (/^[-+]/)
+			{
+			if (/^-[lL](.*)$/)
+				{
+				$libs.=$_." ";
+				}
+			elsif (/^-[^-]/ or /^\+/)
+				{
+				$flags.=$_." ";
+				}
+			elsif (/^--prefix=(.*)$/)
+				{
+				$prefix=$1;
+				}
+			elsif (/^--openssldir=(.*)$/)
+				{
+				$openssldir=$1;
+				}
+			elsif (/^--install.prefix=(.*)$/)
+				{
+				$install_prefix=$1;
+				}
+			elsif (/^--with-krb5-(dir|lib|include|flavor)=(.*)$/)
+				{
+				$withargs{"krb5-".$1}=$2;
+				}
+			elsif (/^--with-zlib-lib=(.*)$/)
+				{
+				$withargs{"zlib-lib"}=$1;
+				}
+			elsif (/^--with-zlib-include=(.*)$/)
+				{
+				$withargs{"zlib-include"}="-I$1";
+				}
+			else
+				{
+				print STDERR $usage;
+				exit(1);
+				}
+			}
+		elsif ($_ =~ /^([^:]+):(.+)$/)
+			{
+			eval "\$table{\$1} = \"$2\""; # allow $xxx constructs in the string
+			$target=$1;
+			}
+		else
+			{
+			die "target already defined - $target (offending arg: $_)\n" if ($target ne "");
+			$target=$_;
+			}
+
+		unless ($_ eq $target || /^no-/ || /^disable-/)
+			{
+			# "no-..." follows later after implied disactivations
+			# have been derived.  (Don't take this too seroiusly,
+			# we really only write OPTIONS to the Makefile out of
+			# nostalgia.)
+
+			if ($options eq "")
+				{ $options = $_; }
+			else
+				{ $options .= " ".$_; }
+			}
+		}
+	}
+
+
+
+if ($processor eq "386")
+	{
+	$disabled{"sse2"} = "forced";
+	}
+
+if (!defined($withargs{"krb5-flavor"}) || $withargs{"krb5-flavor"} eq "")
+	{
+	$disabled{"krb5"} = "krb5-flavor not specified";
+	}
+
+if (!defined($disabled{"zlib-dynamic"}))
+	{
+	# "zlib-dynamic" was specifically enabled, so enable "zlib"
+	delete $disabled{"zlib"};
+	}
+
+if (defined($disabled{"rijndael"}))
+	{
+	$disabled{"aes"} = "forced";
+	}
+if (defined($disabled{"des"}))
+	{
+	$disabled{"mdc2"} = "forced";
+	}
+if (defined($disabled{"ec"}))
+	{
+	$disabled{"ecdsa"} = "forced";
+	$disabled{"ecdh"} = "forced";
+	}
+
+# SSL 2.0 requires MD5 and RSA
+if (defined($disabled{"md5"}) || defined($disabled{"rsa"}))
+	{
+	$disabled{"ssl2"} = "forced";
+	}
+
+# SSL 3.0 and TLS requires MD5 and SHA and either RSA or DSA+DH
+if (defined($disabled{"md5"}) || defined($disabled{"sha"})
+    || (defined($disabled{"rsa"})
+        && (defined($disabled{"dsa"}) || defined($disabled{"dh"}))))
+	{
+	$disabled{"ssl3"} = "forced";
+	$disabled{"tls1"} = "forced";
+	}
+
+if (defined($disabled{"tls1"}))
+	{
+	$disabled{"tlsext"} = "forced";
+	}
+
+if ($target eq "TABLE") {
+	foreach $target (sort keys %table) {
+		print_table_entry($target);
+	}
+	exit 0;
+}
+
+if ($target eq "LIST") {
+	foreach (sort keys %table) {
+		print;
+		print "\n";
+	}
+	exit 0;
+}
+
+if ($target =~ m/^CygWin32(-.*)$/) {
+	$target = "Cygwin".$1;
+}
+
+print "Configuring for $target\n";
+
+&usage if (!defined($table{$target}));
+
+
+foreach (sort (keys %disabled))
+	{
+	$options .= " no-$_";
+
+	printf "    no-%-12s %-10s", $_, "[$disabled{$_}]";
+
+	if (/^dso$/)
+		{ $no_dso = 1; }
+	elsif (/^threads$/)
+		{ $no_threads = 1; }
+	elsif (/^shared$/)
+		{ $no_shared = 1; }
+	elsif (/^zlib$/)
+		{ $zlib = 0; }
+	elsif (/^montasm$/)
+		{ $montasm = 0; }
+	elsif (/^static-engine$/)
+		{ }
+	elsif (/^zlib-dynamic$/)
+		{ }
+	elsif (/^symlinks$/)
+		{ $symlink = 0; }
+	elsif (/^sse2$/)
+		{ $no_sse2 = 1; }
+	else
+		{
+		my ($ALGO, $algo);
+		($ALGO = $algo = $_) =~ tr/[a-z]/[A-Z]/;
+
+		if (/^asm$/ || /^err$/ || /^hw$/ || /^hw-/)
+			{
+			$openssl_other_defines .= "#define OPENSSL_NO_$ALGO\n";
+			print " OPENSSL_NO_$ALGO";
+		
+			if (/^err$/)	{ $flags .= "-DOPENSSL_NO_ERR "; }
+			elsif (/^asm$/)	{ $no_asm = 1; }
+			}
+		else
+			{
+			$openssl_algorithm_defines .= "#define OPENSSL_NO_$ALGO\n";
+			print " OPENSSL_NO_$ALGO";
+
+			if (/^krb5$/)
+				{ $no_krb5 = 1; }
+			else
+				{
+				push @skip, $algo;
+				print " (skip dir)";
+
+				$depflags .="-DOPENSSL_NO_$ALGO ";
+				}
+			}
+		}
+
+	print "\n";
+	}
+
+
+my $IsMK1MF=scalar grep /^$target$/,@MK1MF_Builds;
+
+$IsMK1MF=1 if ($target eq "mingw" && $^O ne "cygwin" && !is_msys());
+
+$exe_ext=".exe" if ($target eq "Cygwin" || $target eq "DJGPP" || $target eq "mingw");
+$exe_ext=".nlm" if ($target =~ /netware/);
+$exe_ext=".pm"  if ($target =~ /vos/);
+$openssldir="/usr/local/ssl" if ($openssldir eq "" and $prefix eq "");
+$prefix=$openssldir if $prefix eq "";
+
+$default_ranlib= &which("ranlib") or $default_ranlib="true";
+$perl=$ENV{'PERL'} or $perl=&which("perl5") or $perl=&which("perl")
+  or $perl="perl";
+
+chop $openssldir if $openssldir =~ /\/$/;
+chop $prefix if $prefix =~ /\/$/;
+
+$openssldir=$prefix . "/ssl" if $openssldir eq "";
+$openssldir=$prefix . "/" . $openssldir if $openssldir !~ /(^\/|^[a-zA-Z]:[\\\/])/;
+
+
+print "IsMK1MF=$IsMK1MF\n";
+
+my @fields = split(/\s*:\s*/,$table{$target} . ":" x 30 , -1);
+my $cc = $fields[$idx_cc];
+my $cflags = $fields[$idx_cflags];
+my $unistd = $fields[$idx_unistd];
+my $thread_cflag = $fields[$idx_thread_cflag];
+my $sys_id = $fields[$idx_sys_id];
+my $lflags = $fields[$idx_lflags];
+my $bn_ops = $fields[$idx_bn_ops];
+my $cpuid_obj = $fields[$idx_cpuid_obj];
+my $bn_obj = $fields[$idx_bn_obj];
+my $des_obj = $fields[$idx_des_obj];
+my $aes_obj = $fields[$idx_aes_obj];
+my $bf_obj = $fields[$idx_bf_obj];
+my $md5_obj = $fields[$idx_md5_obj];
+my $sha1_obj = $fields[$idx_sha1_obj];
+my $cast_obj = $fields[$idx_cast_obj];
+my $rc4_obj = $fields[$idx_rc4_obj];
+my $rmd160_obj = $fields[$idx_rmd160_obj];
+my $rc5_obj = $fields[$idx_rc5_obj];
+my $dso_scheme = $fields[$idx_dso_scheme];
+my $shared_target = $fields[$idx_shared_target];
+my $shared_cflag = $fields[$idx_shared_cflag];
+my $shared_ldflag = $fields[$idx_shared_ldflag];
+my $shared_extension = $fields[$idx_shared_extension];
+my $ranlib = $fields[$idx_ranlib];
+my $arflags = $fields[$idx_arflags];
+
+# '%' in $lflags is used to split flags to "pre-" and post-flags
+my ($prelflags,$postlflags)=split('%',$lflags);
+if (defined($postlflags))	{ $lflags=$postlflags;  }
+else				{ $lflags=$prelflags; undef $prelflags; }
+
+my $no_shared_warn=0;
+my $no_user_cflags=0;
+
+if ($flags ne "")	{ $cflags="$flags$cflags"; }
+else			{ $no_user_cflags=1;       }
+
+# Kerberos settings.  The flavor must be provided from outside, either through
+# the script "config" or manually.
+if (!$no_krb5)
+	{
+	my ($lresolv, $lpath, $lext);
+	if ($withargs{"krb5-flavor"} =~ /^[Hh]eimdal$/)
+		{
+		die "Sorry, Heimdal is currently not supported\n";
+		}
+	##### HACK to force use of Heimdal.
+	##### WARNING: Since we don't really have adequate support for Heimdal,
+	#####          using this will break the build.  You'll have to make
+	#####          changes to the source, and if you do, please send
+	#####          patches to openssl-dev@openssl.org
+	if ($withargs{"krb5-flavor"} =~ /^force-[Hh]eimdal$/)
+		{
+		warn "Heimdal isn't really supported.  Your build WILL break\n";
+		warn "If you fix the problems, please send a patch to openssl-dev\@openssl.org\n";
+		$withargs{"krb5-dir"} = "/usr/heimdal"
+			if $withargs{"krb5-dir"} eq "";
+		$withargs{"krb5-lib"} = "-L".$withargs{"krb5-dir"}.
+			"/lib -lgssapi -lkrb5 -lcom_err"
+			if $withargs{"krb5-lib"} eq "" && !$IsMK1MF;
+		$cflags="-DKRB5_HEIMDAL $cflags";
+		}
+	if ($withargs{"krb5-flavor"} =~ /^[Mm][Ii][Tt]/)
+		{
+		$withargs{"krb5-dir"} = "/usr/kerberos"
+			if $withargs{"krb5-dir"} eq "";
+		$withargs{"krb5-lib"} = "-L".$withargs{"krb5-dir"}.
+			"/lib -lgssapi_krb5 -lkrb5 -lcom_err -lk5crypto"
+			if $withargs{"krb5-lib"} eq "" && !$IsMK1MF;
+		$cflags="-DKRB5_MIT $cflags";
+		$withargs{"krb5-flavor"} =~ s/^[Mm][Ii][Tt][._-]*//;
+		if ($withargs{"krb5-flavor"} =~ /^1[._-]*[01]/)
+			{
+			$cflags="-DKRB5_MIT_OLD11 $cflags";
+			}
+		}
+	LRESOLV:
+	foreach $lpath ("/lib", "/usr/lib")
+		{
+		foreach $lext ("a", "so")
+			{
+			$lresolv = "$lpath/libresolv.$lext";
+			last LRESOLV	if (-r "$lresolv");
+			$lresolv = "";
+			}
+		}
+	$withargs{"krb5-lib"} .= " -lresolv"
+		if ("$lresolv" ne "");
+	$withargs{"krb5-include"} = "-I".$withargs{"krb5-dir"}."/include"
+		if $withargs{"krb5-include"} eq "" &&
+		   $withargs{"krb5-dir"} ne "";
+	}
+
+# The DSO code currently always implements all functions so that no
+# applications will have to worry about that from a compilation point
+# of view. However, the "method"s may return zero unless that platform
+# has support compiled in for them. Currently each method is enabled
+# by a define "DSO_<name>" ... we translate the "dso_scheme" config
+# string entry into using the following logic;
+my $dso_cflags;
+if (!$no_dso && $dso_scheme ne "")
+	{
+	$dso_scheme =~ tr/[a-z]/[A-Z]/;
+	if ($dso_scheme eq "DLFCN")
+		{
+		$dso_cflags = "-DDSO_DLFCN -DHAVE_DLFCN_H";
+		}
+	elsif ($dso_scheme eq "DLFCN_NO_H")
+		{
+		$dso_cflags = "-DDSO_DLFCN";
+		}
+	else
+		{
+		$dso_cflags = "-DDSO_$dso_scheme";
+		}
+	$cflags = "$dso_cflags $cflags";
+	}
+
+my $thread_cflags;
+my $thread_defines;
+if ($thread_cflag ne "(unknown)" && !$no_threads)
+	{
+	# If we know how to do it, support threads by default.
+	$threads = 1;
+	}
+if ($thread_cflag eq "(unknown)" && $threads)
+	{
+	# If the user asked for "threads", [s]he is also expected to
+	# provide any system-dependent compiler options that are
+	# necessary.
+	if ($no_user_cflags)
+		{
+		print "You asked for multi-threading support, but didn't\n";
+		print "provide any system-specific compiler options\n";
+		exit(1);
+		}
+	$thread_cflags="-DOPENSSL_THREADS $cflags" ;
+	$thread_defines .= "#define OPENSSL_THREADS\n";
+	}
+else
+	{
+	$thread_cflags="-DOPENSSL_THREADS $thread_cflag $cflags";
+	$thread_defines .= "#define OPENSSL_THREADS\n";
+#	my $def;
+#	foreach $def (split ' ',$thread_cflag)
+#		{
+#		if ($def =~ s/^-D// && $def !~ /^_/)
+#			{
+#			$thread_defines .= "#define $def\n";
+#			}
+#		}
+	}	
+
+$lflags="$libs$lflags" if ($libs ne "");
+
+if ($no_asm)
+	{
+	$cpuid_obj=$bn_obj=$des_obj=$aes_obj=$bf_obj=$cast_obj=$rc4_obj=$rc5_obj="";
+	$sha1_obj=$md5_obj=$rmd160_obj="";
+	}
+if ($montasm)
+	{
+	$bn_obj =~ s/MAYBE-MO86-/mo86-/;
+	}
+else
+	{
+	$bn_obj =~ s/MAYBE-MO86-[a-z.]*//;
+	}
+
+if (!$no_shared)
+	{
+	$cast_obj="";	# CAST assembler is not PIC
+	}
+
+if ($threads)
+	{
+	$cflags=$thread_cflags;
+	$openssl_thread_defines .= $thread_defines;
+	}
+
+if ($zlib)
+	{
+	$cflags = "-DZLIB $cflags";
+	if (defined($disabled{"zlib-dynamic"}))
+		{
+		$lflags = "$lflags -lz";
+		}
+	else
+		{
+		$cflags = "-DZLIB_SHARED $cflags";
+		}
+	}
+
+# You will find shlib_mark1 and shlib_mark2 explained in Makefile.org
+my $shared_mark = "";
+if ($shared_target eq "")
+	{
+	$no_shared_warn = 1 if !$no_shared;
+	$no_shared = 1;
+	}
+if (!$no_shared)
+	{
+	if ($shared_cflag ne "")
+		{
+		$cflags = "$shared_cflag -DOPENSSL_PIC $cflags";
+		}
+	}
+
+if (!$IsMK1MF)
+	{
+	if ($no_shared)
+		{
+		$openssl_other_defines.="#define OPENSSL_NO_DYNAMIC_ENGINE\n";
+		}
+	else
+		{
+		$openssl_other_defines.="#define OPENSSL_NO_STATIC_ENGINE\n";
+		}
+	}
+
+$cpuid_obj.=" uplink.o uplink-cof.o" if ($cflags =~ /\-DOPENSSL_USE_APPLINK/);
+
+#
+# Platform fix-ups
+#
+if ($target =~ /\-icc$/)	# Intel C compiler
+	{
+	my $iccver=0;
+	if (open(FD,"$cc -V 2>&1 |"))
+		{
+		while(<FD>) { $iccver=$1 if (/Version ([0-9]+)\./); }
+		close(FD);
+		}
+	if ($iccver>=8)
+		{
+		# Eliminate unnecessary dependency from libirc.a. This is
+		# essential for shared library support, as otherwise
+		# apps/openssl can end up in endless loop upon startup...
+		$cflags.=" -Dmemcpy=__builtin_memcpy -Dmemset=__builtin_memset";
+		}
+	if ($iccver>=9)
+		{
+		$cflags.=" -i-static";
+		$cflags=~s/\-no_cpprt/-no-cpprt/;
+		}
+	if ($iccver>=10)
+		{
+		$cflags=~s/\-i\-static/-static-intel/;
+		}
+	}
+
+# Unlike other OSes (like Solaris, Linux, Tru64, IRIX) BSD run-time
+# linkers (tested OpenBSD, NetBSD and FreeBSD) "demand" RPATH set on
+# .so objects. Apparently application RPATH is not global and does
+# not apply to .so linked with other .so. Problem manifests itself
+# when libssl.so fails to load libcrypto.so. One can argue that we
+# should engrave this into Makefile.shared rules or into BSD-* config
+# lines above. Meanwhile let's try to be cautious and pass -rpath to
+# linker only when --prefix is not /usr.
+if ($target =~ /^BSD\-/)
+	{
+	$shared_ldflag.=" -Wl,-rpath,\$(LIBRPATH)" if ($prefix !~ m|^/usr[/]*$|);
+	}
+
+if ($sys_id ne "")
+	{
+	#$cflags="-DOPENSSL_SYSNAME_$sys_id $cflags";
+	$openssl_sys_defines="#define OPENSSL_SYSNAME_$sys_id\n";
+	}
+
+if ($ranlib eq "")
+	{
+	$ranlib = $default_ranlib;
+	}
+
+#my ($bn1)=split(/\s+/,$bn_obj);
+#$bn1 = "" unless defined $bn1;
+#$bn1=$bn_asm unless ($bn1 =~ /\.o$/);
+#$bn_obj="$bn1";
+
+$cpuid_obj="" if ($processor eq "386");
+
+$bn_obj = $bn_asm unless $bn_obj ne "";
+# bn86* is the only one implementing bn_*_part_words
+$cflags.=" -DOPENSSL_BN_ASM_PART_WORDS" if ($bn_obj =~ /bn86/);
+$cflags.=" -DOPENSSL_IA32_SSE2" if (!$no_sse2 && $bn_obj =~ /bn86/);
+$cflags.=" -DOPENSSL_BN_ASM_MONT" if ($bn_obj =~ /\-mont|mo86\-/);
+
+$des_obj=$des_enc	unless ($des_obj =~ /\.o$/);
+$bf_obj=$bf_enc		unless ($bf_obj =~ /\.o$/);
+$cast_obj=$cast_enc	unless ($cast_obj =~ /\.o$/);
+$rc4_obj=$rc4_enc	unless ($rc4_obj =~ /\.o$/);
+$rc5_obj=$rc5_enc	unless ($rc5_obj =~ /\.o$/);
+if ($sha1_obj =~ /\.o$/)
+	{
+#	$sha1_obj=$sha1_enc;
+	$cflags.=" -DSHA1_ASM"   if ($sha1_obj =~ /sx86/ || $sha1_obj =~ /sha1/);
+	$cflags.=" -DSHA256_ASM" if ($sha1_obj =~ /sha256/);
+	$cflags.=" -DSHA512_ASM" if ($sha1_obj =~ /sha512/);
+	if ($sha1_obj =~ /sse2/)
+	    {	if ($no_sse2)
+		{   $sha1_obj =~ s/\S*sse2\S+//;        }
+		elsif ($cflags !~ /OPENSSL_IA32_SSE2/)
+		{   $cflags.=" -DOPENSSL_IA32_SSE2";    }
+	    }
+	}
+if ($md5_obj =~ /\.o$/)
+	{
+#	$md5_obj=$md5_enc;
+	$cflags.=" -DMD5_ASM";
+	}
+if ($rmd160_obj =~ /\.o$/)
+	{
+#	$rmd160_obj=$rmd160_enc;
+	$cflags.=" -DRMD160_ASM";
+	}
+if ($aes_obj =~ /\.o$/)
+	{
+	$cflags.=" -DAES_ASM";
+	}
+else	{
+	$aes_obj=$aes_enc;
+	}
+
+# "Stringify" the C flags string.  This permits it to be made part of a string
+# and works as well on command lines.
+$cflags =~ s/([\\\"])/\\\1/g;
+
+my $version = "unknown";
+my $version_num = "unknown";
+my $major = "unknown";
+my $minor = "unknown";
+my $shlib_version_number = "unknown";
+my $shlib_version_history = "unknown";
+my $shlib_major = "unknown";
+my $shlib_minor = "unknown";
+
+open(IN,'<crypto/opensslv.h') || die "unable to read opensslv.h:$!\n";
+while (<IN>)
+	{
+	$version=$1 if /OPENSSL.VERSION.TEXT.*OpenSSL (\S+) /;
+	$version_num=$1 if /OPENSSL.VERSION.NUMBER.*0x(\S+)/;
+	$shlib_version_number=$1 if /SHLIB_VERSION_NUMBER *"([^"]+)"/;
+	$shlib_version_history=$1 if /SHLIB_VERSION_HISTORY *"([^"]*)"/;
+	}
+close(IN);
+if ($shlib_version_history ne "") { $shlib_version_history .= ":"; }
+
+if ($version =~ /(^[0-9]*)\.([0-9\.]*)/)
+	{
+	$major=$1;
+	$minor=$2;
+	}
+
+if ($shlib_version_number =~ /(^[0-9]*)\.([0-9\.]*)/)
+	{
+	$shlib_major=$1;
+	$shlib_minor=$2;
+	}
+
+open(IN,'<Makefile.org') || die "unable to read Makefile.org:$!\n";
+unlink("$Makefile.new") || die "unable to remove old $Makefile.new:$!\n" if -e "$Makefile.new";
+open(OUT,">$Makefile.new") || die "unable to create $Makefile.new:$!\n";
+print OUT "### Generated automatically from Makefile.org by Configure.\n\n";
+my $sdirs=0;
+while (<IN>)
+	{
+	chomp;
+	$sdirs = 1 if /^SDIRS=/;
+	if ($sdirs) {
+		my $dir;
+		foreach $dir (@skip) {
+			s/([ 	])$dir /\1/;
+			}
+		}
+	$sdirs = 0 unless /\\$/;
+	s/^VERSION=.*/VERSION=$version/;
+	s/^MAJOR=.*/MAJOR=$major/;
+	s/^MINOR=.*/MINOR=$minor/;
+	s/^SHLIB_VERSION_NUMBER=.*/SHLIB_VERSION_NUMBER=$shlib_version_number/;
+	s/^SHLIB_VERSION_HISTORY=.*/SHLIB_VERSION_HISTORY=$shlib_version_history/;
+	s/^SHLIB_MAJOR=.*/SHLIB_MAJOR=$shlib_major/;
+	s/^SHLIB_MINOR=.*/SHLIB_MINOR=$shlib_minor/;
+	s/^SHLIB_EXT=.*/SHLIB_EXT=$shared_extension/;
+	s/^INSTALLTOP=.*$/INSTALLTOP=$prefix/;
+	s/^OPENSSLDIR=.*$/OPENSSLDIR=$openssldir/;
+	s/^INSTALL_PREFIX=.*$/INSTALL_PREFIX=$install_prefix/;
+	s/^PLATFORM=.*$/PLATFORM=$target/;
+	s/^OPTIONS=.*$/OPTIONS=$options/;
+	s/^CONFIGURE_ARGS=.*$/CONFIGURE_ARGS=$argvstring/;
+	s/^CC=.*$/CC= $cc/;
+	s/^MAKEDEPPROG=.*$/MAKEDEPPROG= $cc/ if $cc eq "gcc";
+	s/^CFLAG=.*$/CFLAG= $cflags/;
+	s/^DEPFLAG=.*$/DEPFLAG= $depflags/;
+	s/^PEX_LIBS=.*$/PEX_LIBS= $prelflags/;
+	s/^EX_LIBS=.*$/EX_LIBS= $lflags/;
+	s/^EXE_EXT=.*$/EXE_EXT= $exe_ext/;
+	s/^CPUID_OBJ=.*$/CPUID_OBJ= $cpuid_obj/;
+	s/^BN_ASM=.*$/BN_ASM= $bn_obj/;
+	s/^DES_ENC=.*$/DES_ENC= $des_obj/;
+	s/^AES_ASM_OBJ=.*$/AES_ASM_OBJ= $aes_obj/;
+	s/^BF_ENC=.*$/BF_ENC= $bf_obj/;
+	s/^CAST_ENC=.*$/CAST_ENC= $cast_obj/;
+	s/^RC4_ENC=.*$/RC4_ENC= $rc4_obj/;
+	s/^RC5_ENC=.*$/RC5_ENC= $rc5_obj/;
+	s/^MD5_ASM_OBJ=.*$/MD5_ASM_OBJ= $md5_obj/;
+	s/^SHA1_ASM_OBJ=.*$/SHA1_ASM_OBJ= $sha1_obj/;
+	s/^RMD160_ASM_OBJ=.*$/RMD160_ASM_OBJ= $rmd160_obj/;
+	s/^PROCESSOR=.*/PROCESSOR= $processor/;
+	s/^RANLIB=.*/RANLIB= $ranlib/;
+	s/^ARFLAGS=.*/ARFLAGS= $arflags/;
+	s/^PERL=.*/PERL= $perl/;
+	s/^KRB5_INCLUDES=.*/KRB5_INCLUDES=$withargs{"krb5-include"}/;
+	s/^LIBKRB5=.*/LIBKRB5=$withargs{"krb5-lib"}/;
+	s/^LIBZLIB=.*/LIBZLIB=$withargs{"zlib-lib"}/;
+	s/^ZLIB_INCLUDE=.*/ZLIB_INCLUDE=$withargs{"zlib-include"}/;
+	s/^SHLIB_TARGET=.*/SHLIB_TARGET=$shared_target/;
+	s/^SHLIB_MARK=.*/SHLIB_MARK=$shared_mark/;
+	s/^SHARED_LIBS=.*/SHARED_LIBS=\$(SHARED_CRYPTO) \$(SHARED_SSL)/ if (!$no_shared);
+	if ($shared_extension ne "" && $shared_extension =~ /^\.s([ol])\.[^\.]*$/)
+		{
+		my $sotmp = $1;
+		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.s$sotmp/;
+		}
+	elsif ($shared_extension ne "" && $shared_extension =~ /^\.[^\.]*\.dylib$/)
+		{
+		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.dylib/;
+		}
+	elsif ($shared_extension ne "" && $shared_extension =~ /^\.s([ol])\.[^\.]*\.[^\.]*$/)
+		{
+		my $sotmp = $1;
+		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.s$sotmp.\$(SHLIB_MAJOR) .s$sotmp/;
+		}
+	elsif ($shared_extension ne "" && $shared_extension =~ /^\.[^\.]*\.[^\.]*\.dylib$/)
+		{
+		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.\$(SHLIB_MAJOR).dylib .dylib/;
+		}
+	s/^SHARED_LDFLAGS=.*/SHARED_LDFLAGS=$shared_ldflag/;
+	print OUT $_."\n";
+	}
+close(IN);
+close(OUT);
+rename($Makefile,"$Makefile.bak") || die "unable to rename $Makefile\n" if -e $Makefile;
+rename("$Makefile.new",$Makefile) || die "unable to rename $Makefile.new\n";
+
+print "CC            =$cc\n";
+print "CFLAG         =$cflags\n";
+print "EX_LIBS       =$lflags\n";
+print "CPUID_OBJ     =$cpuid_obj\n";
+print "BN_ASM        =$bn_obj\n";
+print "DES_ENC       =$des_obj\n";
+print "AES_ASM_OBJ   =$aes_obj\n";
+print "BF_ENC        =$bf_obj\n";
+print "CAST_ENC      =$cast_obj\n";
+print "RC4_ENC       =$rc4_obj\n";
+print "RC5_ENC       =$rc5_obj\n";
+print "MD5_OBJ_ASM   =$md5_obj\n";
+print "SHA1_OBJ_ASM  =$sha1_obj\n";
+print "RMD160_OBJ_ASM=$rmd160_obj\n";
+print "PROCESSOR     =$processor\n";
+print "RANLIB        =$ranlib\n";
+print "ARFLAGS       =$arflags\n";
+print "PERL          =$perl\n";
+print "KRB5_INCLUDES =",$withargs{"krb5-include"},"\n"
+	if $withargs{"krb5-include"} ne "";
+
+my $des_ptr=0;
+my $des_risc1=0;
+my $des_risc2=0;
+my $des_unroll=0;
+my $bn_ll=0;
+my $def_int=2;
+my $rc4_int=$def_int;
+my $md2_int=$def_int;
+my $idea_int=$def_int;
+my $rc2_int=$def_int;
+my $rc4_idx=0;
+my $rc4_chunk=0;
+my $bf_ptr=0;
+my @type=("char","short","int","long");
+my ($b64l,$b64,$b32,$b16,$b8)=(0,0,1,0,0);
+my $export_var_as_fn=0;
+
+my $des_int;
+
+foreach (sort split(/\s+/,$bn_ops))
+	{
+	$des_ptr=1 if /DES_PTR/;
+	$des_risc1=1 if /DES_RISC1/;
+	$des_risc2=1 if /DES_RISC2/;
+	$des_unroll=1 if /DES_UNROLL/;
+	$des_int=1 if /DES_INT/;
+	$bn_ll=1 if /BN_LLONG/;
+	$rc4_int=0 if /RC4_CHAR/;
+	$rc4_int=3 if /RC4_LONG/;
+	$rc4_idx=1 if /RC4_INDEX/;
+	$rc4_chunk=1 if /RC4_CHUNK/;
+	$rc4_chunk=2 if /RC4_CHUNK_LL/;
+	$md2_int=0 if /MD2_CHAR/;
+	$md2_int=3 if /MD2_LONG/;
+	$idea_int=1 if /IDEA_SHORT/;
+	$idea_int=3 if /IDEA_LONG/;
+	$rc2_int=1 if /RC2_SHORT/;
+	$rc2_int=3 if /RC2_LONG/;
+	$bf_ptr=1 if $_ eq "BF_PTR";
+	$bf_ptr=2 if $_ eq "BF_PTR2";
+	($b64l,$b64,$b32,$b16,$b8)=(0,1,0,0,0) if /SIXTY_FOUR_BIT/;
+	($b64l,$b64,$b32,$b16,$b8)=(1,0,0,0,0) if /SIXTY_FOUR_BIT_LONG/;
+	($b64l,$b64,$b32,$b16,$b8)=(0,0,1,0,0) if /THIRTY_TWO_BIT/;
+	($b64l,$b64,$b32,$b16,$b8)=(0,0,0,1,0) if /SIXTEEN_BIT/;
+	($b64l,$b64,$b32,$b16,$b8)=(0,0,0,0,1) if /EIGHT_BIT/;
+	$export_var_as_fn=1 if /EXPORT_VAR_AS_FN/;
+	}
+
+open(IN,'<crypto/opensslconf.h.in') || die "unable to read crypto/opensslconf.h.in:$!\n";
+unlink("crypto/opensslconf.h.new") || die "unable to remove old crypto/opensslconf.h.new:$!\n" if -e "crypto/opensslconf.h.new";
+open(OUT,'>crypto/opensslconf.h.new') || die "unable to create crypto/opensslconf.h.new:$!\n";
+print OUT "/* opensslconf.h */\n";
+print OUT "/* WARNING: Generated automatically from opensslconf.h.in by Configure. */\n\n";
+
+print OUT "/* OpenSSL was configured with the following options: */\n";
+my $openssl_algorithm_defines_trans = $openssl_algorithm_defines;
+$openssl_algorithm_defines_trans =~ s/^\s*#\s*define\s+OPENSSL_(.*)/# if defined(OPENSSL_$1) \&\& !defined($1)\n#  define $1\n# endif/mg;
+$openssl_algorithm_defines =~ s/^\s*#\s*define\s+(.*)/#ifndef $1\n# define $1\n#endif/mg;
+$openssl_algorithm_defines = "   /* no ciphers excluded */\n" if $openssl_algorithm_defines eq "";
+$openssl_thread_defines =~ s/^\s*#\s*define\s+(.*)/#ifndef $1\n# define $1\n#endif/mg;
+$openssl_sys_defines =~ s/^\s*#\s*define\s+(.*)/#ifndef $1\n# define $1\n#endif/mg;
+$openssl_other_defines =~ s/^\s*#\s*define\s+(.*)/#ifndef $1\n# define $1\n#endif/mg;
+print OUT $openssl_sys_defines;
+print OUT "#ifndef OPENSSL_DOING_MAKEDEPEND\n\n";
+print OUT $openssl_algorithm_defines;
+print OUT "\n#endif /* OPENSSL_DOING_MAKEDEPEND */\n";
+print OUT $openssl_thread_defines;
+print OUT $openssl_other_defines,"\n";
+
+print OUT "/* The OPENSSL_NO_* macros are also defined as NO_* if the application\n";
+print OUT "   asks for it.  This is a transient feature that is provided for those\n";
+print OUT "   who haven't had the time to do the appropriate changes in their\n";
+print OUT "   applications.  */\n";
+print OUT "#ifdef OPENSSL_ALGORITHM_DEFINES\n";
+print OUT $openssl_algorithm_defines_trans;
+print OUT "#endif\n\n";
+
+print OUT "#define OPENSSL_CPUID_OBJ\n\n" if ($cpuid_obj);
+
+while (<IN>)
+	{
+	if	(/^#define\s+OPENSSLDIR/)
+		{ print OUT "#define OPENSSLDIR \"$openssldir\"\n"; }
+	elsif	(/^#define\s+ENGINESDIR/)
+		{ print OUT "#define ENGINESDIR \"$prefix/lib/engines\"\n"; }
+	elsif	(/^#((define)|(undef))\s+OPENSSL_EXPORT_VAR_AS_FUNCTION/)
+		{ printf OUT "#undef OPENSSL_EXPORT_VAR_AS_FUNCTION\n"
+			if $export_var_as_fn;
+		  printf OUT "#%s OPENSSL_EXPORT_VAR_AS_FUNCTION\n",
+			($export_var_as_fn)?"define":"undef"; }
+	elsif	(/^#define\s+OPENSSL_UNISTD/)
+		{
+		$unistd = "<unistd.h>" if $unistd eq "";
+		print OUT "#define OPENSSL_UNISTD $unistd\n";
+		}
+	elsif	(/^#((define)|(undef))\s+SIXTY_FOUR_BIT_LONG/)
+		{ printf OUT "#%s SIXTY_FOUR_BIT_LONG\n",($b64l)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+SIXTY_FOUR_BIT/)
+		{ printf OUT "#%s SIXTY_FOUR_BIT\n",($b64)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+THIRTY_TWO_BIT/)
+		{ printf OUT "#%s THIRTY_TWO_BIT\n",($b32)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+SIXTEEN_BIT/)
+		{ printf OUT "#%s SIXTEEN_BIT\n",($b16)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+EIGHT_BIT/)
+		{ printf OUT "#%s EIGHT_BIT\n",($b8)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+BN_LLONG\s*$/)
+		{ printf OUT "#%s BN_LLONG\n",($bn_ll)?"define":"undef"; }
+	elsif	(/^\#define\s+DES_LONG\s+.*/)
+		{ printf OUT "#define DES_LONG unsigned %s\n",
+			($des_int)?'int':'long'; }
+	elsif	(/^\#(define|undef)\s+DES_PTR/)
+		{ printf OUT "#%s DES_PTR\n",($des_ptr)?'define':'undef'; }
+	elsif	(/^\#(define|undef)\s+DES_RISC1/)
+		{ printf OUT "#%s DES_RISC1\n",($des_risc1)?'define':'undef'; }
+	elsif	(/^\#(define|undef)\s+DES_RISC2/)
+		{ printf OUT "#%s DES_RISC2\n",($des_risc2)?'define':'undef'; }
+	elsif	(/^\#(define|undef)\s+DES_UNROLL/)
+		{ printf OUT "#%s DES_UNROLL\n",($des_unroll)?'define':'undef'; }
+	elsif	(/^#define\s+RC4_INT\s/)
+		{ printf OUT "#define RC4_INT unsigned %s\n",$type[$rc4_int]; }
+	elsif	(/^#undef\s+RC4_CHUNK/)
+		{
+		printf OUT "#undef RC4_CHUNK\n" if $rc4_chunk==0;
+		printf OUT "#define RC4_CHUNK unsigned long\n" if $rc4_chunk==1;
+		printf OUT "#define RC4_CHUNK unsigned long long\n" if $rc4_chunk==2;
+		}
+	elsif	(/^#((define)|(undef))\s+RC4_INDEX/)
+		{ printf OUT "#%s RC4_INDEX\n",($rc4_idx)?"define":"undef"; }
+	elsif (/^#(define|undef)\s+I386_ONLY/)
+		{ printf OUT "#%s I386_ONLY\n", ($processor eq "386")?
+			"define":"undef"; }
+	elsif	(/^#define\s+MD2_INT\s/)
+		{ printf OUT "#define MD2_INT unsigned %s\n",$type[$md2_int]; }
+	elsif	(/^#define\s+IDEA_INT\s/)
+		{printf OUT "#define IDEA_INT unsigned %s\n",$type[$idea_int];}
+	elsif	(/^#define\s+RC2_INT\s/)
+		{printf OUT "#define RC2_INT unsigned %s\n",$type[$rc2_int];}
+	elsif (/^#(define|undef)\s+BF_PTR/)
+		{
+		printf OUT "#undef BF_PTR\n" if $bf_ptr == 0;
+		printf OUT "#define BF_PTR\n" if $bf_ptr == 1;
+		printf OUT "#define BF_PTR2\n" if $bf_ptr == 2;
+	        }
+	else
+		{ print OUT $_; }
+	}
+close(IN);
+close(OUT);
+rename("crypto/opensslconf.h","crypto/opensslconf.h.bak") || die "unable to rename crypto/opensslconf.h\n" if -e "crypto/opensslconf.h";
+rename("crypto/opensslconf.h.new","crypto/opensslconf.h") || die "unable to rename crypto/opensslconf.h.new\n";
+
+
+# Fix the date
+
+print "SIXTY_FOUR_BIT_LONG mode\n" if $b64l;
+print "SIXTY_FOUR_BIT mode\n" if $b64;
+print "THIRTY_TWO_BIT mode\n" if $b32;
+print "SIXTEEN_BIT mode\n" if $b16;
+print "EIGHT_BIT mode\n" if $b8;
+print "DES_PTR used\n" if $des_ptr;
+print "DES_RISC1 used\n" if $des_risc1;
+print "DES_RISC2 used\n" if $des_risc2;
+print "DES_UNROLL used\n" if $des_unroll;
+print "DES_INT used\n" if $des_int;
+print "BN_LLONG mode\n" if $bn_ll;
+print "RC4 uses u$type[$rc4_int]\n" if $rc4_int != $def_int;
+print "RC4_INDEX mode\n" if $rc4_idx;
+print "RC4_CHUNK is undefined\n" if $rc4_chunk==0;
+print "RC4_CHUNK is unsigned long\n" if $rc4_chunk==1;
+print "RC4_CHUNK is unsigned long long\n" if $rc4_chunk==2;
+print "MD2 uses u$type[$md2_int]\n" if $md2_int != $def_int;
+print "IDEA uses u$type[$idea_int]\n" if $idea_int != $def_int;
+print "RC2 uses u$type[$rc2_int]\n" if $rc2_int != $def_int;
+print "BF_PTR used\n" if $bf_ptr == 1; 
+print "BF_PTR2 used\n" if $bf_ptr == 2; 
+
+if($IsMK1MF) {
+	open (OUT,">crypto/buildinf.h") || die "Can't open buildinf.h";
+	printf OUT <<EOF;
+#ifndef MK1MF_BUILD
+  /* auto-generated by Configure for crypto/cversion.c:
+   * for Unix builds, crypto/Makefile.ssl generates functional definitions;
+   * Windows builds (and other mk1mf builds) compile cversion.c with
+   * -DMK1MF_BUILD and use definitions added to this file by util/mk1mf.pl. */
+  #error "Windows builds (PLATFORM=$target) use mk1mf.pl-created Makefiles"
+#endif
+EOF
+	close(OUT);
+} else {
+	my $make_command = "make PERL=\'$perl\'";
+	my $make_targets = "";
+	$make_targets .= " links" if $symlink;
+	$make_targets .= " depend" if $depflags ne $default_depflags && $make_depend;
+	$make_targets .= " gentests" if $symlink;
+	(system $make_command.$make_targets) == 0 or exit $?
+		if $make_targets ne "";
+	if ( $perl =~ m@^/@) {
+	    &dofile("tools/c_rehash",$perl,'^#!/', '#!%s','^my \$dir;$', 'my $dir = "' . $openssldir . '";');
+	    &dofile("apps/CA.pl",$perl,'^#!/', '#!%s');
+	} else {
+	    # No path for Perl known ...
+	    &dofile("tools/c_rehash",'/usr/local/bin/perl','^#!/', '#!%s','^my \$dir;$', 'my $dir = "' . $openssldir . '";');
+	    &dofile("apps/CA.pl",'/usr/local/bin/perl','^#!/', '#!%s');
+	}
+	if ($depflags ne $default_depflags && !$make_depend) {
+		print <<EOF;
+
+Since you've disabled or enabled at least one algorithm, you need to do
+the following before building:
+
+	make depend
+EOF
+	}
+}
+
+# create the ms/version32.rc file if needed
+if ($IsMK1MF && ($target !~ /^netware/)) {
+	my ($v1, $v2, $v3, $v4);
+	if ($version_num =~ /(^[0-9a-f]{1})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})/i) {
+		$v1=hex $1;
+		$v2=hex $2;
+		$v3=hex $3;
+		$v4=hex $4;
+	}
+	open (OUT,">ms/version32.rc") || die "Can't open ms/version32.rc";
+	print OUT <<EOF;
+#include <winver.h>
+
+LANGUAGE 0x09,0x01
+
+1 VERSIONINFO
+  FILEVERSION $v1,$v2,$v3,$v4
+  PRODUCTVERSION $v1,$v2,$v3,$v4
+  FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+  FILEFLAGS 0x01L
+#else
+  FILEFLAGS 0x00L
+#endif
+  FILEOS VOS__WINDOWS32
+  FILETYPE VFT_DLL
+  FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+	BLOCK "040904b0"
+	BEGIN
+	    // Required:	    
+	    VALUE "CompanyName", "The OpenSSL Project, http://www.openssl.org/\\0"
+	    VALUE "FileDescription", "OpenSSL Shared Library\\0"
+	    VALUE "FileVersion", "$version\\0"
+#if defined(CRYPTO)
+	    VALUE "InternalName", "libeay32\\0"
+	    VALUE "OriginalFilename", "libeay32.dll\\0"
+#elif defined(SSL)
+	    VALUE "InternalName", "ssleay32\\0"
+	    VALUE "OriginalFilename", "ssleay32.dll\\0"
+#endif
+	    VALUE "ProductName", "The OpenSSL Toolkit\\0"
+	    VALUE "ProductVersion", "$version\\0"
+	    // Optional:
+	    //VALUE "Comments", "\\0"
+	    VALUE "LegalCopyright", "Copyright  1998-2005 The OpenSSL Project. Copyright  1995-1998 Eric A. Young, Tim J. Hudson. All rights reserved.\\0"
+	    //VALUE "LegalTrademarks", "\\0"
+	    //VALUE "PrivateBuild", "\\0"
+	    //VALUE "SpecialBuild", "\\0"
+	END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 0x4b0
+    END
+END
+EOF
+	close(OUT);
+  }
+  
+print <<EOF;
+
+Configured for $target.
+EOF
+
+print <<\EOF if (!$no_threads && !$threads);
+
+The library could not be configured for supporting multi-threaded
+applications as the compiler options required on this system are not known.
+See file INSTALL for details if you need multi-threading.
+EOF
+
+print <<\EOF if ($no_shared_warn);
+
+You gave the option 'shared'.  Normally, that would give you shared libraries.
+Unfortunately, the OpenSSL configuration doesn't include shared library support
+for this platform yet, so it will pretend you gave the option 'no-shared'.  If
+you can inform the developpers (openssl-dev\@openssl.org) how to support shared
+libraries on this platform, they will at least look at it and try their best
+(but please first make sure you have tried with a current version of OpenSSL).
+EOF
+
+exit(0);
+
+sub usage
+	{
+	print STDERR $usage;
+	print STDERR "\npick os/compiler from:\n";
+	my $j=0;
+	my $i;
+        my $k=0;
+	foreach $i (sort keys %table)
+		{
+		next if $i =~ /^debug/;
+		$k += length($i) + 1;
+		if ($k > 78)
+			{
+			print STDERR "\n";
+			$k=length($i);
+			}
+		print STDERR $i . " ";
+		}
+	foreach $i (sort keys %table)
+		{
+		next if $i !~ /^debug/;
+		$k += length($i) + 1;
+		if ($k > 78)
+			{
+			print STDERR "\n";
+			$k=length($i);
+			}
+		print STDERR $i . " ";
+		}
+	print STDERR "\n\nNOTE: If in doubt, on Unix-ish systems use './config'.\n";
+	exit(1);
+	}
+
+sub which
+	{
+	my($name)=@_;
+	my $path;
+	foreach $path (split /:/, $ENV{PATH})
+		{
+		if (-f "$path/$name$exe_ext" and -x _)
+			{
+			return "$path/$name$exe_ext" unless ($name eq "perl" and
+			 system("$path/$name$exe_ext -e " . '\'exit($]<5.0);\''));
+			}
+		}
+	}
+
+sub dofile
+	{
+	my $f; my $p; my %m; my @a; my $k; my $ff;
+	($f,$p,%m)=@_;
+
+	open(IN,"<$f.in") || open(IN,"<$f") || die "unable to open $f:$!\n";
+	@a=<IN>;
+	close(IN);
+	foreach $k (keys %m)
+		{
+		grep(/$k/ && ($_=sprintf($m{$k}."\n",$p)),@a);
+		}
+	open(OUT,">$f.new") || die "unable to open $f.new:$!\n";
+	print OUT @a;
+	close(OUT);
+	rename($f,"$f.bak") || die "unable to rename $f\n" if -e $f;
+	rename("$f.new",$f) || die "unable to rename $f.new\n";
+	}
+
+sub print_table_entry
+	{
+	my $target = shift;
+
+	(my $cc,my $cflags,my $unistd,my $thread_cflag,my $sys_id,my $lflags,
+	my $bn_ops,my $cpuid_obj,my $bn_obj,my $des_obj,my $aes_obj, my $bf_obj,
+	my $md5_obj,my $sha1_obj,my $cast_obj,my $rc4_obj,my $rmd160_obj,
+	my $rc5_obj,my $dso_scheme,my $shared_target,my $shared_cflag,
+	my $shared_ldflag,my $shared_extension,my $ranlib,my $arflags)=
+	split(/\s*:\s*/,$table{$target} . ":" x 30 , -1);
+			
+	print <<EOF
+
+*** $target
+\$cc           = $cc
+\$cflags       = $cflags
+\$unistd       = $unistd
+\$thread_cflag = $thread_cflag
+\$sys_id       = $sys_id
+\$lflags       = $lflags
+\$bn_ops       = $bn_ops
+\$cpuid_obj    = $cpuid_obj
+\$bn_obj       = $bn_obj
+\$des_obj      = $des_obj
+\$aes_obj      = $aes_obj
+\$bf_obj       = $bf_obj
+\$md5_obj      = $md5_obj
+\$sha1_obj     = $sha1_obj
+\$cast_obj     = $cast_obj
+\$rc4_obj      = $rc4_obj
+\$rmd160_obj   = $rmd160_obj
+\$rc5_obj      = $rc5_obj
+\$dso_scheme   = $dso_scheme
+\$shared_target= $shared_target
+\$shared_cflag = $shared_cflag
+\$shared_ldflag = $shared_ldflag
+\$shared_extension = $shared_extension
+\$ranlib       = $ranlib
+\$arflags      = $arflags
+\$/benchmarks  = $/benchmarks
+EOF
+	}
+
+sub test_sanity
+	{
+	my $errorcnt = 0;
+
+	print STDERR "=" x 70, "\n";
+	print STDERR "=== SANITY TESTING!\n";
+	print STDERR "=== No configuration will be done, all other arguments will be ignored!\n";
+	print STDERR "=" x 70, "\n";
+
+	foreach $target (sort keys %table)
+		{
+		@fields = split(/\s*:\s*/,$table{$target} . ":" x 30 , -1);
+
+		if ($fields[$idx_dso_scheme-1] =~ /^(dl|dlfcn|win32|vms)$/)
+			{
+			$errorcnt++;
+			print STDERR "SANITY ERROR: '$target' has the dso_scheme [$idx_dso_scheme] values\n";
+			print STDERR "              in the previous field\n";
+			}
+		elsif ($fields[$idx_dso_scheme+1] =~ /^(dl|dlfcn|win32|vms)$/)
+			{
+			$errorcnt++;
+			print STDERR "SANITY ERROR: '$target' has the dso_scheme [$idx_dso_scheme] values\n";
+			print STDERR "              in the following field\n";
+			}
+		elsif ($fields[$idx_dso_scheme] !~ /^(dl|dlfcn|win32|vms|)$/)
+			{
+			$errorcnt++;
+			print STDERR "SANITY ERROR: '$target' has the dso_scheme [$idx_dso_scheme] field = ",$fields[$idx_dso_scheme],"\n";
+			print STDERR "              valid values are 'dl', 'dlfcn', 'win32' and 'vms'\n";
+			}
+		}
+	print STDERR "No sanity errors detected!\n" if $errorcnt == 0;
+	return $errorcnt;
+	}
+
+# Attempt to detect MSYS environment
+
+sub is_msys
+	{
+	return 1 if (exists $ENV{"TERM"} && $ENV{"TERM"} eq "msys");
+	return 0;
+	}

language: node_js
sudo: false
node_js:
- '4.2.1'

branches:
  except:
    - g3sync

cache:
  directories:
    - node_modules
    - $HOME/.pub-cache

env:
  global:
  - KARMA_BROWSERS=DartiumWithWebPlatform
  - E2E_BROWSERS=Dartium
  - LOGS_DIR=/tmp/angular-build/logs
  - SAUCE_USERNAME=angular-ci
  - SAUCE_ACCESS_KEY=9b988f434ff8-fbca-8aa4-4ae3-35442987
  - BROWSER_STACK_USERNAME=angularteam1
  - BROWSER_STACK_ACCESS_KEY=BWCd4SynLzdDcv8xtzsB
  - ARCH=linux-x64
  - DART_DEV_VERSION=latest
  - DART_STABLE_VERSION=latest
  # Token for tsd to increase github rate limit
  # See https://github.com/DefinitelyTyped/tsd#tsdrc
  # This does not use http://docs.travis-ci.com/user/environment-variables/#Secure-Variables
  # because those are not visible for pull requests, and those should also be reliable.
  # This SSO token belongs to github account angular-github-ratelimit-token which has no access
  # (password is in Valentine)
  - TSDRC='{"token":"ef474500309daea53d5991b3079159a29520a40b"}'
  # GITHUB_TOKEN_ANGULAR
  - secure: "fq/U7VDMWO8O8SnAQkdbkoSe2X92PVqg4d044HmRYVmcf6YbO48+xeGJ8yOk0pCBwl3ISO4Q2ot0x546kxfiYBuHkZetlngZxZCtQiFT9kyId8ZKcYdXaIW9OVdw3Gh3tQyUwDucfkVhqcs52D6NZjyE2aWZ4/d1V4kWRO/LMgo="
  matrix:
    # Order: a slower build first, so that we don't occupy an idle travis worker waiting for others to complete.
    - MODE=dart DART_CHANNEL=stable DART_VERSION=$DART_STABLE_VERSION
    - MODE=dart DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
    - MODE=saucelabs_required DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
    - MODE=browserstack_required DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
    - MODE=saucelabs_optional DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
    - MODE=browserstack_optional DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
    - MODE=dart_experimental DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
    - MODE=js DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
    - MODE=router DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
    - MODE=build_only DART_CHANNEL=stable DART_VERSION=$DART_STABLE_VERSION
    - MODE=lint DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION
    - MODE=payload DART_CHANNEL=stable DART_VERSION=$DART_STABLE_VERSION

matrix:
  allow_failures:
  - env: "MODE=saucelabs_optional DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"
  - env: "MODE=browserstack_optional DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"
  - env: "MODE=dart_experimental DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"
  # TODO(alxhub): remove when dartdoc #1039 is in dev channel
  - env: "MODE=dart DART_CHANNEL=dev DART_VERSION=$DART_DEV_VERSION"

addons:
  firefox: "38.0"

before_install:
- node tools/analytics/build-analytics start ci job
- node tools/analytics/build-analytics start ci before_install
- echo ${TSDRC} > .tsdrc
- export DISPLAY=:99.0
- export GIT_SHA=$(git rev-parse HEAD)
- ./scripts/ci/init_android.sh
- ./scripts/ci/install_dart.sh ${DART_CHANNEL} ${DART_VERSION} ${ARCH}
- sh -e /etc/init.d/xvfb start
- if [[ -e SKIP_TRAVIS_TESTS ]]; then { cat SKIP_TRAVIS_TESTS ; exit 0; } fi
- '[ "${TRAVIS_PULL_REQUEST}" = "false" ] && [ "${TRAVIS_BRANCH}" = "master" ] && SAUCE_USERNAME="angular2-ci" && SAUCE_ACCESS_KEY="693ebc16208a-0b5b-1614-8d66-a2662f4e" || true'
- node tools/analytics/build-analytics success ci before_install

install:
  - node tools/analytics/build-analytics start ci install
  # Check the size of caches
  - du -sh ./node_modules || true
  # Install npm dependecies
  - npm install
  - node tools/analytics/build-analytics success ci install

before_script:
- node tools/analytics/build-analytics start ci before_script
- mkdir -p $LOGS_DIR
- ./scripts/ci/presubmit-queue-setup.sh
- node tools/analytics/build-analytics success ci before_script

script:
- node tools/analytics/build-analytics start ci script
- ./scripts/ci/build_and_test.sh ${MODE}
- node tools/analytics/build-analytics success ci script

after_script:
- node tools/analytics/build-analytics start ci after_script
- ./scripts/ci/print-logs.sh
- ./scripts/ci/after-script.sh
- ./scripts/publish/publish-build-artifacts.sh
- node tools/analytics/build-analytics success ci after_script
- if [[ $TRAVIS_TEST_RESULT -eq 0 ]]; then node tools/analytics/build-analytics success ci job; else node tools/analytics/build-analytics error ci job; fi

notifications:
  webhooks:
    urls:
    - https://webhooks.gitter.im/e/1ef62e23078036f9cee4
    # trigger Buildtime Trend Service to parse Travis CI log
    - https://buildtimetrend.herokuapp.com/travis
    on_success: always  # options: [always|never|change] default: always
    on_failure: always  # options: [always|never|change] default: always
    on_start: false     # default: false
  slack:
    secure: EP4MzZ8JMyNQJ4S3cd5LEPWSMjC7ZRdzt3veelDiOeorJ6GwZfCDHncR+4BahDzQAuqyE/yNpZqaLbwRWloDi15qIUsm09vgl/1IyNky1Sqc6lEknhzIXpWSalo4/T9ZP8w870EoDvM/UO+LCV99R3wS8Nm9o99eLoWVb2HIUu0=

